import { IDetailArticle } from "blog"

const images = {
  firstVue: require("@/assets/firstVue.gif"),
  board: require("@/assets/board.png"),
  human: require("@/assets/human.gif"),
  msp0: require("@/assets/msp0.gif"),
  msp0struct: require("@/assets/msp0.png"),
  vsp0: require("@/assets/vsp0all.png"),
  vsp0Effect: require("@/assets/vsp0.gif"),
  vsp0struct: require("@/assets/vsp0.png"),
}
export const projectItem = {
  1: {
    code: 200,
    data: {
      id: 1,
      title: "第一个vue页面",
      description: "使用vue做的第一个看板",
      scanNumber: "1",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "%E7%AC%AC%E4%B8%80%E4%B8%AA-vue-%E9%A1%B5%E9%9D%A2",
          name: "第一个 Vue 页面",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            { anchor: "template", name: "template", tag: "h2", children: [] },
            {
              anchor: "options",
              name: "options",
              tag: "h2",
              children: [
                { anchor: "data", name: "data", tag: "h3", children: [] },
                { anchor: "method", name: "method", tag: "h3", children: [] },
                { anchor: "computed", name: "computed", tag: "h3", children: [] },
              ],
            },
            { anchor: "%E6%80%BB%E7%BB%93", name: "总结", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent: `<h1 id="%E7%AC%AC%E4%B8%80%E4%B8%AA-vue-%E9%A1%B5%E9%9D%A2" tabindex="-1">第一个 Vue 页面</h1>\n<h2 id="%E6%95%88%E6%9E%9C" tabindex="-1">效果</h2>\n<p><img src="${images.firstVue}" alt="firstVue"></p>\n<h2 id="template" tabindex="-1">template</h2>\n<p>写死的东西太多,computed 传参也不太好,这种 style 我感觉换类可能更舒服一点,table-column里面的v-if感觉纯属浪费……</p>\n<pre><code class="language-ts"> &lt;el-table\n      ref=&quot;lightTable&quot;\n      tooltip-effect=&quot;dark&quot;\n      style=&quot;width: 100%&quot;\n      :height=&quot;tableHeight&quot;\n      border\n      :data=&quot;tableData&quot;\n      @select=&quot;hide&quot;\n      @cell-mouse-enter=&quot;getMSG&quot;\n      :header-cell-class-name=&quot;cellClass&quot;\n    &gt;\n      &lt;el-table-column type=&quot;selection&quot; align=&quot;center&quot;&gt; &lt;/el-table-column&gt;\n\n      &lt;el-table-column label=&quot;线体&quot; align=&quot;center&quot; prop=&quot;line&quot;&gt;\n      &lt;/el-table-column&gt;\n      &lt;el-table-column\n        v-for=&quot;i in stations&quot;\n        :key=&quot;i&quot;\n        :label=&quot;i&quot;\n        align=&quot;center&quot;\n        :prop=&quot;i&quot;\n      &gt;\n        &lt;template slot-scope=&quot;scope&quot;&gt;\n          &lt;div\n            v-if=&quot;scope.row[scope.column.property] === \'bgcRunning\'&quot;\n            @click=&quot;turnTOWeb&quot;\n            :style=&quot;bgcComputed(\'bgcRunning\')&quot;\n          &gt;\n            &amp;emsp;\n          &lt;/div&gt;\n          &lt;div\n            v-else-if=&quot;scope.row[scope.column.property] == \'bgcWaitRepair\'&quot;\n            :style=&quot;bgcComputed(\'bgcWaitRepair\')&quot;\n            @click=&quot;turnTOWeb&quot;\n          &gt;\n            &amp;emsp;\n          &lt;/div&gt;\n\t\t//   ...\n\n        &lt;/template&gt;\n      &lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n</code></pre>\n<h2 id="options" tabindex="-1">options</h2>\n<h3 id="data" tabindex="-1">data</h3>\n<p>东西太多，太乱。style的设置放data里也没用必要。类型也有错误的。</p>\n<pre><code class="language-ts">  data(){\n\treturn {\n\t\t    tableData: [],\n\t\t\tstations: [], //列\n\t\t\tlines: [],    //行\n\t\t\tdisLine: [],  //只显示被勾选的行\n\t\t\ttableHeight: &quot;1000px&quot;,\n\t\t\ttimer1: null,  //短轮训timer\n\t\t\ttimer2: null,\n\t\t\t/**\n\t\t\t * @type {\n\t\t\t *     {\n\t\t\t *        [line,statin]: value\n\t\t\t *     }\n\t\t\t * }\n\t\t\t */\n\t\t\tBoardInfo: &quot;&quot;,  //存放灯号信息,明明是个对象 \n\t\t\tbgcRunning: [{ &quot;background-color&quot;: &quot;#00B050&quot; }], //正常运行的特殊颜色，下同\n\t\t\tbgc: [\n\t\t\t\t//通用属性\n\t\t\t\t{ &quot;border-radius&quot;: &quot;50%&quot; },\n\t\t\t\t{ width: &quot;20px&quot; },\n\t\t\t\t{ height: &quot;20px&quot; },\n\t\t\t\t{ &quot;margin-left&quot;: &quot;50%&quot; },\n\t\t\t\t{ transform: &quot;translateX(-50%)&quot; },\n\t\t\t],\n\t\t\tbgc5MinsUnRepair: [{ &quot;background-color&quot;: &quot;red&quot; }],\n\t\t\tbgc5MinsRepairing: [{ &quot;background-color&quot;: &quot;#FF9900&quot; }],\n\t\t\tbgcGrayFlash: [{ &quot;background-color&quot;: &quot;gray&quot; }],\n\t\t\tbgcBlueFlash: [{ &quot;background-color&quot;: &quot;#0000FF&quot; }],\n\t\t\tbgcWaitRepair: [{ &quot;background-color&quot;: &quot;red&quot; }],\n\t\t\tbgcNoEquipment: [{ &quot;background-color&quot;: &quot;white&quot; }],\n\t\t\tbgcUnUse: [{ &quot;background-color&quot;: &quot;#A6A6A6&quot; }],\n\t\t\tbgcBlue: [{ &quot;background-color&quot;: &quot;#0000FF&quot; }],\n\t\t\tbgcRepairing: [{ &quot;background-color&quot;: &quot;#FF9900&quot; }],\n\n\t\t\tbgcContrl: true, //控制闪烁\n\t}\n  }\n</code></pre>\n<h3 id="method" tabindex="-1">method</h3>\n<pre><code class="language-ts">//Boardinfo=&gt;tableData\n\nmethods:{\n\t//太可怕了，居然会操作字符串,而且需要分if else吗\nDisplay() {\n      //显示控制，生成表格对应的json\n      if (this.disLine.length === 0) {\n        //全部显示\n        var Lines = this.lines;\n        var tboby = &quot;&quot;;\n        var Boardinfo = this.BoardInfo;\n        var Station = this.stations;\n        for (var i = 0; i &lt; Lines.length; i++) {\n          if (i != 0) {\n            tboby += \'{&quot;line&quot;:&quot;\' + Lines[i] + \'&quot;,\';\n          } else {\n            tboby += \'[{&quot;line&quot;:&quot;\' + Lines[i] + \'&quot;,\';\n          }\n\n          for (var j = 0; j &lt; Station.length; j++) {\n            var station = Station[j];\n            var bgc = &quot;&quot;;\n            //判断JSON Array中是否包含value2=line value3=station。如果有的话，那么就取当前JSON中的值\n            var JsonKey = Lines[i] + &quot;,&quot; + station;\n            if (this.isHasAttr(Boardinfo, JsonKey)) {\n              switch (Boardinfo[JsonKey]) {\n                case &quot;1&quot;:\n                  bgc = &quot;bgcRunning&quot;;\n                  break;\n                case &quot;2&quot;:\n                  bgc = &quot;bgcWaitRepair&quot;;\n                  break;\n                case &quot;3&quot;:\n                  bgc = &quot;bgc5MinsUnRepair&quot;;\n                  break;\n                case &quot;4&quot;:\n                  bgc = &quot;bgcRepairing&quot;;\n                  break;\n                case &quot;5&quot;:\n                  bgc = &quot;bgc5MinsRepairing&quot;;\n                  break;\n                case &quot;6&quot;:\n                  bgc = &quot;bgcUnUse&quot;; //bgcNoEquipment\n                  break;\n                case &quot;7&quot;:\n                  bgc = &quot;bgcGrayFlash&quot;;\n                  break;\n                case &quot;8&quot;:\n                  bgc = &quot;bgcBlue&quot;;\n                  break;\n                case &quot;9&quot;:\n                  bgc = &quot;bgcBlueFlash&quot;;\n                  break;\n              }\n            }\n            if (j != Station.length - 1) {\n              tboby += \'&quot;\' + station + \'&quot;:\' + \'&quot;\' + bgc + \'&quot;,\';\n            } else {\n              tboby += \'&quot;\' + station + \'&quot;:\' + \'&quot;\' + bgc + \'&quot;\';\n            }\n          }\n          if (i != Lines.length - 1) {\n            tboby += &quot;},&quot;;\n          } else {\n            tboby += &quot;}]&quot;;\n          }\n        }\n        this.tableData = JSON.parse(tboby);\n      } else {\n        var Lines = this.disLine;\n        var tboby = &quot;&quot;;\n        var Boardinfo = this.BoardInfo;\n        var Station = this.stations;\n        for (var i = 0; i &lt; Lines.length; i++) {\n          if (i != 0) {\n            tboby += \'{&quot;line&quot;:&quot;\' + Lines[i] + \'&quot;,\';\n          } else {\n            tboby += \'[{&quot;line&quot;:&quot;\' + Lines[i] + \'&quot;,\';\n          }\n        //   ……\n        this.tableData = JSON.parse(tboby);\n      }\n    },\n\t //通过时间间隔改变控制属性，结合computed中 bgcComputed达到闪烁目的\n\t bgcControl() {\n      this.bgcContrl = !this.bgcContrl;\n    },\n}\n</code></pre>\n<h3 id="computed" tabindex="-1">computed</h3>\n<pre><code class="language-ts">  computed: {\n    bgcComputed() {\n      return function (x) {\n        var BGC = [];\n        switch (x) {\n          case &quot;bgcRunning&quot;:\n            BGC = this.bgcRunning;\n            return this.bgc.concat(BGC);\n          // break;\n          case &quot;bgcWaitRepair&quot;:\n            BGC = this.bgcWaitRepair;\n            return this.bgc.concat(BGC);\n          // break;\n          case &quot;bgc5MinsUnRepair&quot;:\n            BGC = this.bgc5MinsUnRepair;\n            break;\n          case &quot;bgcRepairing&quot;:\n            BGC = this.bgcRepairing;\n            // break;\n            return this.bgc.concat(BGC);\n          case &quot;bgc5MinsRepairing&quot;:\n            BGC = this.bgc5MinsRepairing;\n            break;\n          case &quot;bgcUnUse&quot;:\n            BGC = this.bgcUnUse;\n            // break;\n            return this.bgc.concat(BGC);\n          case &quot;bgcGrayFlash&quot;:\n            BGC = this.bgcGrayFlash;\n            break;\n          case &quot;bgcBlue&quot;:\n            BGC = this.bgcBlue;\n            return this.bgc.concat(BGC);\n          // break;\n          case &quot;bgcBlueFlash&quot;:\n            BGC = this.bgcBlueFlash;\n            break;\n        }\n        var res = this.bgcContrl ? this.bgc.concat(BGC) : this.bgc;\n        return res;\n      };\n    },\n  },\n</code></pre>\n<h2 id="%E6%80%BB%E7%BB%93" tabindex="-1">总结</h2>\n<p>现在看起来，这个页面没用任何难度。但对于新手来说，特别是ES6,CSS也不熟悉的人来说还是有点难度的。</p>\n<p>如果现在的我来写,直接计算出全部表格数据，通过computed控制显示</p>\n<pre><code class="language-ts">  data(){\n\treturn {\n\t\t//获取行列直接计算出全部的数据\n\t\ttableData:[],\n\t\tdisplayLines:[]\n\t}\n  },\n  methods:{\n\t setTableData(){\n\t\t const res = [] \n\t\t for(let i of Object.keys(BoardInfo)){\n\t\t\tconst [line,station] = i.split(&quot;,&quot;)\n\t\t\tres.push({line,station,value:BoardInfo[i]})\n\t\t }\n\t\t this.tableData = res\n\t }\n  },\n  computed:{\n\tdisplayTableData(){\n        return this.tableData.filter(x=&gt;displayLines.includes(x.line))\n\t}\n  }\n\n</code></pre>\n<p>闪烁很明显使用简单的animation就完成了,用js控制真没必要</p>\n<pre><code class="language-less">@bgcWaitRepair: red;\n.bgc{\n\t&amp;.bgcWaitRepair{\n\t\tbackground:@bgcWaitRepair;\n\t\tanimation: flicker .3s infinite;\n\t}\n}\n@keyframes flicker {\n\t0%{\n\t\topacity:1;\n\t}\n\t50%{\n\t\topacity:0;\n\t}\n\t100%{\n\t\topacity:1;\n\t}\n};\n</code></pre>\n`,
    },
  },
  2: {
    code: 200,
    data: {
      id: 2,
      title: "human management",
      description: "简单的人员管理系统",
      scanNumber: "0",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86",
          name: "人员管理",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            { anchor: "%E5%90%8E%E7%AB%AF", name: "后端", tag: "h2", children: [] },
            { anchor: "%E5%89%8D%E7%AB%AF", name: "前端", tag: "h2", children: [] },
            { anchor: "%E6%80%BB%E7%BB%93", name: "总结", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent: `<h1 id=\"%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86\" tabindex=\"-1\">人员管理</h1>\n<h2 id=\"%E6%95%88%E6%9E%9C\" tabindex=\"-1\">效果</h2>\n<p><img src=\"${images.human}\" alt=\"human\"></p>\n<h2 id=\"%E5%90%8E%E7%AB%AF\" tabindex=\"-1\">后端</h2>\n<p>公司使用还是.Net Framework4.0,\nRoute</p>\n<pre><code class=\"language-C#\">//  Route 对应 handler  xxx.ashx\n public class basicInfo : IHttpHandler{\n basicInfo_BLL bInfo = new basicInfo_BLL();\n public void ProcessRequest(HttpContext context)\n        {\n\t\t\t//CORS\n            context.Response.ContentType = &quot;text/plain&quot;;\n            context.Response.AddHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n            context.Response.AddHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;);\n            context.Response.AddHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);\n            string action = context.Request[&quot;action&quot;];\n\t\t\t//路由还不是Rest风格\n            switch (action)\n            {\n                case &quot;getTable&quot;:\n                    getTable(context);\n                    break;\n                // ...\n\n            }\n}\nprivate void getTable(HttpContext context){\n            //自己写的Action,统一处理错误\n            Try(() =&gt;\n            {\n                context.Response.Write(bInfo.search(context.Request[&quot;dept&quot;], context.Request[&quot;id&quot;],...);\n            });\n}\n\n}\n\n\n</code></pre>\n<p>BLL 略</p>\n<pre><code class=\"language-C#\">    public class basicInfo_BLL\n    {\n        basicInfo_DAL bInfo = new basicInfo_DAL();\n        public string search(string dept,string id,string name,string line,string position)\n        {\n            string condition = getCondition(dept, &quot;dept&quot;) + getCondition(id, &quot;id&quot;) + getCondition(name, &quot;cName&quot;) + getCondition(line, &quot;line&quot;) + getCondition(position,&quot;position&quot;);\n            return bInfo.search(condition);\n \n        }\n\t\t...\n\t}\n</code></pre>\n<p>DAL 以直接的sql语句+Linq为主</p>\n<pre><code class=\"language-ts\">  public List&lt;basicData_Model&gt; SearchList(string condition){\n\n     string factory = &quot;MSM0&quot;;\n            string cmd2 = string.Format(@&quot;select * from\n(\n     select company,dept,id,cName,eName,line,position,gender,enterDate,leaveDate,homeAddress,telephone,wechat,email,emergencyContact,station,responseRegion,factory,region,rownumber,EMSIdentity \n\t from HM_BasicInfo where isValid ='Y' and factory='{1}' {0}\n) A\nleft join\n(\n\t select value2 ,value6 shiftAB,term hmProperty,rowNum EMSRowNum,value1,value4 from EMS_Maintain \n\t\twhere system_type='打卡看板' and value4 = 'MSM0'  and term in ('领班','出席信息','组长','工程师') and validYN = 'Y'\n) B on id = value2 and  factory = value4 and region = value1 and EMSIdentity=hmProperty order by rownumber desc&quot;, condition, factory);\n\n            List&lt;basicData_Model&gt; list = SqlHelper.GetList&lt;basicData_Model&gt;(cmd2).Select(x =&gt;\n            {\n                x.emergencyContact = x.emergencyContact.Trim();\n                x.leaveDate = System.Text.RegularExpressions.Regex.IsMatch(x.leaveDate, @&quot;1900.*&quot;) ? &quot;&quot; : DateTime.Parse(x.leaveDate).ToString(&quot;yyyy-MM-dd&quot;);\n\n                x.enterDate = DateTime.Parse(x.enterDate).ToString(&quot;yyyy-MM-dd&quot;);\n                return x;\n            }).ToList();\n            return list;\n        }\n</code></pre>\n<h2 id=\"%E5%89%8D%E7%AB%AF\" tabindex=\"-1\">前端</h2>\n<p>慢慢开始接近我现在的风格了,但是还差很远，这个初始化就感觉回到了jQuery,完全没用理解到模块化的好处。</p>\n<pre><code class=\"language-ts\">     init(){\n           let labels =['公司别','部门','工号','姓名','英文名','线别','职务','性别',\n           '入职日','离职日期','户籍地址','电话','微信','邮箱','紧急联络人','班别','人员属性','设备别','负责区域(线体)','厂别','车间']\n           let prop = ['company','dept','id','cName','eName','line','position','gender','enterDate',\n           'leaveDate','homeAddress','telephone','wechat','email','emergencyContact','shiftAB','hmProperty','station','responseRegion','factory','region']\n           let table = {\n                label:[],\n                height:window.innerHeight*0.75,\n                data:[]\n           }\n           let widthArr = {\n               'company':'70px',\n               'line':'70px',\n               'gender':'50px',\n               'shiftAB':'50px',\n               'station':'200px',\n               'responseRegion':'200px',\n               'homeAddress':'180px'\n           }\n           for(let i = 0;i&lt;labels.length;i++){\n              table.label.push({label:labels[i],prop:prop[i],width:widthArr[prop[i]]})\n           }\n           this.tableData = table   \n           this.paginationData = {\n               sizes : [10,15,20,30],\n               size:20,\n               total:null,\n               currentPage:1\n           }\n           Promise.resolve().then(()=&gt;{\n               let array = ['homeAddress','telephone','wechat','email','emergencyContact','station','responseRegion']\n               this.editableData = array\n               this.testInput = {\n                    email:x=&gt; /^([a-zA-Z]|[0-9])(\\w|\\-)+@[a-zA-Z0-9]+\\.([a-zA-Z]{2,4})$/.test(x),\n                    telephone:x=&gt;/^1\\d{10}$/.test(x),\n                    wechat:x=&gt;/^1\\d{10}$/.test(x),\n                    emergencyContact:x=&gt;/^1[3|4|5|8][0-9]\\d{4,8}$/.test(x),\n                    homeAddress:x=&gt;/[\\u4e00-\\u9fa5]+/.test(x),\n               }\n\n           }).then(()=&gt;{\n               this.getSelectInfo()\n           })\n           \n\n        },\n</code></pre>\n<p>当然也开始尝试写一些共用方法了，虽然不忍直视,而且还是CommonJs那种导入，当然webpack无所谓，也没用用户ts。</p>\n<pre><code class=\"language-ts\">async function getData(url,param={},type='post'){\n    let axios = require('axios')\n    function PostData(){\n        let qs = require('qs')\n        return  qs.stringify(param,{ indices: false })\n    }\n   return axios[type](url,type===&quot;post&quot;?PostData():{params:param}).then(value=&gt;value.data,reason=&gt;{console.error(reason); throw reason}).catch((e)=&gt;{})\n}\n\nasync function excelOut(name='excel',header=[],series=[]){\n    const ExportJsonExcel = require(&quot;js-export-excel&quot;);\n    let option = {\n        fileName:name,\n        datas:[{\n            sheetHeader:header,\n            // sheetName: &quot;sheet&quot;,\n            sheetData:series\n         }]\n    }\n    setTimeout(() =&gt; {\n        let toExcel = new ExportJsonExcel(option); //new\n        toExcel.saveExcel();\n    }, 0); \n}\n</code></pre>\n<p>数据管理混乱，很明显感觉数据应该在父组件里。不管是formData，又或者是tableData。</p>\n<pre><code class=\"language-ts\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;Selects ref=&quot;Inputs&quot; @updateTable=&quot;updateTable&quot; @saveData=&quot;saveData&quot; @excelOut=&quot;excelOut&quot; @addItem=&quot;addItem&quot; /&gt;\n        &lt;Table ref=&quot;Table&quot; @rowClick=&quot;updateInputs&quot; style=&quot;margin:1.5% 0&quot;/&gt;     \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n    components:{\n        Selects:()=&gt;import('@/components/basicInfo/selects'),\n        Table:()=&gt;import('@/components/basicInfo/basicInfoTB')\n    },\n    methods:{\n        \n        updateTable(value){},\n        updateInputs(row){\n             this.$refs.Inputs.setInputValue(row)\n        },\n        saveData(){\n            this.$refs.Table.saveData()\n        },\n        excelOut(){\n            this.$refs.Table.excelOut()\n        },\n        addItem(row){\n            this.$refs.Table.addItem(row)\n        },\n    }\n}\n</code></pre>\n<h2 id=\"%E6%80%BB%E7%BB%93\" tabindex=\"-1\">总结</h2>\n<p>此时的自己应该是对vue有了一定的了解，也可以实现一定的功能，但是模块化思想，组件之间的关系还是非常欠缺。总之就是非常混乱，缺乏美感。</p>\n`,
    },
  },
  3: {
    code: 200,
    data: {
      id: 3,
      title: "wechat mini program",
      description: "微信小程序记录",
      scanNumber: "0",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "wechat",
          name: "wechat",
          tag: "h1",
          children: [
            { anchor: "%E8%AE%A4%E8%AF%81", name: "认证", tag: "h2", children: [] },
            {
              anchor: "mvvm%E6%93%8D%E4%BD%9C",
              name: "MVVM操作",
              tag: "h2",
              children: [
                { anchor: "%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8", name: "基本使用", tag: "h3", children: [] },
                { anchor: "%E9%80%9A%E4%BF%A1", name: "通信", tag: "h3", children: [] },
              ],
            },
          ],
        },
      ],
      htmlContent:
        "<h1 id=\"wechat\" tabindex=\"-1\">wechat</h1>\n<h2 id=\"%E8%AE%A4%E8%AF%81\" tabindex=\"-1\">认证</h2>\n<p>前端</p>\n<pre><code class=\"language-ts\">// app.ts\n enum LoginStatus{\n\tlogining = 'logining',\n\tlogined = 'logined',\n\tunlogin = 'unlogin'\n }\n\n async onShow(){\n   let pages = getCurrentPages();\n   //进入小程序\n   if(pages.length == 0) {\n\t   wx.setStorageSync('loginStatus',LoginStatus.logining)\n       const res = await checkIdentity()\n       if(!res){\n         wx.showToast({\n           title: '身份认证失败',\n         })\n\t\t  wx.setStorageSync('loginStatus',LoginStatus.unlogin)\n       }else{ \n\t\t wx.setStorageSync('loginStatus',LoginStatus.logined)\n         wx.setStorageSync('userInfo',{userid:res.id,token:res.token,factory:res.factory,access:res.access})\n         wx.showToast({\n           title: `${res.id}\n              \\r\\nversion:${wx.getAccountInfoSync().miniProgram.version}` ,\n         })\n       }\n    }\n}\n\n//utils.ts\n/**\n * 返回工号token,根据企业微信还是手机微信统一返回固定格式\n */\nasync function checkIdentity(){\n  const {environment} = await getEnvironment() as {environment:string}  \n  if(environment &amp;&amp; environment=='wxwork'){\n      return qyLogin() \n  }else{\n      return wxLogin()\n  }\n}\n\n/**\n * 微信认证,就是拿code换id\n */\nasync function wxLogin(){\n  const code = await new Promise(resolve=&gt;{\n      wx.login({\n        success:res=&gt;{\n          resolve(res.code)\n        },\n      })\n  })\n  //自己封装了一下wx.request(),以前写的，感觉写的不是很好\n  return requestData(`${loginUrl}login`,{code},&quot;POST&quot;,{\n    'content-type': 'application/x-www-form-urlencoded'\n  },setSessionId) as Promise&lt;IUserInfo&gt;\n}\n</code></pre>\n<p>后端也就根据code去换id,如何生成token并返回</p>\n<pre><code class=\"language-c#\">        /// &lt;summary&gt;\n        /// 通过openid认证\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static string auth2(string code)\n        {\n            string res = string.Empty;\n            string openid = GetOpenid(code);\n            string url = string.Format(@&quot;https://qyapi.weixin.qq.com/cgi-bin/user/convert_to_userid?access_token={0}&quot;, GetAccessToken());\n            string responseText = HttpHelper.Instance.post(url, &quot;{\\&quot;openid\\&quot;:\\&quot;&quot; + openid + &quot;\\&quot;}&quot;);\n            WeChatUserInfoFromOpenId codeEn = JsonHelper.GetEntity&lt;WeChatUserInfoFromOpenId&gt;(responseText);\n            if (!string.IsNullOrEmpty(codeEn.errmsg) &amp;&amp; codeEn.errmsg.Equals(&quot;ok&quot;))\n            {\n                res = codeEn.userid;\n            }\n            return res;\n        }\n</code></pre>\n<p>当时写的是判断40s内有没有验证通过，现在的话，我感觉使用一个eventbus之类，可能比这个死循环要好多了</p>\n<pre><code class=\"language-ts\">  async onShow(){\n      wx.showLoading({title:'加载中'})\n      const result = await isIdentityCheckFinished()\n      if(!result){\n        wx.redirectTo({\n          'url':'../errorPage/index',\n        })\n        return\n      }\n      wx.hideLoading()\n      this.init()\n  }\n\n\n/**\n * 认证是否执行完成\n */\nconst isIdentityCheckFinished= async (count = 20)=&gt;{\n  while(count--){\n\tconst status = wx.getStorageSync('loginStatus')\n\tif(status===LoginStatus.logining){\n       await sleep(2)\n\t}else{\n\t\treturn wx.getStorageSync('loginStatus') === LoginStatus.logined\n\t}\n  }\n  return false\n}\n</code></pre>\n<h2 id=\"mvvm%E6%93%8D%E4%BD%9C\" tabindex=\"-1\">MVVM操作</h2>\n<h3 id=\"%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\" tabindex=\"-1\">基本使用</h3>\n<p>这就完成可以类比vue了,就是没有composition api。\n之前vue里面的生成template的和data的方法都可以直接用,模板里面的语法也大差不差。变化也只是标签而且。</p>\n<pre><code class=\"language-html\">   &lt;view class=&quot;inspectionItem&quot; wx:for=&quot;{{templateData}}&quot; wx:key=&quot;prop&quot;&gt; \n      &lt;block wx:if=&quot;{{item.prop=='remark'}}&quot;&gt;\n        &lt;wux-cell wx:if=&quot;{{showRemark}}&quot;&gt;\n          &lt;view  class=&quot;InspectionItemLabel&quot; &gt;\n              {{item.label}}\n          &lt;/view&gt;  \n          &lt;wux-textarea  bind:change='onChange' data-prop=&quot;{{item.prop}}&quot; rows='3' placeholder='请输入' placeholder-style='font-weight:10'&gt;&lt;/wux-textarea&gt;\n        &lt;/wux-cell&gt; \n      &lt;/block&gt;\n      &lt;block wx:elif=&quot;{{item.prop=='haveProblem'}}&quot;&gt;\n        &lt;wux-picker options=&quot;{{['是','否']}}&quot; value=&quot;{{ formData[item.prop] }}&quot;  bind:confirm=&quot;onConfirm&quot;\n        data-prop=&quot;{{item.prop}}&quot;\n      &gt;\n        &lt;wux-cell  is-link extra=&quot;{{ formData[item.prop][0] }}&quot;&gt;\n          &lt;view class=&quot;InspectionItemLabel&quot; &gt;\n              {{item.label}}\n          &lt;/view&gt;  \n        &lt;/wux-cell&gt;\n      &lt;/wux-picker&gt;\n      &lt;/block&gt; \n   &lt;/view&gt;\n   ……\n   &lt;wux-button block type=&quot;balanced&quot; wux-class='myButton' bind:click='submit'\n      &gt;&lt;wux-icon type=&quot;ios-save&quot; size=&quot;16&quot; /&gt; 提交&lt;/wux-button\n    &gt;\n</code></pre>\n<p>唯一不同的就是不是响应式,和React一样要手动set一下</p>\n<pre><code class=\"language-ts\">Page({\n   data:{\n     formData,\n     templateData,\n     ……\n   },\n   onLoad(){\n\t  //调用一些后台api\n   },\n   //监听input的change事件\n   onChange(){\n\t  ···\n      setFormValue()\n   },\n    setFormValue(prop: Insection,value: any){\n      this.setData({\n        [`formData.${prop}`]:value\n      })\n   },\n   submit(){\n\t  validate(this.data.formData) &amp;&amp; submitApi(this.data.formData)\n   }\n\n})\n</code></pre>\n<h3 id=\"%E9%80%9A%E4%BF%A1\" tabindex=\"-1\">通信</h3>\n<p>父子组件通过event的方式即可。打开也被打开页面见的通信，我一般使用<code>eventChannel</code>。经过vue的经验，可以确定这就是<code>event bus</code>,也就是和vue观察者模式类似的发布订阅模式。</p>\n<pre><code class=\"language-ts\"> wx.navigateTo({\n             url:'../resolve/index',\n             events:{\n               research:()=&gt;{\n                this.getList()\n              },\n             },\n            success:(res)=&gt;{\n                res.eventChannel.emit('navSuccess',item,this.data.searchCondition)\n            }\n})\n\nonLoad(){\n\tconst eventChannel = this.getOpenerEventChannel();\n\tthis.eventChannel.on('navSuccess',(condition:Record&lt;string,string&gt;)=&gt;{\n\t\t\t\tthis.setData({\n\t\t\t\t\tcondition\n\t\t\t\t})\n\t\t\t\t\n\t})\n}\n\n</code></pre>\n",
    },
  },
  4: {
    code: 200,
    data: {
      id: 4,
      title: "Big Data Board",
      description: "Big Data Board can see different chart about production",
      scanNumber: "0",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "bigdata-system",
          name: "bigData System",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            { anchor: "%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84", name: "项目结构", tag: "h2", children: [] },
            { anchor: "prototype%E6%8B%93%E5%B1%95", name: "prototype拓展", tag: "h2", children: [] },
            {
              anchor: "%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95",
              name: "自定义方法",
              tag: "h2",
              children: [{ anchor: "%E6%94%B9%E5%96%84%E5%90%8E%E7%9A%84%E8%BD%AE%E6%92%AD%E6%96%B9%E6%B3%95", name: "改善后的轮播方法", tag: "h3", children: [] }],
            },
            {
              anchor: "%E5%85%AC%E7%94%A8%E7%BB%84%E4%BB%B6",
              name: "公用组件",
              tag: "h2",
              children: [
                { anchor: "echarts%E7%BB%84%E4%BB%B6", name: "echarts组件", tag: "h3", children: [] },
                { anchor: "upload-excel%E7%BB%84%E4%BB%B6", name: "upload excel组件", tag: "h3", children: [] },
              ],
            },
            { anchor: "store", name: "Store", tag: "h2", children: [] },
            { anchor: "route", name: "Route", tag: "h2", children: [] },
            { anchor: "%E6%80%BB%E7%BB%93", name: "总结", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="bigdata-system" tabindex="-1">bigData System</h1>\n<p>此时的自己vue的操作已经是没有问题了，但是一些模块化思想啊，逻辑就感觉很奇怪，自己也感觉自己的vue写的很不优雅。也是看了一些比较优质的代码，当时从零开始梳理了一遍vue-element-admin,在此基础上加上了新学习的typescript，开始了本次的项目。</p>\n<h2 id="%E6%95%88%E6%9E%9C" tabindex="-1">效果</h2>\n<p><img src="' +
        images.msp0 +
        '" alt="msp0"></p>\n<h2 id="%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" tabindex="-1">项目结构</h2>\n<p>项目结构已经大致接近现在的项目了，但是没有Utils目录，一些工具写在了外面。对typescript不熟悉，所以types目录不存在。</p>\n<p><img src="' +
        images.msp0struct +
        "\" alt=\"image-20240827200012949\"></p>\n<h2 id=\"prototype%E6%8B%93%E5%B1%95\" tabindex=\"-1\">prototype拓展</h2>\n<p>有了Typescript之后，终于可以摆脱挂在原型上没有提示了</p>\n<pre><code class=\"language-ts\">declare module &quot;vue/types/vue&quot; {\n  interface Vue {\n    $message:typeof Message;\n    $axios: typeof Axios;\n    $echarts: EChartsHelper;\n    $MessageBox:ElMessageBox;\n  }\n}\n//main.ts\nVue.config.productionTip = false\nVue.prototype.$axios = Axios\nVue.prototype.$echarts = EChartsHelper\nVue.prototype.$MessageBox = MessageBox\nObject.prototype[Symbol.iterator] = function * &lt;T&gt;(this:T){\n  for(let i in this){\n    yield {key:i,value:this[i]}\n  }\n}\n</code></pre>\n<h2 id=\"%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95\" tabindex=\"-1\">自定义方法</h2>\n<p>此时写的Helper大部分还是为了熟悉使用</p>\n<pre><code class=\"language-ts\">class EChartsHelper{\n    private Mychart: EChartsType\n    \n    constructor(dom:HTMLElement|undefined|null,theme='lightGreen'){\n        if(dom){\n            this.Mychart = echarts.init(dom,theme)\n            this.Mychart.off('click')\n         }else{\n            throw new Error('echarts init failed')\n         }  \n    }\n    /**\n     * @type\n     * 普通合并，永远不会删除组件 */\n    updateMyChart(obj: object): void\n    /**\n     * @param notMerge 为true 则全部删除，默认false不写\n     */\n    updateMyChart(obj: object,notMerge:boolean): void\n    /**\n     * \n     * @param notMerge 默认false不需要传 \n     * @param replaceMerge 哪些组件需要替换更新——有就更新，没有就删除\n     */\n    updateMyChart(obj: object,{replaceMerge}: {replaceMerge: Array&lt;string&gt;|string}): void\n    updateMyChart(obj:object,s?:any):void {\n        if(s){\n            if(typeof s == 'boolean'){}\n            else{\n               if(s.replaceMerge &amp;&amp; (Array.isArray(s.replaceMerge)|| typeof s.replaceMerge=='string')){}\n               else{\n                   throw new Error('ECharts setOption params error')\n               }\n            }\n            this.Mychart.setOption(obj as echarts.EChartsCoreOption,s)\n        }\n        this.Mychart.setOption(obj as echarts.EChartsCoreOption)\n    }\n    // setOn(event: string,series='',F: Function){\n    //     this.Mychart.on(event,'series',()=&gt;{\n    //         F()\n    //     })\n    // }\n    setOn(event: string,F:Function): void\n    setOn(event: string,F: Function,series: string): void\n    setOn(event: string,F: Function,c?: any): void{\n        if(!c){\n            c = 'series'\n        }\n        this.Mychart.on(event,c,(param: object)=&gt;{\n                    F(param)\n                })\n    }\n    setLoading(){\n        this.Mychart.showLoading()\n    }\n    hideLoading(){\n        this.Mychart.hideLoading()\n    }\n    triggerAction(action: string, name: string){\n        this.Mychart.dispatchAction({type:action,name})\n    }\n    get chart(){\n        return this.Mychart\n    }\n\n    get width(){\n       return this.Mychart.getWidth()*0.8\n    }\n    resize(){\n        this.Mychart.resize()\n    }\n   dispose(){\n       this.Mychart.dispose()\n   }\n   static of(dom: HTMLElement|undefined|null,theme='lightGreen'){\n        return new EChartsHelper(dom,theme)\n    }\n\n}\n</code></pre>\n<pre><code class=\"language-ts\">class AxiosHelper{\n     private static axios:AxiosStatic = axios\n     static async getData(url: string): Promise&lt;any&gt;\n     static async getData(url: string,type: string): Promise&lt;any&gt;\n     static async getData(url: string,data:{[k: string]:any}): Promise&lt;any&gt;\n     static async getData(url: string,data:{[k: string]:any},type: string): Promise&lt;any&gt;\n     static async getData(url: string,b?:any,c?: string){\n         if(b){\n             if(typeof b == 'object'){\n                 if(c &amp;&amp; typeof c=='string'){\n                     return this.request(url,b,c as Method)\n                 }else{\n                     return this.request(url,b)\n                 }\n             }else{\n                 if(typeof b == 'string'){\n                     return this.requstUrl(url,b)\n                 }else{\n                    throw new Error('参数格式错误')\n                }        \n             }\n         }else{\n            //  b=&quot;POST&quot; \n             return  this.requstUrl(url)\n         }\n\n     }\n\n     static async request(url: string,data:{} = {},type: Method =&quot;post&quot; ){\n       return await this.axios({\n            url: url,\n            data: qs.stringify(data),\n            method:type\n         }).then(value=&gt;{\n             if(value.data){\n                 return value.data\n             }else{\n                 throw new Error(&quot;无数据&quot;+url);\n             }\n         },reason=&gt;{throw reason}).catch((e: Error)=&gt;{console.error(e)})\n         \n\n     }\n     static async requstUrl(url: string,b='POST'){\n        return await this.axios({\n            url: url,\n            method:b as Method\n         }).then(value=&gt;{\n             if(value.data){\n                 return value.data\n             }else{\n                 throw new Error(&quot;无数据&quot;);\n             }\n         },reason=&gt;{throw reason}).catch((e: Error)=&gt;{console.error(e)})\n     }\n     static get Axios(){\n         return this.axios\n     }\n\n     \n\n} \n</code></pre>\n<p>轮播页面工具。当时想了很久才写出来。现在看起来很low就是了。</p>\n<pre><code class=\"language-ts\">class Carousel{\n    /**\n     * 所有可选页面\n     */\n     private pageNames: string[]\n     /**\n      * 控制轮播开始与暂停\n      */\n     private canCarousel = true\n     /**\n      * 获取下一个轮播页面名\n      */\n     private nextPage: Generator&lt;string | void, void, unknown&gt; = this.getNextPage()\n     /**\n      * 每个页面停留时间\n      */\n     private interval:number;\n     constructor(config: typeof carouselConfig){\n        const {carouselInterval,loopIndex} = config\n        this.interval = carouselInterval\n        this.pageNames = loopIndex\n     }\n\n    private *getNextPage(){\n         const currentPage = getCookie('currentPageName')\n         /**\n          * \n          * 从循环的下一个页面开始\n          * */\n         let p =  this.pageNames\n         if(p.includes(currentPage)){\n            p = p.slice(p.indexOf(currentPage)+1)\n            p = p.length?p:this.pageNames   \n         }\n        let t = this.pages(p)\n        let res = t.next()\n        while(true){\n            if(res.done){\n                t = this.pages()\n                res = t.next()\n            }\n            yield res.value\n            res = t.next()\n        } \n    }\n     private *pages(pages = this.pageNames){\n        if(!pages.length)\n           yield ''\n        \n        for(let i of pages){\n            yield i\n        }\n     }\n     start(){\n       this.canCarousel = true\n       this.carousel() \n     }\n     // 主要逻辑其实只是这里\n     async carousel(){\n        const next = this.nextPage.next()\n        if(next.value &amp;&amp; store.getters.getLoginIdentity){\n            const path = getPathByPageName(next.value as string)\n            this.canCarousel &amp;&amp; Router.push(path).catch(e=&gt;{\n                Router.push({name:&quot;back&quot;})\n                setTimeout(()=&gt;{\n                    Router.replace(path)\n                },500)\n            })\n        }\n        await sleep(this.interval)\n        this.canCarousel &amp;&amp; this.carousel()\n     }\n\n     stopCarousel(){\n         this.canCarousel = false\n     }\n     static of(){\n         return new Carousel(carouselConfig)\n     }\n     setNextPage(){\n        this.nextPage = this.getNextPage()\n     }\n}\n</code></pre>\n<p>现在看来有主要有两个大问题。</p>\n<ol>\n<li>违反了单一职能原则。</li>\n</ol>\n<p>​       明明是路由的轮播的工具，却有一大半在做无限循环。其实主要逻辑就是控制播放与停止。无限获取下一个，可以单独提出来。</p>\n<ol start=\"2\">\n<li>\n<p>无法正确停止</p>\n<p>极端的情况，调用停止的的时候，此时正在sleep，在sleep结束前再次开始，这其实没有任何意义。</p>\n</li>\n</ol>\n<h3 id=\"%E6%94%B9%E5%96%84%E5%90%8E%E7%9A%84%E8%BD%AE%E6%92%AD%E6%96%B9%E6%B3%95\" tabindex=\"-1\">改善后的轮播方法</h3>\n<p>之后也写过类似方法，是这样写的</p>\n<p>无限Loop</p>\n<pre><code class=\"language-ts\">type Item&lt;T&gt; = T extends Iterable&lt;infer R&gt;?R:never\nclass LoopIteratorData&lt;T extends Iterable&lt;TItem&gt;,TItem = Item&lt;T&gt;&gt;{\n\tprivate _generator: Generator&lt;TItem,TItem,any&gt;\n\tprivate _index = 0\n\tprivate _destroyed = false\n\tconstructor(private _data:T){\n\t\tthis.createGenerator()\n\t}\n\tprivate createGenerator(){\n\t\tthis._generator = LoopIteratorData.createGenerator(this._data)\n\t\tthis._index = 0\n\t}\n\tnext():{value:TItem,index:number}{\n\t\tif(this._destroyed){\n\t\t\tthrow new Error('loop is over')\n\t\t}\n\t\tconst value = this._generator.next()\n\t\tif(!value.done){\n\t\t\treturn {value:value.value,index:this._index++}\n\t\t}else{\n\t\t\tthis.createGenerator()\n            return this.next()\n\t\t}\n\t}\n\tdestory(){\n\t\ttry{\n\t\t\tthis._destroyed = true\n\t\t\tthis._generator.throw('手动停止')\n\t\t}catch(e){\n\t\t}\n\t}\n    //创建生成器直接挂在了类构造器上了\n    static createGenerator&lt;T extends Iterable&lt;TItem&gt;,TItem = Item&lt;T&gt;&gt;(data:T){\n\t\tfunction *g(){\n            for(let i of data){\n\t\t\t\tyield i\n\t\t\t}\n\t\t} \n\t\treturn g() as Generator&lt;TItem,TItem,any&gt;\n        \n\t}\n}\n</code></pre>\n<p>轮播方法。其实<code>_loopInstance</code>也可以直接约束为  <code>interface ILoopInstance{ next():{value:TItem,index:number}}</code></p>\n<pre><code class=\"language-ts\">interface ICarouselExecuteObject&lt;T extends Iterable&lt;TItem&gt;&gt;{\n    exec(value: {value:TItem,index:number}):void\n}\n\nclass Carousel&lt;T extends Iterable&lt;TItem&gt;&gt;{\n    private _timer: number\n    constructor(private _loopInstance: LoopIteratorData&lt;T&gt;,\n                private _executeInstance: ICarouselExecuteObject&lt;T&gt;,\n                private _interval = 5000\n                ){}\n    start(){\n        if(this.isLooping){\n            console.warn(&quot;is looping&quot;)\n            return\n        }\n        this.carouselIt()\n    }\n    stop(){\n        this._timer &amp;&amp; clearInterval(this._timer)\n        this._timer = null\n    }\n    private carouselIt(){\n        this._timer = setTimeout(()=&gt;{\n            this._executeInstance.exec(_loopInstance.next())\n            this.carouselIt()\n        },this._interval)\n    }\n    get isLooping(){\n        return !!this._timer\n    }\n    \n}\n</code></pre>\n<p>这样不仅符合单一职能原则，还满足开闭原则，我也不关心你要轮播干啥，只有你<code>implements ICarouselExecuteObject </code>就行。这样看起来，至少现在的我还是感觉挺优雅的。</p>\n<h2 id=\"%E5%85%AC%E7%94%A8%E7%BB%84%E4%BB%B6\" tabindex=\"-1\">公用组件</h2>\n<h3 id=\"echarts%E7%BB%84%E4%BB%B6\" tabindex=\"-1\">echarts组件</h3>\n<p>感觉粒度太大了，props也没有写类型，明明是ts。</p>\n<pre><code class=\"language-ts\">export default Vue.extend({\n    data(){\n        return {\n            myChart:null as null|EChartsHelper,\n        }\n    },\n    props:[&quot;custom&quot;,'dataset'],\n    created(){\n       this.initPie() \n    },\n    beforeDestroy(){\n        this.myChart?.dispose()\n        this.myChart = null\n    }\n    ,methods:{\n       initPie(){\n           if(!this.custom || !this.custom.title){\n               return\n           }\n           const div = document.getElementById(`${this.custom.title}`)\n          \n           if(!div){\n               return      \n           }\n            this.myChart = EChartsHelper.of(div)\n            this.dataset &amp;&amp; this.myChart.updateMyChart(this.dataset)\n            this.myChart.setOn('click',(params: {[k:string]:any})=&gt;{\n                 let index = params.seriesIndex as number|undefined     \n                 this.$emit('clickPie',this.custom.title,getType(index))\n               })\n           }\n           \n       }\n\n    },\n  \n    watch:{\n        dataset:{\n            handler(){         \n                this.myChart?.updateMyChart({dataset:{source:this.dataset},title})\n            }\n          }\n        },\n       async menuOpen(){ \n           const timer = setInterval(()=&gt;{\n               this.myChart?.resize()  \n            },1000)\n            setTimeout(() =&gt; {\n                clearInterval(timer)\n            }, 1000);      \n        }, \n    },\n    \n      computed:{\n        ...mapGetters({\n            menuOpen:&quot;menuOpen&quot;,\n        }),\n    \n    },\n})\n\n</code></pre>\n<h3 id=\"upload-excel%E7%BB%84%E4%BB%B6\" tabindex=\"-1\">upload excel组件</h3>\n<p>感觉读取文件内容可以提出去，或者使用Hooks之类的，可以减少代码量方便阅读</p>\n<pre><code class=\"language-ts\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;input ref=&quot;excel-upload-input&quot; class=&quot;excel-upload-input&quot; type=&quot;file&quot; accept=&quot;.xlsx, .xls&quot; @change=&quot;handleClick&quot;&gt;\n     &lt;el-button :loading=&quot;loading&quot;  size=&quot;mini&quot; type=&quot;primary&quot; @click=&quot;handleUpload&quot;&gt;\n        选择\n      &lt;/el-button&gt;\n      &lt;el-button size=&quot;mini&quot; type=&quot;primary&quot; @click=&quot;uploadExcel&quot;&gt;上传&lt;/el-button&gt;\n      &lt;div class=&quot;myFile&quot;&gt;\n            &lt;div v-if=&quot;excelData.fileName&quot; class=&quot;fileName&quot;&gt;\n                {{excelData.fileName}} \n                &lt;span&gt;(数据无误,请点击上传)&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div v-else&gt;\n                未选择文件&lt;span&gt;(请选择上传文件)&lt;/span&gt;\n            &lt;/div&gt;\n      &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport XLSX from 'xlsx'\nexport default {\n  props: {\n     onUpload:Function\n    ,dataFormat:{\n        required:true,\n        default:[],\n        type:Array\n    }\n  },\n  data() {\n    return {\n      loading: false,\n      excelData: {\n        header: null,\n        results: null,\n        fileName:null\n      },\n      \n    }\n  },\n  methods: {\n    uploadExcel(){\n       this.onUpload &amp;&amp; this.onUpload(JSON.stringify(this.excelData.results))\n    },\n    generateData({ header, results }) {\n      this.excelData.header = header\n      results?.shift()\n      this.excelData.results = results\n    },\n    handleUpload() {\n      this.$refs['excel-upload-input'].click()\n    },\n    handleClick(e) {\n      const files = e.target.files\n      const rawFile = files[0] // only use files[0]\n      if (!rawFile) return\n      this.readerData(rawFile)\n    },\n    readerData(rawFile) {\n      const name = rawFile.name\n      this.loading = true\n      return new Promise((resolve, reject) =&gt; {\n        const reader = new FileReader()  \n        reader.onload = e =&gt; {  \n          const data = e.target.result\n          const workbook = XLSX.read(data, { type: 'array' })\n          const firstSheetName = workbook.SheetNames[0]\n          const worksheet = workbook.Sheets[firstSheetName]\n          const header = this.getHeaderRow(worksheet)\n          if(this.dataFormat &amp;&amp; this.dataFormat.length){\n              /*\n              *@param {[{prop:string,label: string}]} ar1\n               * @param {string[]} ar2\n               */\n              const checkFormat = (ar1 ,ar2)=&gt;{\n                  if(ar1.length!=ar2.length)\n                     return false\n                  for(let i of ar1){\n                      if(!ar2.includes(i.label)){\n                          return false\n                      }\n                  }\n                  return true\n              }\n              if(!checkFormat(this.dataFormat,header)){\n                  this.loading = false\n                  reject('上传格式有误')\n                  return\n              }\n\n          }\n          const results = XLSX.utils.sheet_to_json(worksheet,{header:this.dataFormat.map(v=&gt;v.prop)})\n          this.generateData({ header, results })\n          this.excelData.fileName = name\n          this.loading = false\n          resolve()\n        }\n        reader.readAsArrayBuffer(rawFile)\n      }).catch(e=&gt;{\n           this.$message({\n                      type:'warning',\n                      message:e\n           })\n      })\n    },\n    getHeaderRow(sheet) {\n      const headers = []\n      const range = XLSX.utils.decode_range(sheet['!ref'])\n      let C\n      const R = range.s.r\n      /* start in the first row */\n      for (C = range.s.c; C &lt;= range.e.c; ++C) { /* walk every column in the range */\n        const cell = sheet[XLSX.utils.encode_cell({ c: C, r: R })]\n        /* find the cell in the first row */\n        let hdr = 'UNKNOWN ' + C // &lt;-- replace with your desired default\n        if (cell &amp;&amp; cell.t) hdr = XLSX.utils.format_cell(cell)\n        headers.push(hdr)\n      }\n      return headers\n    },\n    isExcel(file) {\n      return /\\.(xlsx|xls|csv)$/.test(file.name)\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"store\" tabindex=\"-1\">Store</h2>\n<p>没有分模块，还是比较混乱的，而且有些，比如url完成可以用环境变量处理，存在store感觉没有必要，最主要的作用就是存用户信息以及记录菜单是否展开，echarts的图表需要resize一下。</p>\n<pre><code class=\"language-ts\">export default new Vuex.Store({\n  state: {\n    userName:null as null|string,\n    login:false,\n    frameLabels:null as null|Iterable&lt;{key:string,value:string|null|number}&gt;,\n    pageName:'S4大数据',\n    url:isOnline?onlineUrl:testUrl,\n\n    continue:true,\n    frameLabelsTimer:null as null|number,\n    countDownTimer:null as null|number,\n    menuOpen:true,\n    imgSrc:&quot;&quot;,\n    ...\n  },\n   getters:{...},\n   mutations:{...},\n   actions:{...}\n}\n</code></pre>\n<h2 id=\"route\" tabindex=\"-1\">Route</h2>\n<p>个人感觉此项目最大的不足还是明明已经设置了路由，还要手动去设置菜单内容，还是hard code，那时候不知道route专门预留了meta的位置。</p>\n<pre><code class=\"language-ts\">const menuName = ['一阶','二阶',...]\nconst menuRouter:{[k in number]:RawLocation} = {\n    0:{\n        name:'step1',params:{\n            pageName:'一阶'\n        }\n    },\n    1:{\n        name:&quot;step2&quot;,\n        params:{\n            pageName:'二阶'\n        }\n    \n    },\n  ...    \n]\n\n</code></pre>\n<pre><code class=\"language-vue\">&lt;el-menu-item-group&gt;\n      &lt;el-menu-item  v-for=&quot;(item,index) in menuName&quot; :key=&quot;index&quot; :index=&quot;getIndex(index)&quot; @click=&quot;turn2Page(index)&quot;\n      class=&quot;S4Item&quot;&gt;{{item}}&lt;/el-menu-item&gt;\n&lt;/el-menu-item-group&gt;\n</code></pre>\n<h2 id=\"%E6%80%BB%E7%BB%93\" tabindex=\"-1\">总结</h2>\n<p>我感觉，此时期的我已经初步具备了解决复杂问题能力，但是对一些编程的基本思想，原则学习不够，也就是内功不够，所以也出来的代码可阅读性，可维护性不强。所以之后才会开始补Vue原理，设计原则，算法这种内功。</p>\n",
    },
  },
  5: {
    code: 200,
    data: {
      id: 5,
      title: "模具管理系统",
      description: "常见包管理器及其区别",
      scanNumber: "0",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "vsp0modules",
          name: "VSP0Modules",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            { anchor: "%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84", name: "项目结构", tag: "h2", children: [] },
            { anchor: "layout", name: "Layout", tag: "h2", children: [{ anchor: "%E5%85%AC%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E7%BB%84%E4%BB%B6", name: "公用方法与组件", tag: "h3", children: [] }] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="vsp0modules" tabindex="-1">VSP0Modules</h1>\n<p>终于开始了vue3，真的很忙，用vue2肯定会轻松，但是不想停下就用了vue3.</p>\n<h2 id="%E6%95%88%E6%9E%9C" tabindex="-1">效果</h2>\n<p><img src="' +
        images.vsp0 +
        '" alt="vsp0all"></p>\n<p><img src="' +
        images.vsp0Effect +
        '" alt="vsp0"></p>\n<h2 id="%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" tabindex="-1">项目结构</h2>\n<p>项目结构已经成型</p>\n<p>![image-20240827222802818](' +
        images.vsp0struct +
        ")</p>\n<h2 id=\"layout\" tabindex=\"-1\">Layout</h2>\n<p>此时眼里的网页就是LayOut里面加了一个Route-view，Layout我也不是太关注，想要用的东西就存store里面，主要关注Route-view。</p>\n<h3 id=\"%E5%85%AC%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E7%BB%84%E4%BB%B6\" tabindex=\"-1\">公用方法与组件</h3>\n<p>可能是这种一个form(不管是查询条件还是维护信息)+buttons(一些操作)+table(结果),这种结构真是太多了，不知不觉间就形成了现在的风格。</p>\n<p>不过也分为两个时期吧。</p>\n<h4>1.  typescript进阶学习之后</h4>\n<p>对OOP有了执念，想着前后端统一了。</p>\n<h5>axios</h5>\n<pre><code class=\"language-ts\">class AxiosHelper{\n        public  request:&lt;T&gt;(config: AxiosRequestConfig) =&gt; Promise&lt;T&gt;\n        private instance:AxiosInstance\n        private constructor(){\n            this.instance= this.createInstance()\n            this.request = this.createRequset()\n        }\n        private createInstance(){\n            const instance = axios.create()\n            //设置拦截器\n            instance.interceptors.request.use(config=&gt;{\n              return  config\n            },error=&gt;Promise.reject(error))\n            instance.interceptors.response.use(\n                response=&gt;{\n                const apiData = response.data as IApiResponseData&lt;any&gt;                \n                return apiData as any\n\n            },\n            error=&gt;Promise.reject(error)\n            \n            )\n            return instance\n        }\n        private createRequset(){\n            return  &lt;T&gt;(config:AxiosRequestConfig):Promise&lt;T&gt;=&gt;{\n                const defaultConfig:AxiosRequestConfig = {\n                    headers:{\n                        Authorization:'',\n                        'Content-Type':config.headers?.['Content-Type']||'application/json',\n                       \n                    },\n                    timeout: 10000,\n                    baseURL: import.meta.env.VITE_BASE_API\n                    // process.env.VUE_APP_BASE_URL\n                    ,\n                    data: {}\n                } \n                return  this.instance({...defaultConfig,...config})\n           }\n        }\n        static _instance:AxiosHelper\n        static instance(){\n              if(this._instance){\n                  return this._instance\n              }else{\n                  this._instance = new AxiosHelper()\n                  return this.instance()\n              }\n        }\n  \n}\n\n const axiosHelper = AxiosHelper.instance()\n</code></pre>\n<h5>手写Promise</h5>\n<pre><code class=\"language-ts\">enum Status{\n     /**\n         * 等待/准备\n         */\n     pending = 'pending',\n     /**\n      * 执行态\n      */\n     fulFilled = &quot;fulFilled&quot;,\n     /**\n      * 拒绝\n      */\n     rejected = 'rejected'\n}\n\nclass MyPromise&lt;T&gt; implements MyPromiseTypes.IMyPromise&lt;T&gt;{\n    /**\n     * 三种状态\n     */\n    private status:MyPromiseTypes.TStatus\n    /**\n     * fulfilled value\n     * rejected err\n     * pending null\n     */\n    private result:T = null\n    /**\n     * 存储在当前promise里，即p里面，不是then的新的promisem,因为那个时候还没有生成\n     * 因为一个promise后面可以分开跟着无数then\n     * p.then()\n     * p.then()\n     * 需要一个queue去挨个执行\n     */\n    private handler:Array&lt;MyPromiseTypes.handlerItem&lt;T&gt;&gt; = []\n    constructor(executor: (resolve?:MyPromise&lt;T&gt;['resolve'],reject?:MyPromise&lt;T&gt;['reject'])=&gt;any){\n         this.status = Status.pending\n         try{\n            /**\n             * 注意点，resolve执行是在executor内部，this指向有问题\n             */\n            executor(this.resolve.bind(this),this.reject.bind(this)) \n         }catch(err){ \n            this.reject(err)\n         }\n         \n    }\n    resolve&lt;TResovle = T&gt;(value: TResovle){\n        this.changeStatus(Status.fulFilled,value)\n    }\n    reject(err){\n        this.changeStatus(Status.rejected,err) \n    }\n    private changeStatus(status:keyof MyPromiseTypes.Status,result:any){\n         if(this.status!==Status.pending) return //promise 状态不可逆\n         this.status = status\n         this.result = result \n         this.run()\n    }\n    private isPromiseLike&lt;R extends MyPromiseTypes.IMyPromiseLike&lt;T&gt;&gt;(callback: R){\n        if(callback &amp;&amp; (typeof callback=='function' || typeof callback=='object')){\n             return typeof callback.then == 'function'\n        }\n        return false  \n    }\n    \n    private add2MicroTask(func: MyPromise&lt;T&gt;['resolve']|MyPromise&lt;T&gt;['reject']){\n        //node 环境\n        if(process &amp;&amp; typeof process=== 'object' &amp;&amp; typeof process.nextTick === 'function'){\n            process.nextTick(func)\n        }else if(MutationObserver &amp;&amp; typeof MutationObserver === 'function'){\n            const ob = new MutationObserver(func)\n            const node = document.createTextNode(&quot;1&quot;)\n            ob.observe(node,{\n                characterData:true\n            })\n            node.data = &quot;2&quot;\n        }else{\n             setTimeout(func,0)\n        }\n    }\n   \n    then&lt;TReturn1 = T,TReturn2 = never&gt;(onfulfilled?:(res:T)=&gt;TReturn1|MyPromiseTypes.IMyPromiseLike&lt;TReturn1&gt;,onrejected?:(res: any)=&gt;TReturn2|MyPromiseTypes.IMyPromiseLike&lt;TReturn2&gt;):MyPromise&lt;TReturn1|TReturn2&gt;{\n        return new MyPromise&lt;TReturn1|TReturn2&gt;((resolve,reject)=&gt;{\n            this.handler.push({\n                onfulfilled,onrejected,resolve,reject\n            })\n            /**\n             * 注意，如果new 的时候是同步代码，then的时候其实已经执行完了，需要手动调用一次。\n             * 如果异步没有完成，这次会因为pending状态而什么都没做，等异步完成通过resolve，reject时候调用执行\n             */\n            this.run()\n        })\n        \n        \n    }\n   \n    \n    private runOneItem&lt;R extends MyPromiseTypes.handlerItem&lt;T&gt;&gt;({onfulfilled,onrejected,reject,resolve}:R){\n         this.add2MicroTask(()=&gt;{\n            const callback = this.status===Status.fulFilled?onfulfilled:onrejected\n            \n            //如果不是函数，新promise resolve 之前的result\n            if(typeof callback !== 'function'){\n                const settled = this.status === Status.fulFilled?resolve:reject\n                settled(this.result)\n                return\n            }\n            //是函数，如果执行成功就resolve,就算是onrejected里面的，也是resolve\n            try{\n                    const data = callback(this.result)\n                    if(this.isPromiseLike(data)){\n                        (data as MyPromise&lt;any&gt;).then(resolve,reject)\n                    }else{\n                        resolve(data)\n                    }\n                \n            }catch(err){\n                reject(err)\n            }\n            }\n        )\n\n    }\n\n\n \n    private run(){\n         if(this.status===Status.pending) return\n         else{\n            while(this.handler.length){\n                this.runOneItem(this.handler.shift())\n            }\n         }\n    }\n}\ndeclare namespace MyPromiseTypes{\n\n    declare enum Status{\n        /**\n         * 等待/准备\n         */\n        pending:'pending',\n        /**\n         * 执行态\n         */\n        fulFilled:&quot;fulFilled&quot;,\n        /**\n         * 拒绝\n         */\n        rejected:'rejected'\n    }\n    interface IMyPromiseLike&lt;T&gt;{\n         then:IMyPromise&lt;T&gt;['then']\n    }\n    type TStatus = keyof Status\n    interface handlerItem&lt;T&gt;{\n        resolve: MyPromise&lt;T&gt;['resolve']\n        reject: MyPromise&lt;T&gt;['reject']\n        onfulfilled:Parameters&lt;IMyPromise&lt;T&gt;['then']&gt;[0]\n        onrejected(res: any):any\n    } \n\n    interface IMyPromise&lt;T&gt;{\n        // status:keyof Status\n        /**\n         * pending-&gt;fulfilled\n         */\n        resolve&lt;R = T&gt;(value:R):void\n        /**\n         * pending=&gt;rejected\n         */\n        reject(value: any):void\n        /**\n         * \n         * @param onfulfilled \n         * @param onrejected \n         * @description 需要执行的回调,全部存在handler数组里面了，执行当状态改变会执行回调函数\n         * 回调分为三种 \n         * 1.函数，执行成功resolve，失败reject\n         * 2.promiseLike即有then回调的\n         * 3.非上面两种，直接将继承之前的promise状态与值\n         */\n        then&lt;TReturn1 = T,TReturn2 = never&gt;(onfulfilled:(res:T)=&gt;TReturn1|IMyPromiseLike&lt;TReturn1&gt;,onrejected?:(res: any)=&gt;TReturn2|IMyPromiseLike&lt;TReturn2&gt;):MyPromise&lt;TReturn1|TReturn2&gt;\n        \n    }\n    \n\n}\n</code></pre>\n<h5>Form</h5>\n<pre><code class=\"language-ts\">// form.d.ts\n\n/**\n * all formitem type enum\n */\ndeclare  enum EFormItemType{\n   input = 'input',\n   date = 'date',\n   select = 'select'\n}\n/**\n * all formitem type\n */\ntype TSearchItem = keyof typeof EFormItemType\n/**\n * if formitem is select,then it can has some options\n * option type\n */\ntype TSelectOption&lt;T extends string = string&gt; = T | {value:T,label: string} \n\n/**\n * getFormTemplate params.\n * can auto fill content\n */\ninterface IFormTemplateOption&lt;T extends (string[]|readonly string[]),TType extends Partial&lt;Record&lt;ArrayKey&lt;T&gt;,EFormItemType&gt;&gt;&gt;{\n\tlabels:string[],\n\tprops:T, \n\ttypes?:TType,\n\toptions?:{\n\t\t [k in keyof TType as TType[k] extends EFormItemType.select?k :never]?: TSelectOption[]\n\t},\n\treadonlys?:{[k in ArrayKey&lt;T&gt;]?:boolean}\n }\n /**\n  * getFormTemplate Return data\n  */\n interface IFormItem&lt;T extends string&gt;{\n\t label: string,\n\t prop: T\n\t type?:EFormItemType\n\t options?:IFormItem&lt;T&gt;['type'] extends EFormItemType.select?TSelectOption[]:never\n\t readonly?:boolean\n }\n\n\n\n/**\n * getFormData param\n */\ninterface IFormDataOption&lt;T extends string[]|readonly string[]&gt;{\n\tprops:T,\n\tdefaultData?:Partial&lt;Record&lt;ArrayKey&lt;T&gt;,string&gt;&gt;\n}\n\n\n /**\n  * formitem type\n  */\n type ICondition&lt;T extends string&gt; = {\n\t[k in  T]: string\n }\n\n\n interface IFormComponent&lt;T extends string = any&gt;{\n    template: IFormItem&lt;T&gt;[]\n\tformdata: ICondition&lt;T&gt;\n }\n\n//form.ts\n\nexport enum EFormItemType  {\n\tinput = 'input',\n\tdate = 'date',\n\tselect = 'select'\n}\n\nexport function getFormTemplate&lt;\n        T extends string[]|readonly string[],\n\t\tR extends Partial&lt;Record&lt;ArrayKey&lt;T&gt;,EFormItemType&gt;&gt;\n&gt;({labels,props,types,options,readonlys}:IFormTemplateOption&lt;T,R&gt;){\n\ttypes = types||{} as R\n    options = options||{}\n    readonlys = readonlys||{}\n    if(labels.length !== props.length){\n      throw new Error('label and prop are not corrent')\n    }\n    return props.map((prop:ArrayKey&lt;T&gt;,i)=&gt;{\n      const label = labels[i] \n      const type = types[prop] \n      const option = options[prop as any] as TSelectOption[]\n      const readonly = readonlys[prop]\n      return {\n          label,prop,\n          ...type?{type}:{},\n          ...option?{option}:{},\n          ...readonly?{readonly}:{}\n      }\n   })\n}\n\nexport function getFormData&lt;T extends string[]|readonly string[]&gt;({props,defaultData={}}:IFormDataOption&lt;T&gt;){\n    return Object.fromEntries(props.map(v=&gt;[v,defaultData[v]||null]))  as ICondition&lt;ArrayKey&lt;T&gt;&gt;\n}\n</code></pre>\n<pre><code class=\"language-vue\">\n&lt;script lang=&quot;ts&quot; setup&gt;\nimport { EFormItemType } from '@/utils/template/form'\nconst { formdata, template } = defineProps&lt;IFormComponent&gt;()\n&lt;/script&gt;\n\n&lt;template&gt;\n\t&lt;div class=&quot;form-container&quot;&gt;\n\t\t&lt;ElForm inline&gt;\n\t\t\t&lt;template v-for=&quot;item of template&quot; :key=&quot;item.prop&quot;&gt;\n\t\t\t\t&lt;slot :name=&quot;item.prop&quot;&gt;\n\t\t\t\t\t&lt;ElFormItem class=&quot;form-item&quot; :label=&quot;item.label&quot;&gt;\n\t\t\t\t\t\t&lt;template v-if=&quot;item.type === EFormItemType.select&quot;&gt;\n\t\t\t\t\t\t\t&lt;ElSelect v-model=&quot;formdata[item.prop]&quot;&gt;\n\t\t\t\t\t\t\t\t&lt;template v-if=&quot;item.options&quot; v-for=&quot;(option, index) of &lt;TSelectOption[]&gt;item.options &quot;&gt;\n\t\t\t\t\t\t\t\t\t&lt;ElOption v-if=&quot;typeof option === 'object'&quot; :label=&quot;option.label&quot;\n\t\t\t\t\t\t\t\t\t\t:value=&quot;option.value&quot; :key=&quot;index&quot;&gt;&lt;/ElOption&gt;\n\t\t\t\t\t\t\t\t\t&lt;ElOption v-else :label=&quot;option&quot; :value=&quot;option&quot;&gt;&lt;/ElOption&gt;\n\t\t\t\t\t\t\t\t&lt;/template&gt;\n\t\t\t\t\t\t\t&lt;/ElSelect&gt;\n\t\t\t\t\t\t&lt;/template&gt;\n\t\t\t\t\t\t&lt;template v-if=&quot;item.type === EFormItemType.date&quot;&gt;\n\t\t\t\t\t\t\t&lt;ElDatePicker v-model=&quot;formdata[item.prop]&quot; format=&quot;YYYY-MM-DD&quot; value-format='YYYY-MM-DD'\n\t\t\t\t\t\t\t\tclearable&gt;&lt;/ElDatePicker&gt;\n\t\t\t\t\t\t&lt;/template&gt;\n\t\t\t\t\t\t&lt;template v-else&gt;\n\t\t\t\t\t\t\t&lt;ElInput v-model=&quot;formdata[item.prop]&quot;&gt;&lt;/ElInput&gt;\n\t\t\t\t\t\t&lt;/template&gt;\n\n\t\t\t\t\t&lt;/ElFormItem&gt;\n\t\t\t\t&lt;/slot&gt;\n\t\t\t&lt;/template&gt;\n\t\t\t&lt;ElFormItem class=&quot;form-item&quot;&gt;\n\t\t\t\t&lt;slot name=&quot;last&quot;&gt;&lt;/slot&gt;\n\t\t\t&lt;/ElFormItem&gt;\n\n\t\t&lt;/ElForm&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<h5>buttons</h5>\n<pre><code class=\"language-ts\">// buttons.d.ts\nimport type { ButtonType } from &quot;element-plus&quot;\nimport { DefineComponent } from &quot;vue&quot;\n\ndeclare global {\n  type TButtonType = ButtonType\n  type TIcon = DefineComponent\n  \n  interface IButtonOption&lt;T extends string[]| readonly string[]&gt; {\n    labels: string[]\n    props: T\n    icons?: Partial&lt;Record&lt;ArrayKey&lt;T&gt;,TIcon&gt;&gt;\n    types?: Partial&lt;Record&lt;ArrayKey&lt;T&gt;,TButtonType&gt;&gt;,\n  }\n\n  interface IButtonItem&lt;T extends string&gt;{\n     label: string\n\t prop: T\n\t icon?: TIcon\n\t type?:TButtonType\n  }\n\n  interface IButtonProps&lt;T = any&gt;{\n\t  template: IButtonItem&lt;T&gt;[]\n\t//   events:Partial&lt;Record&lt;TEvent,(...any)=&gt;any&gt;&gt;\n  }\n}\n//button.ts\nexport function getButtonTemplate&lt;T extends string[]| readonly string[]&gt;({props,labels,icons={},types={}}:IButtonOption&lt;T&gt;){\t\n    if(labels.length !== props.length){\n       throw new Error('length is diff between labels and props')\n\t}\n\treturn props.map((prop:ArrayKey&lt;T&gt;,index)=&gt;{\n\t\t const label = labels[index]\n\t\t const res:IButtonItem&lt;ArrayKey&lt;T&gt;&gt; = {\n\t\t\tprop,\n\t\t\tlabel,\n\t\t }\n\t\t icons[prop] &amp;&amp; Reflect.set(res,'icon',icons[prop])\n\t\t types[prop] &amp;&amp; Reflect.set(res,'type',types[prop])\n\t\t return res\n\t})\n\n}\n</code></pre>\n<pre><code class=\"language-vue\">&lt;script lang=&quot;ts&quot; setup&gt;\nconst {template,} = defineProps&lt;IButtonProps&gt;()\nconst emit = defineEmits&lt;{\n\t(event: 'buttonClick',item: IButtonItem&lt;any&gt;)\n}&gt;()\nfunction handleClick(e:MouseEvent,item: IButtonItem&lt;any&gt;){\n\te.stopPropagation()\n    emit('buttonClick',item)\n\t\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n\t&lt;div class=&quot;buttons-container&quot;&gt;\n\t\t&lt;ElButton v-for=&quot;item of template&quot; :key=&quot;item.prop&quot; :type=&quot;item.type&quot; :icon=&quot;item.icon&quot;\n\t\t @click=&quot;e=&gt;handleClick(e,item)&quot;\n\t\t&gt;{{ item.label }}&lt;/ElButton&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<h5>table</h5>\n<pre><code class=\"language-ts\">//table.d.ts\nimport type { TableInstance } from &quot;element-plus&quot;\nimport {UnwrapNestedRefs} from 'vue'\n\ntype FuncFirstParam&lt;T extends (...arg: any) =&gt; any&gt; = T extends (\n  ...arg: [infer R]\n) =&gt; any\n  ? R\n  : any\ntype TEvents = FuncFirstParam&lt;TableInstance[&quot;$emit&quot;]&gt;\n\ndeclare global {\n  interface IPaginationTable&lt;T extends Record&lt;string, any&gt; = any&gt; {\n    /**\n     * 满足loading的querySelector用\n     */\n    class?: string\n    tableConfig: UnwrapNestedRefs&lt;{\n      tableData: T[]\n      tableTemplate: Array&lt;\n        Record&lt;&quot;label&quot; | &quot;prop&quot;, string&gt; &amp; { [k: string]: string }\n      &gt;\n    }&gt;\n    columnConfig?: UnwrapNestedRefs&lt;TElTableColumnConfig&lt;string&gt;&gt;\n    pagination?: UnwrapNestedRefs&lt;{\n      currentPageNum: number\n      pageSizes: number[]\n      total: number\n      pageSize: number\n    }&gt;\n    onClickRow?: (row: T) =&gt; any\n    rowStyle?: (data: { row: T; rowIndex: number }) =&gt; Object\n    events?: Partial&lt;Record&lt;TEvents, (...arg: any) =&gt; any&gt;&gt;\n  }\n  type TElTableColumnConfig&lt;T extends string&gt; = Partial&lt;\n    Record&lt;\n      T,\n      {\n        type?: &quot;input&quot; | &quot;select&quot; | &quot;color&quot;\n        options?: { value: string; tip?: string; label: string }[] | string[]\n        cannotedit?: true\n        cannotshow?: true\n      }\n    &gt;\n  &gt;\n\n  type TTableDataItem&lt;T extends string[]|readonly string[]&gt; = {\n\t   [k in ArrayKey&lt;T&gt;]: string\n\t  \n  } &amp; { [k: string] : any}\n\n\n  type TTableTemplateItem = Record&lt;'label'|'prop',string&gt;\n}\n//table.ts\n\nexport function getTableTemplate&lt;T extends string[]|readonly string[]&gt;({props,labels}:{props:T,labels: string[]}){\n\tif(props.length!==labels.length){\n\t\tthrow new Error('length is diff between labels and props')\n\t}\n\n\treturn props.map((prop,i)=&gt;({prop,label:labels[i]}))\n}\n</code></pre>\n<pre><code class=\"language-vue\">&lt;script lang=&quot;ts&quot; setup&gt;\nimport { computed, toRefs,reactive } from 'vue'\nimport {paginationTable} from '.'\n\nconst props = withDefaults(defineProps&lt;paginationTable.IPaginationTable&gt;(),{\n    pagination:()=&gt;reactive({  currentPageNum:1, pageSizes:[2,5,10], total:0, pageSize:5 }),\n    columnConfig:()=&gt;reactive({}),\n\tevents:()=&gt;reactive({})\n\t\n})\nconst displayData = computed(()=&gt;{\n    const {pageSize: size,currentPageNum: page,total} = toRefs(props.pagination)\n    total.value = props.tableConfig.tableData.length\n     const res = props.tableConfig.tableData.filter((x,i)=&gt;i&lt;size.value*page.value&amp;&amp;i&gt;=size.value*(page.value-1))\n     return res\n})\n\n&lt;/script&gt;\n\n\n&lt;template&gt;\n\t&lt;div class=&quot;paginationTableContainer&quot;&gt;\n    &lt;div class=&quot;paginationTable&quot; &gt;\n        &lt;ElTable border stripe :class=&quot;class&quot; :data=&quot;displayData&quot; fit flexible highlight-current-row \n\t\t height=&quot;100%&quot; :row-style=&quot;(rowStyle as any)&quot;\n\t      v-on=&quot;events&quot;\n\t\t  &gt;\n            &lt;template v-for=&quot;item of props.tableConfig.tableTemplate&quot; &gt;\n                &lt;ElTableColumn min-width=&quot;150px&quot; v-if=&quot;!columnConfig[item.prop] || !columnConfig[item.prop].cannotshow&quot;  :label=&quot;item.label&quot; :prop=&quot;item.prop&quot; :key=&quot;item.prop&quot;\n                   align=&quot;center&quot; resizable show-overflow-tooltip&gt;\n                    &lt;template v-if=&quot;columnConfig[item.prop] &amp;&amp; columnConfig[item.prop].type=='color'&quot; #default=&quot;scope&quot;&gt;\n                        &lt;ElColorPicker :model-value=&quot;scope.row[item.prop]&quot;  disabled&gt;&lt;/ElColorPicker&gt;\n                    &lt;/template&gt;\n                &lt;/ElTableColumn&gt;\n           &lt;/template&gt;\n        &lt;/ElTable&gt;\n    &lt;/div&gt;\n    &lt;ElPagination  v-model:page-size=&quot;pagination.pageSize&quot; v-model:current-page=&quot;pagination.currentPageNum&quot;\n               :total=&quot;pagination.total&quot; :page-sizes=&quot;pagination.pageSizes&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot;\n            &gt;&lt;/ElPagination&gt;\n\t\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>使用</p>\n<pre><code class=\"language-vue\">&lt;script lang=&quot;ts&quot; setup&gt;\nimport { reactive, ref,onBeforeMount } from 'vue';\nimport {formTemplate,conditions,buttonTemplate} from '.'\nimport {TButtonProp,TTableItem} from 'backupModel'\nimport {backupModelList as backupModelListApi} from '@/api/backupModel'\nimport { ElMessage, ElNotification} from 'element-plus';\nimport PaginationTable from '@/components/publicComponents/paginationTable/index.vue'\nimport { paginationTable } from 'customComponent'\nimport { excelOut } from '@/utils/excelHelper';\nimport { getExcelData, sleep } from '@/utils/common';\nimport {TFormDataProp} from 'backupModel'\n\nonBeforeMount(()=&gt;{\n     backupModelListApi.getTableTemplate().then(v=&gt;{\n         if(v.status){\n             tableTemplate.value = v.data\n         }\n     })\n})\n\nconst formData = ref(conditions)\nconst tableData = ref&lt;TTableItem[]&gt;([])\nconst tableTemplate = ref&lt;Array&lt;{prop:keyof TTableItem,label: string}&gt;&gt;([])\nlet currentRow:TTableItem = null\nconst tableConfig:Partial&lt;paginationTable.IPaginationTable&lt;TTableItem&gt;&gt; = {\n    pagination:reactive({\n        currentPageNum:1,\n        pageSizes:[10,15,20],\n        total:0,\n        pageSize:15\n      }),\n\t  events:{\n\t\t'row-click':(row:TTableItem)=&gt;{\t\t\t\n            currentRow = row\n\t\t},\n\t\t'row-dblclick':(row:TTableItem)=&gt;{\n\t\t\t// console.log(row);\n\t\t    formData.value.workOrderNumber = row.workOrderNumber\n\t\t}\n\t  }\n}\n\nconst buttonClick = &lt;T extends TButtonProp&gt;(type: T)=&gt;{\n    const strategy:Record&lt;TButtonProp,()=&gt;any&gt; = {\n         search(){\n            // if(!formData.value.mouldSteelGrade){\n            //     ElMessage.info('模具钢号为空')\n            //     return\n            // }\n            backupModelListApi.search({...formData.value,dom:'.tableContainer'}).then(v=&gt;{\n                 if(v.status &amp;&amp; v.data){\n                    //  ElMessage.success('查询成功')\n                     tableData.value = v.data\n                 }else{\n                     ElMessage.info('查询失败')\n                     tableData.value = []\n                 }\n            })\n         },\n         backupFinish(){\n            if(!currentRow){\n                 ElMessage.info('请选择要备模行')\n                 return\n            }\n\t\t\tif(currentRow.workOrderNumber!==formData.value.workOrderNumber){\n\t\t\t\tElMessage.info('请选择要备模行')\n\t\t\t\treturn\n\t\t\t}\n\n\n\n            backupModelListApi.backupFinish({...currentRow,dom:'.tableContainer',mouldSteelGrade:formData.value.mouldSteelGrade}).then(v=&gt;{\n                if(v.status &amp;&amp; v.data){\n                     ElMessage.success('备模成功')\n                     strategy.search()\n                }else{\n                    ElMessage.error('备模失败')\n                }\n                \n            })\n         },\n         excelOut(){\n            if(!tableData.value.length){\n                 ElMessage({type:'info',message:&quot;无数据可以导出&quot;})\n                 return\n            }\n            const excelData = getExcelData({name:&quot;备模清单&quot;,tableTemplate: tableTemplate.value,tableData:tableData.value})\n            excelOut(excelData.name,excelData.headers as any,excelData.series)\n         }\n    }\n    strategy[type]()\n}\n\nconst visibleChange = (prop:TFormDataProp,visible:boolean)=&gt;{\n\tconst strategy:Partial&lt;Record&lt;TFormDataProp,()=&gt;any&gt;&gt; = {\n\t\t mouldSteelGrade:()=&gt;{\n\t\t\tif(visible){\n\t\t\t\tconst mouldSteelGrade = ref()\n\t\t\t\tconst templateRow = formTemplate.find(x=&gt;x.prop===prop);\n\t\t\t\t(templateRow as any).loading = true\n                backupModelListApi.getMouldSteelGradeFromMSch(formData.value).then(v=&gt;{\n\t\t\t\t\tif(v.status){\n\t\t\t\t\t\ttemplateRow.option = v.data\n\t\t\t\t\t}else{\n\t\t\t\t\t\tElNotification({\n\t\t\t\t\t\t\ttitle:`getMouldSteelGradeFromMSch error`,\n\t\t\t\t\t\t\ttype:'error',\n\t\t\t\t\t\t\tmessage:v.data as any\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}).finally(()=&gt;{\n\t\t\t\t\t(templateRow as any).loading = false\n\t\t\t\t})\n\t\t\n\t\t\t}\n\t\t }\n\t}\n\tstrategy[prop] &amp;&amp; strategy[prop]()\n}\n\n\n\n// console.log(formTemplate);\n\n\n&lt;/script&gt;\n\n\n&lt;template&gt;\n    &lt;div class=&quot;backupModelList&quot;&gt;\n        &lt;div class=&quot;header&quot;&gt;\n            &lt;ElForm class=&quot;myForm&quot;&gt;\n                &lt;!-- 之前的display:inline-block;不想改,就在下面加了一个flex的div --&gt;\n                &lt;div&gt;\n                    &lt;ElFormItem v-for=&quot;item of formTemplate&quot; :label=&quot;item.label&quot; :key=&quot;item.prop&quot;&gt;\n                        &lt;ElSelect v-model=&quot;formData[item.prop]&quot; clearable v-if=&quot;item.type &amp;&amp; item.type==='select'&quot; \n\t\t\t\t\t\t @visible-change=&quot;visible=&gt;visibleChange(item.prop,visible)&quot;\n\t\t\t\t\t\t :loading=&quot;(item as any).loading&quot;\n\t\t\t\t\t\t &gt;\n\t\t\t\t\t\t\t&lt;template v-if=&quot;item.option&quot;&gt;\n\t\t\t\t\t\t\t\t&lt;ElOption v-for=&quot;op of item.option&quot; :key=&quot;op&quot; :value=&quot;op&quot; :label=&quot;op&quot;&gt;&lt;/ElOption&gt;\n\t\t\t\t\t\t\t&lt;/template&gt;\n                        &lt;/ElSelect&gt;\n                        &lt;ElInput v-else v-model=&quot;formData[item.prop]&quot;&gt;&lt;/ElInput&gt;\n                    &lt;/ElFormItem&gt;\n                &lt;/div&gt;\n                \n            &lt;/ElForm&gt;\n            &lt;div class=&quot;buttonContainer&quot;&gt;\n                &lt;ElButton v-for=&quot;item of buttonTemplate&quot; :key=&quot;item.prop&quot; :icon=&quot;item.icon&quot; :type=&quot;item.type&quot; @click=&quot;buttonClick(item.prop)&quot;&gt;\n                {{ item.label }}\n                &lt;/ElButton&gt;\n            &lt;/div&gt;\n                              \n        &lt;/div&gt;\n        &lt;div class=&quot;tableContainer&quot;&gt;\n            &lt;PaginationTable :table-config=&quot;{tableTemplate,tableData}&quot; :pagination=&quot;tableConfig.pagination&quot; \n\t\t\t:events=&quot;tableConfig.events&quot;&gt;&lt;/PaginationTable&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>此时也还没有从vue2中完成出来，虽然确实写在了一起，但感觉莫名有点乱。</p>\n<h4>2.  上手React之后</h4>\n<p>class，又或者OOP没有什么不好，但ts中的class就有点奇怪，假如我想像后端一样属性私有，只能通过get，set访问。写是没有问题，但是当想遍历时，又或者我想有Object.keys,Reflect.ownKeys之类的，就会吧私有属性带出来，毕竟ts编译之后就没了。当然可以通过new Proxy，来设置ownKeys，但这就感觉太复杂，而且不确定以后会不会有其他操作。使用<code>#prop</code>的话，又感觉兼容性不行，而且看着也不舒服。就很迷茫。</p>\n<p>学习React之后，React从class组件到function组件，我才发现，我好像确实忘记了function，hooks真是神了啊。忽然感觉豁然开朗、</p>\n<p>此时风格又一次发生改变，开始拥抱Composition API；</p>\n<pre><code class=\"language-ts\">// useForm.ts\nexport function useForm(){\n\tconst formTemplate = getFormTemplate({\n\t\tprops,\n        //整个系统中某些数据库中列太常用，就设置成了enum\n\t\tlabels:[EModuleLabels.makeMachine,EModuleLabels.mouldSteelGrade]\n\t})\n\t\n\tconst formData = reactive(getFormData({props})) \n\treturn {\n       formData,\n\t   formTemplate\n\t}\n}\n</code></pre>\n<pre><code class=\"language-ts\">// useButton.ts\nconst strategy:Record&lt;TProps,(...arg: any)=&gt;any&gt; = {\n\tsearch({formData,getTableData}:IUseButtonProps&lt;TFormData&gt;){\n\t\tgetTableData &amp;&amp; formData &amp;&amp; getTableData(formData)\n\t},\n\texport({exportExcel}:IUseButtonProps&lt;any&gt;){\n\t\texportExcel &amp;&amp; exportExcel()\n\t}\n}\n\nexport function useButton&lt;T extends Record&lt;string,any&gt;&gt;(options: IUseButtonProps&lt;T&gt;) {\n  const buttonTemplate = getButtonTemplate({\n    props: buttonProps,\n    labels: buttonLabels,\n    icons: {\n      search: Search,\n      export: Download,\n    },\n    types: {\n      search: &quot;primary&quot;,\n      export: &quot;success&quot;,\n    },\n  })\n  \n  function buttonClickHandler(item:IButtonItem&lt;TProps&gt;){\n\t  strategy[item.prop]? strategy[item.prop](options):''\n  }\n  \n  return {\n    buttonTemplate,\n\tbuttonClickHandler\n  }\n}\n</code></pre>\n<pre><code class=\"language-ts\">// useTable.ts\nexport function useTable(){\n\tconst tableData = ref&lt;TTableDataItem&lt;any&gt;[]&gt;([])\n\tconst tableTemplate = reactive&lt;Record&lt;'label'|'prop',string&gt;[]&gt;([])\n    \n    let loadingInstance:LoadingInstance\n\tfunction getTableTemplate(){\n\t\tendTime.getTableTemplate().then(v=&gt;{\n\t\t\t// console.log(v);\n\t\t\tif(v.status){\n\t\t\t\ttableTemplate.splice(0,tableTemplate.length,...v.data)\n\t\t\t}\n\t\t\t\n\t\t})\n\t}\n\tgetTableTemplate()\n\tfunction getTableData&lt;T extends TFormData&gt;(formData:T){\n\t\tif(loadingInstance){\n\t\t\treturn\n\t\t}\n\t\t loadingInstance = ElLoadingService({\n\t\t\ttarget:'.paginationTable'\n\t\t})\n\t\t return  endTime.getTableData(formData).then(v=&gt;{\n\t\t\t if(v.status){\n\t\t\t\t tableData.value = v.data\n\t\t\t\t ElMessage.success('查询成功')\n\t\t\t }else{\n\t\t\t\tElMessage.error('查询失败')\n\t\t\t }\n\t\t  }).catch(e=&gt;{\n\t\t\tElNotification({\n\t\t\t\tmessage:e instanceof Error?e.message:e,\n\t\t\t\ttitle:'error'\n\t\t\t})\n\t\t  }).finally(()=&gt;{\n\t\t\tloadingInstance?.close()\n\t\t\tloadingInstance = null\n\t\t  })\n\t}\n\treturn {\n\t\ttableTemplate,\n\t\ttableData,\n\t\tgetTableData\n\t}\n}\n</code></pre>\n<p>现在vue文件就非常清爽了。</p>\n<pre><code class=\"language-vue\">&lt;script lang=&quot;ts&quot; setup&gt;\nimport { useButton } from './useButton';\nimport { useForm } from './useForm';\nimport FormCondition from '@/components/publicComponents/formCondition/index.vue'\nimport Buttons from &quot;@/components/publicComponents/buttons/index.vue&quot;\nimport PaginationTable  from '@/components/publicComponents/paginationTable/index.vue'\nimport { useTable } from './useTable';\nimport { useExportExcel } from '@/hooks/useExportExcel'\nimport { onMounted, reactive } from 'vue';\n\nconst {formData,formTemplate} = useForm()\n\nconst {tableData,tableTemplate,getTableData} = useTable()\n\nconst {exportExcel} = useExportExcel({tableData,tableTemplate})\n\nconst {buttonTemplate, buttonClickHandler} = useButton({formData,exportExcel,getTableData})\n\n\nconst tableSetting:Partial&lt;IPaginationTable&lt;any&gt;&gt; = {\n\tpagination:reactive({\n      currentPageNum: 1,\n      pageSizes: [15,20,30],\n      total: 0,\n      pageSize: 20\n    })\n}\n\nonMounted(()=&gt;{\n\tbuttonClickHandler({prop:&quot;search&quot;,label:''})\n})\n\n\n&lt;/script&gt;\n\n&lt;template&gt;\n\t&lt;div class=&quot;end-time-container&quot;&gt;\n          &lt;FormCondition :template=&quot;formTemplate&quot; :formdata=&quot;formData&quot;&gt;\n\t\t\t&lt;template #last&gt;\n\t\t\t\t&lt;Buttons :template=&quot;buttonTemplate&quot; @button-click=&quot;buttonClickHandler&quot;&gt;&lt;/Buttons&gt;\n\t\t\t&lt;/template&gt;\n\t\t  &lt;/FormCondition&gt;\n\t\t  &lt;PaginationTable :table-config=&quot;{tableData,tableTemplate}&quot; :pagination=&quot;tableSetting.pagination&quot;&gt;&lt;/PaginationTable&gt;\n\n\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n",
    },
  },
  6: {
    code: 200,
    data: {
      id: 6,
      title: "模具备模看板",
      description: "特定数据看板",
      scanNumber: "0",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "chartboard",
          name: "chartBoard",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            {
              anchor: "%E7%BB%93%E6%9E%84",
              name: "结构",
              tag: "h2",
              children: [
                { anchor: "vue", name: "vue", tag: "h3", children: [] },
                { anchor: "hooks", name: "hooks", tag: "h3", children: [] },
              ],
            },
          ],
        },
      ],
      htmlContent:
        '<h1 id="chartboard" tabindex="-1">chartBoard</h1>\n<h2 id="%E6%95%88%E6%9E%9C" tabindex="-1">效果</h2>\n<p><img src="' +
        images.board +
        "\" alt=\"board\"></p>\n<h2 id=\"%E7%BB%93%E6%9E%84\" tabindex=\"-1\">结构</h2>\n<h3 id=\"vue\" tabindex=\"-1\">vue</h3>\n<pre><code class=\"language-vue\">//index.vue\n//整体分为三个hook，一目了然\n&lt;script lang=&quot;ts&quot; setup&gt;\n\nimport EditableTable from '@/components/common/tables/editableTable/index.vue'\nimport { onBeforeUnmount } from 'vue';\nimport { plainToClass } from 'class-transformer'\nimport useBoardTable from './useBoardTable'\nimport useWarningList from './useWarningList'\nimport usePie from './usePie'\n\nlet intervalTime = 30 * 1000\n\nusePie(intervalTime)\n\nconst { tableData, getTableData } = useBoardTable()\n\nlet getTableDataTimer = setInterval(() =&gt; {\n\tgetTableData()\n}, intervalTime)\nonBeforeUnmount(() =&gt; {\n\tgetTableDataTimer &amp;&amp; clearInterval(getTableDataTimer)\n})\n\nconst { warningList, getWarningList } = useWarningList()\nconst getWarningListTimer = setTimeout(() =&gt; {\n\tgetWarningList()\n}, intervalTime);\nonBeforeUnmount(() =&gt; {\n\tgetWarningListTimer &amp;&amp; clearInterval(getWarningListTimer)\n})\n\n\n&lt;/script&gt;\n</code></pre>\n<h3 id=\"hooks\" tabindex=\"-1\">hooks</h3>\n<pre><code class=\"language-ts\">//usePie.ts\nimport EchartsHelper from &quot;@/utils/echartsHelper&quot;\nimport * as API from &quot;@/api/board&quot;\nimport { onBeforeUnmount, onMounted } from &quot;vue&quot;\nimport { option } from &quot;./echarts&quot;\n\nexport default function (intervalTime: number) {\n\n  let echartsInstance: EchartsHelper = null\n  const getPieDataTimer = setInterval(() =&gt; {\n    getPieData()\n  }, intervalTime)\n  function getPieData() {\n    API.getPieData().then((v) =&gt; {\n      echartsInstance?.updateChart({\n        option: {\n          dataset: {\n            source: v\n          }\n        }\n      })\n    })\n  }\n  onMounted(() =&gt; {\n    const dom = document.querySelector(&quot;#dq9boardContainerPie&quot;) as HTMLElement\n    echartsInstance = dom &amp;&amp; EchartsHelper.init({ dom })\n    echartsInstance?.updateChart({ option })\n    getPieData()\n  })\n  onBeforeUnmount(() =&gt; {\n    echartsInstance?.destroy()\n    echartsInstance = null\n    getPieDataTimer &amp;&amp; clearInterval(getPieDataTimer)\n  })\n}\n\n</code></pre>\n<pre><code class=\"language-ts\">// useBoardTable.ts\nimport { IPaginationTable } from '@/components/common/tables/editableTable'\nimport { reactive } from 'vue'\nimport { EventEmitter } from '@/utils/eventEmitter';\nimport * as API from '@/api/board'\n\n\n export default function (){\n\tconst tableData: Partial&lt;IPaginationTable&lt;Record&lt;string, any&gt;&gt;&gt; = {\n\t\ttableConfig: reactive({\n\t\t\ttableData: [],\n\t\t\ttableTemplate: []\n\t\t}),\n\t\tminWidth:{\n\t\t\tpartNumber:130,lastProdPartNumber:130,\n\t\t\tworkOrderNumber:130\n\t\n\t\t}\n\t}\n\tfunction getTableData(){\n\t\tAPI.getBoardTableData().then(v =&gt; {\n\t\t\ttableData.tableConfig.tableData = v\n\t\t})\n\t}\n\tfunction getTableTemplate(){\n\t\tAPI.getTableTemplate().then(v =&gt; {\n\t\t\ttableData.tableConfig.tableTemplate = v\n\t\t})\n\t}\n\tgetTableData();\n\tgetTableTemplate()\n\treturn {\n\t\ttableData,\n\t\tgetTableData\n\t}\n }\n</code></pre>\n<pre><code class=\"language-ts\">//useWarningList\nimport { ref } from 'vue'\nimport * as API from '@/api/board'\n\nexport default function(){\n\tconst warningList = ref&lt;string[]&gt;([])\n\n\tfunction getWarningList(){\n\t\tAPI.getWarningList().then(v =&gt; {\n\t\t\twarningList.value = v\n\t\t})\n\t}\n\tgetWarningList()\n    return {\n\t\twarningList,getWarningList\n\t}\n\n}\n</code></pre>\n",
    },
  },
} as unknown as Record<any, IResponse<IDetailArticle>>

export const projectItem4JP = {
  6: {
    code: 200,
    data: {
      id: 6,
      title: "キャビティーかんばんボード",
      description: "特定データかんばんボード",
      scanNumber: "0",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "chartboard",
          name: "chartBoard",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            {
              anchor: "%E6%A7%8B%E9%80%A0",
              name: "構造",
              tag: "h2",
              children: [
                { anchor: "vue", name: "vue", tag: "h3", children: [] },
                { anchor: "hooks", name: "hooks", tag: "h3", children: [] },
              ],
            },
          ],
        },
      ],
      htmlContent: `<h1 id="chartboard" tabindex="-1">chartBoard</h1>\n<h2 id="%E6%95%88%E6%9E%9C" tabindex="-1">效果</h2>\n<p><img src="${images.board}" alt="board"></p>\n<h2 id="%E6%A7%8B%E9%80%A0" tabindex="-1">構造</h2>\n<h3 id="vue" tabindex="-1">vue</h3>\n<pre><code class="language-vue">//index.vue\n//整体分为三个hook，一目了然\n&lt;script lang=&quot;ts&quot; setup&gt;\n\nimport EditableTable from \'@/components/common/tables/editableTable/index.vue\'\nimport { onBeforeUnmount } from \'vue\';\nimport { plainToClass } from \'class-transformer\'\nimport useBoardTable from \'./useBoardTable\'\nimport useWarningList from \'./useWarningList\'\nimport usePie from \'./usePie\'\n\nlet intervalTime = 30 * 1000\n\nusePie(intervalTime)\n\nconst { tableData, getTableData } = useBoardTable()\n\nlet getTableDataTimer = setInterval(() =&gt; {\n\tgetTableData()\n}, intervalTime)\nonBeforeUnmount(() =&gt; {\n\tgetTableDataTimer &amp;&amp; clearInterval(getTableDataTimer)\n})\n\nconst { warningList, getWarningList } = useWarningList()\nconst getWarningListTimer = setTimeout(() =&gt; {\n\tgetWarningList()\n}, intervalTime);\nonBeforeUnmount(() =&gt; {\n\tgetWarningListTimer &amp;&amp; clearInterval(getWarningListTimer)\n})\n\n\n&lt;/script&gt;\n</code></pre>\n<h3 id="hooks" tabindex="-1">hooks</h3>\n<pre><code class="language-ts">//usePie.ts\nimport EchartsHelper from &quot;@/utils/echartsHelper&quot;\nimport * as API from &quot;@/api/board&quot;\nimport { onBeforeUnmount, onMounted } from &quot;vue&quot;\nimport { option } from &quot;./echarts&quot;\n\nexport default function (intervalTime: number) {\n\n  let echartsInstance: EchartsHelper = null\n  const getPieDataTimer = setInterval(() =&gt; {\n    getPieData()\n  }, intervalTime)\n  function getPieData() {\n    API.getPieData().then((v) =&gt; {\n      echartsInstance?.updateChart({\n        option: {\n          dataset: {\n            source: v\n          }\n        }\n      })\n    })\n  }\n  onMounted(() =&gt; {\n    const dom = document.querySelector(&quot;#dq9boardContainerPie&quot;) as HTMLElement\n    echartsInstance = dom &amp;&amp; EchartsHelper.init({ dom })\n    echartsInstance?.updateChart({ option })\n    getPieData()\n  })\n  onBeforeUnmount(() =&gt; {\n    echartsInstance?.destroy()\n    echartsInstance = null\n    getPieDataTimer &amp;&amp; clearInterval(getPieDataTimer)\n  })\n}\n\n</code></pre>\n<pre><code class="language-ts">// useBoardTable.ts\nimport { IPaginationTable } from \'@/components/common/tables/editableTable\'\nimport { reactive } from \'vue\'\nimport { EventEmitter } from \'@/utils/eventEmitter\';\nimport * as API from \'@/api/board\'\n\n\n export default function (){\n\tconst tableData: Partial&lt;IPaginationTable&lt;Record&lt;string, any&gt;&gt;&gt; = {\n\t\ttableConfig: reactive({\n\t\t\ttableData: [],\n\t\t\ttableTemplate: []\n\t\t}),\n\t\tminWidth:{\n\t\t\tpartNumber:130,lastProdPartNumber:130,\n\t\t\tworkOrderNumber:130\n\t\n\t\t}\n\t}\n\tfunction getTableData(){\n\t\tAPI.getBoardTableData().then(v =&gt; {\n\t\t\ttableData.tableConfig.tableData = v\n\t\t})\n\t}\n\tfunction getTableTemplate(){\n\t\tAPI.getTableTemplate().then(v =&gt; {\n\t\t\ttableData.tableConfig.tableTemplate = v\n\t\t})\n\t}\n\tgetTableData();\n\tgetTableTemplate()\n\treturn {\n\t\ttableData,\n\t\tgetTableData\n\t}\n }\n</code></pre>\n<pre><code class="language-ts">//useWarningList\nimport { ref } from \'vue\'\nimport * as API from \'@/api/board\'\n\nexport default function(){\n\tconst warningList = ref&lt;string[]&gt;([])\n\n\tfunction getWarningList(){\n\t\tAPI.getWarningList().then(v =&gt; {\n\t\t\twarningList.value = v\n\t\t})\n\t}\n\tgetWarningList()\n    return {\n\t\twarningList,getWarningList\n\t}\n\n}\n</code></pre>\n`,
    },
  },
  5: {
    code: 200,
    data: {
      id: 5,
      title: "キャビティー管理システム",
      description: "キャビティー管理システム",
      scanNumber: "0",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "vsp0modules",
          name: "VSP0Modules",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            { anchor: "%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E6%A7%8B%E9%80%A0", name: "プロジェクトの構造", tag: "h2", children: [] },
            {
              anchor: "layout",
              name: "Layout",
              tag: "h2",
              children: [
                {
                  anchor: "%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A8%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88",
                  name: "パブリックメソッドとコンポーネント",
                  tag: "h3",
                  children: [],
                },
              ],
            },
          ],
        },
      ],
      htmlContent:
        '<h1 id="vsp0modules" tabindex="-1">VSP0Modules</h1>\n<p>やっと vue3 を始めました。とても忙しかったので vue2 を使ったほうが簡単ですが、勉強をやめたくなかったので vue3 を使いました。</p>\n<h2 id="%E6%95%88%E6%9E%9C" tabindex="-1">效果</h2>\n<p><img src="' +
        images.vsp0 +
        '" alt="vsp0all"></p>\n<p><img src="' +
        images.vsp0Effect +
        '" alt="vsp0"></p>\n<h2 id="%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E6%A7%8B%E9%80%A0" tabindex="-1">プロジェクトの構造</h2>\n<p>構造は出来ていたと思います</p>\n<p><img src="' +
        images.vsp0struct +
        "\" alt=\"image-20240827200012949\"></p>\n<h2 id=\"layout\" tabindex=\"-1\">Layout</h2>\n<p>現時点で私の目に写っている Web ページは、LayOut に Route-view を追加したものです。Layout にはあまり気を配らず、ストア内で使用したいものを保存するだけで、Route-view に重点を置いています。</p>\n<h3 id=\"%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A8%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\" tabindex=\"-1\">パブリックメソッドとコンポーネント</h3>\n<p>おそらくフォーム（クエリ条件でもメンテナンス情報でも）＋ボタン（一部の操作）＋テーブル（結果）という構造が多く、無意識のうちに今のスタイルが形成されているのでしょう。</p>\n<p>しかし、それは2つの時期に分けることができます。</p>\n<h4>1.  typescript高度な学習を経て</h4>\n<p>OOP に夢中になり、フロントエンドとバックエンドを統合したいと考えました。</p>\n<h5>axios</h5>\n<pre><code class=\"language-ts\">class AxiosHelper{\n        public  request:&lt;T&gt;(config: AxiosRequestConfig) =&gt; Promise&lt;T&gt;\n        private instance:AxiosInstance\n        private constructor(){\n            this.instance= this.createInstance()\n            this.request = this.createRequset()\n        }\n        private createInstance(){\n            const instance = axios.create()\n            //设置拦截器\n            instance.interceptors.request.use(config=&gt;{\n              return  config\n            },error=&gt;Promise.reject(error))\n            instance.interceptors.response.use(\n                response=&gt;{\n                const apiData = response.data as IApiResponseData&lt;any&gt;                \n                return apiData as any\n\n            },\n            error=&gt;Promise.reject(error)\n            \n            )\n            return instance\n        }\n        private createRequset(){\n            return  &lt;T&gt;(config:AxiosRequestConfig):Promise&lt;T&gt;=&gt;{\n                const defaultConfig:AxiosRequestConfig = {\n                    headers:{\n                        Authorization:'',\n                        'Content-Type':config.headers?.['Content-Type']||'application/json',\n                       \n                    },\n                    timeout: 10000,\n                    baseURL: import.meta.env.VITE_BASE_API\n                    // process.env.VUE_APP_BASE_URL\n                    ,\n                    data: {}\n                } \n                return  this.instance({...defaultConfig,...config})\n           }\n        }\n        static _instance:AxiosHelper\n        static instance(){\n              if(this._instance){\n                  return this._instance\n              }else{\n                  this._instance = new AxiosHelper()\n                  return this.instance()\n              }\n        }\n  \n}\n\n const axiosHelper = AxiosHelper.instance()\n</code></pre>\n<h5>自分で書いたPromise</h5>\n<pre><code class=\"language-ts\">enum Status{\n     /**\n         * 等待/准备\n         */\n     pending = 'pending',\n     /**\n      * 执行态\n      */\n     fulFilled = &quot;fulFilled&quot;,\n     /**\n      * 拒绝\n      */\n     rejected = 'rejected'\n}\n\nclass MyPromise&lt;T&gt; implements MyPromiseTypes.IMyPromise&lt;T&gt;{\n    /**\n     * 三种状态\n     */\n    private status:MyPromiseTypes.TStatus\n    /**\n     * fulfilled value\n     * rejected err\n     * pending null\n     */\n    private result:T = null\n    /**\n     * 存储在当前promise里，即p里面，不是then的新的promisem,因为那个时候还没有生成\n     * 因为一个promise后面可以分开跟着无数then\n     * p.then()\n     * p.then()\n     * 需要一个queue去挨个执行\n     */\n    private handler:Array&lt;MyPromiseTypes.handlerItem&lt;T&gt;&gt; = []\n    constructor(executor: (resolve?:MyPromise&lt;T&gt;['resolve'],reject?:MyPromise&lt;T&gt;['reject'])=&gt;any){\n         this.status = Status.pending\n         try{\n            /**\n             * 注意点，resolve执行是在executor内部，this指向有问题\n             */\n            executor(this.resolve.bind(this),this.reject.bind(this)) \n         }catch(err){ \n            this.reject(err)\n         }\n         \n    }\n    resolve&lt;TResovle = T&gt;(value: TResovle){\n        this.changeStatus(Status.fulFilled,value)\n    }\n    reject(err){\n        this.changeStatus(Status.rejected,err) \n    }\n    private changeStatus(status:keyof MyPromiseTypes.Status,result:any){\n         if(this.status!==Status.pending) return //promise 状态不可逆\n         this.status = status\n         this.result = result \n         this.run()\n    }\n    private isPromiseLike&lt;R extends MyPromiseTypes.IMyPromiseLike&lt;T&gt;&gt;(callback: R){\n        if(callback &amp;&amp; (typeof callback=='function' || typeof callback=='object')){\n             return typeof callback.then == 'function'\n        }\n        return false  \n    }\n    \n    private add2MicroTask(func: MyPromise&lt;T&gt;['resolve']|MyPromise&lt;T&gt;['reject']){\n        //node 环境\n        if(process &amp;&amp; typeof process=== 'object' &amp;&amp; typeof process.nextTick === 'function'){\n            process.nextTick(func)\n        }else if(MutationObserver &amp;&amp; typeof MutationObserver === 'function'){\n            const ob = new MutationObserver(func)\n            const node = document.createTextNode(&quot;1&quot;)\n            ob.observe(node,{\n                characterData:true\n            })\n            node.data = &quot;2&quot;\n        }else{\n             setTimeout(func,0)\n        }\n    }\n   \n    then&lt;TReturn1 = T,TReturn2 = never&gt;(onfulfilled?:(res:T)=&gt;TReturn1|MyPromiseTypes.IMyPromiseLike&lt;TReturn1&gt;,onrejected?:(res: any)=&gt;TReturn2|MyPromiseTypes.IMyPromiseLike&lt;TReturn2&gt;):MyPromise&lt;TReturn1|TReturn2&gt;{\n        return new MyPromise&lt;TReturn1|TReturn2&gt;((resolve,reject)=&gt;{\n            this.handler.push({\n                onfulfilled,onrejected,resolve,reject\n            })\n            /**\n             * 注意，如果new 的时候是同步代码，then的时候其实已经执行完了，需要手动调用一次。\n             * 如果异步没有完成，这次会因为pending状态而什么都没做，等异步完成通过resolve，reject时候调用执行\n             */\n            this.run()\n        })\n        \n        \n    }\n   \n    \n    private runOneItem&lt;R extends MyPromiseTypes.handlerItem&lt;T&gt;&gt;({onfulfilled,onrejected,reject,resolve}:R){\n         this.add2MicroTask(()=&gt;{\n            const callback = this.status===Status.fulFilled?onfulfilled:onrejected\n            \n            //如果不是函数，新promise resolve 之前的result\n            if(typeof callback !== 'function'){\n                const settled = this.status === Status.fulFilled?resolve:reject\n                settled(this.result)\n                return\n            }\n            //是函数，如果执行成功就resolve,就算是onrejected里面的，也是resolve\n            try{\n                    const data = callback(this.result)\n                    if(this.isPromiseLike(data)){\n                        (data as MyPromise&lt;any&gt;).then(resolve,reject)\n                    }else{\n                        resolve(data)\n                    }\n                \n            }catch(err){\n                reject(err)\n            }\n            }\n        )\n\n    }\n\n\n \n    private run(){\n         if(this.status===Status.pending) return\n         else{\n            while(this.handler.length){\n                this.runOneItem(this.handler.shift())\n            }\n         }\n    }\n}\ndeclare namespace MyPromiseTypes{\n\n    declare enum Status{\n        /**\n         * 等待/准备\n         */\n        pending:'pending',\n        /**\n         * 执行态\n         */\n        fulFilled:&quot;fulFilled&quot;,\n        /**\n         * 拒绝\n         */\n        rejected:'rejected'\n    }\n    interface IMyPromiseLike&lt;T&gt;{\n         then:IMyPromise&lt;T&gt;['then']\n    }\n    type TStatus = keyof Status\n    interface handlerItem&lt;T&gt;{\n        resolve: MyPromise&lt;T&gt;['resolve']\n        reject: MyPromise&lt;T&gt;['reject']\n        onfulfilled:Parameters&lt;IMyPromise&lt;T&gt;['then']&gt;[0]\n        onrejected(res: any):any\n    } \n\n    interface IMyPromise&lt;T&gt;{\n        // status:keyof Status\n        /**\n         * pending-&gt;fulfilled\n         */\n        resolve&lt;R = T&gt;(value:R):void\n        /**\n         * pending=&gt;rejected\n         */\n        reject(value: any):void\n        /**\n         * \n         * @param onfulfilled \n         * @param onrejected \n         * @description 需要执行的回调,全部存在handler数组里面了，执行当状态改变会执行回调函数\n         * 回调分为三种 \n         * 1.函数，执行成功resolve，失败reject\n         * 2.promiseLike即有then回调的\n         * 3.非上面两种，直接将继承之前的promise状态与值\n         */\n        then&lt;TReturn1 = T,TReturn2 = never&gt;(onfulfilled:(res:T)=&gt;TReturn1|IMyPromiseLike&lt;TReturn1&gt;,onrejected?:(res: any)=&gt;TReturn2|IMyPromiseLike&lt;TReturn2&gt;):MyPromise&lt;TReturn1|TReturn2&gt;\n        \n    }\n    \n\n}\n</code></pre>\n<h5>Form</h5>\n<pre><code class=\"language-ts\">// form.d.ts\n\n/**\n * all formitem type enum\n */\ndeclare  enum EFormItemType{\n   input = 'input',\n   date = 'date',\n   select = 'select'\n}\n/**\n * all formitem type\n */\ntype TSearchItem = keyof typeof EFormItemType\n/**\n * if formitem is select,then it can has some options\n * option type\n */\ntype TSelectOption&lt;T extends string = string&gt; = T | {value:T,label: string} \n\n/**\n * getFormTemplate params.\n * can auto fill content\n */\ninterface IFormTemplateOption&lt;T extends (string[]|readonly string[]),TType extends Partial&lt;Record&lt;ArrayKey&lt;T&gt;,EFormItemType&gt;&gt;&gt;{\n\tlabels:string[],\n\tprops:T, \n\ttypes?:TType,\n\toptions?:{\n\t\t [k in keyof TType as TType[k] extends EFormItemType.select?k :never]?: TSelectOption[]\n\t},\n\treadonlys?:{[k in ArrayKey&lt;T&gt;]?:boolean}\n }\n /**\n  * getFormTemplate Return data\n  */\n interface IFormItem&lt;T extends string&gt;{\n\t label: string,\n\t prop: T\n\t type?:EFormItemType\n\t options?:IFormItem&lt;T&gt;['type'] extends EFormItemType.select?TSelectOption[]:never\n\t readonly?:boolean\n }\n\n\n\n/**\n * getFormData param\n */\ninterface IFormDataOption&lt;T extends string[]|readonly string[]&gt;{\n\tprops:T,\n\tdefaultData?:Partial&lt;Record&lt;ArrayKey&lt;T&gt;,string&gt;&gt;\n}\n\n\n /**\n  * formitem type\n  */\n type ICondition&lt;T extends string&gt; = {\n\t[k in  T]: string\n }\n\n\n interface IFormComponent&lt;T extends string = any&gt;{\n    template: IFormItem&lt;T&gt;[]\n\tformdata: ICondition&lt;T&gt;\n }\n\n//form.ts\n\nexport enum EFormItemType  {\n\tinput = 'input',\n\tdate = 'date',\n\tselect = 'select'\n}\n\nexport function getFormTemplate&lt;\n        T extends string[]|readonly string[],\n\t\tR extends Partial&lt;Record&lt;ArrayKey&lt;T&gt;,EFormItemType&gt;&gt;\n&gt;({labels,props,types,options,readonlys}:IFormTemplateOption&lt;T,R&gt;){\n\ttypes = types||{} as R\n    options = options||{}\n    readonlys = readonlys||{}\n    if(labels.length !== props.length){\n      throw new Error('label and prop are not corrent')\n    }\n    return props.map((prop:ArrayKey&lt;T&gt;,i)=&gt;{\n      const label = labels[i] \n      const type = types[prop] \n      const option = options[prop as any] as TSelectOption[]\n      const readonly = readonlys[prop]\n      return {\n          label,prop,\n          ...type?{type}:{},\n          ...option?{option}:{},\n          ...readonly?{readonly}:{}\n      }\n   })\n}\n\nexport function getFormData&lt;T extends string[]|readonly string[]&gt;({props,defaultData={}}:IFormDataOption&lt;T&gt;){\n    return Object.fromEntries(props.map(v=&gt;[v,defaultData[v]||null]))  as ICondition&lt;ArrayKey&lt;T&gt;&gt;\n}\n</code></pre>\n<pre><code class=\"language-vue\">\n&lt;script lang=&quot;ts&quot; setup&gt;\nimport { EFormItemType } from '@/utils/template/form'\nconst { formdata, template } = defineProps&lt;IFormComponent&gt;()\n&lt;/script&gt;\n\n&lt;template&gt;\n\t&lt;div class=&quot;form-container&quot;&gt;\n\t\t&lt;ElForm inline&gt;\n\t\t\t&lt;template v-for=&quot;item of template&quot; :key=&quot;item.prop&quot;&gt;\n\t\t\t\t&lt;slot :name=&quot;item.prop&quot;&gt;\n\t\t\t\t\t&lt;ElFormItem class=&quot;form-item&quot; :label=&quot;item.label&quot;&gt;\n\t\t\t\t\t\t&lt;template v-if=&quot;item.type === EFormItemType.select&quot;&gt;\n\t\t\t\t\t\t\t&lt;ElSelect v-model=&quot;formdata[item.prop]&quot;&gt;\n\t\t\t\t\t\t\t\t&lt;template v-if=&quot;item.options&quot; v-for=&quot;(option, index) of &lt;TSelectOption[]&gt;item.options &quot;&gt;\n\t\t\t\t\t\t\t\t\t&lt;ElOption v-if=&quot;typeof option === 'object'&quot; :label=&quot;option.label&quot;\n\t\t\t\t\t\t\t\t\t\t:value=&quot;option.value&quot; :key=&quot;index&quot;&gt;&lt;/ElOption&gt;\n\t\t\t\t\t\t\t\t\t&lt;ElOption v-else :label=&quot;option&quot; :value=&quot;option&quot;&gt;&lt;/ElOption&gt;\n\t\t\t\t\t\t\t\t&lt;/template&gt;\n\t\t\t\t\t\t\t&lt;/ElSelect&gt;\n\t\t\t\t\t\t&lt;/template&gt;\n\t\t\t\t\t\t&lt;template v-if=&quot;item.type === EFormItemType.date&quot;&gt;\n\t\t\t\t\t\t\t&lt;ElDatePicker v-model=&quot;formdata[item.prop]&quot; format=&quot;YYYY-MM-DD&quot; value-format='YYYY-MM-DD'\n\t\t\t\t\t\t\t\tclearable&gt;&lt;/ElDatePicker&gt;\n\t\t\t\t\t\t&lt;/template&gt;\n\t\t\t\t\t\t&lt;template v-else&gt;\n\t\t\t\t\t\t\t&lt;ElInput v-model=&quot;formdata[item.prop]&quot;&gt;&lt;/ElInput&gt;\n\t\t\t\t\t\t&lt;/template&gt;\n\n\t\t\t\t\t&lt;/ElFormItem&gt;\n\t\t\t\t&lt;/slot&gt;\n\t\t\t&lt;/template&gt;\n\t\t\t&lt;ElFormItem class=&quot;form-item&quot;&gt;\n\t\t\t\t&lt;slot name=&quot;last&quot;&gt;&lt;/slot&gt;\n\t\t\t&lt;/ElFormItem&gt;\n\n\t\t&lt;/ElForm&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<h5>buttons</h5>\n<pre><code class=\"language-ts\">// buttons.d.ts\nimport type { ButtonType } from &quot;element-plus&quot;\nimport { DefineComponent } from &quot;vue&quot;\n\ndeclare global {\n  type TButtonType = ButtonType\n  type TIcon = DefineComponent\n  \n  interface IButtonOption&lt;T extends string[]| readonly string[]&gt; {\n    labels: string[]\n    props: T\n    icons?: Partial&lt;Record&lt;ArrayKey&lt;T&gt;,TIcon&gt;&gt;\n    types?: Partial&lt;Record&lt;ArrayKey&lt;T&gt;,TButtonType&gt;&gt;,\n  }\n\n  interface IButtonItem&lt;T extends string&gt;{\n     label: string\n\t prop: T\n\t icon?: TIcon\n\t type?:TButtonType\n  }\n\n  interface IButtonProps&lt;T = any&gt;{\n\t  template: IButtonItem&lt;T&gt;[]\n\t//   events:Partial&lt;Record&lt;TEvent,(...any)=&gt;any&gt;&gt;\n  }\n}\n//button.ts\nexport function getButtonTemplate&lt;T extends string[]| readonly string[]&gt;({props,labels,icons={},types={}}:IButtonOption&lt;T&gt;){\t\n    if(labels.length !== props.length){\n       throw new Error('length is diff between labels and props')\n\t}\n\treturn props.map((prop:ArrayKey&lt;T&gt;,index)=&gt;{\n\t\t const label = labels[index]\n\t\t const res:IButtonItem&lt;ArrayKey&lt;T&gt;&gt; = {\n\t\t\tprop,\n\t\t\tlabel,\n\t\t }\n\t\t icons[prop] &amp;&amp; Reflect.set(res,'icon',icons[prop])\n\t\t types[prop] &amp;&amp; Reflect.set(res,'type',types[prop])\n\t\t return res\n\t})\n\n}\n</code></pre>\n<pre><code class=\"language-vue\">&lt;script lang=&quot;ts&quot; setup&gt;\nconst {template,} = defineProps&lt;IButtonProps&gt;()\nconst emit = defineEmits&lt;{\n\t(event: 'buttonClick',item: IButtonItem&lt;any&gt;)\n}&gt;()\nfunction handleClick(e:MouseEvent,item: IButtonItem&lt;any&gt;){\n\te.stopPropagation()\n    emit('buttonClick',item)\n\t\n}\n&lt;/script&gt;\n\n&lt;template&gt;\n\t&lt;div class=&quot;buttons-container&quot;&gt;\n\t\t&lt;ElButton v-for=&quot;item of template&quot; :key=&quot;item.prop&quot; :type=&quot;item.type&quot; :icon=&quot;item.icon&quot;\n\t\t @click=&quot;e=&gt;handleClick(e,item)&quot;\n\t\t&gt;{{ item.label }}&lt;/ElButton&gt;\n\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<h5>table</h5>\n<pre><code class=\"language-ts\">//table.d.ts\nimport type { TableInstance } from &quot;element-plus&quot;\nimport {UnwrapNestedRefs} from 'vue'\n\ntype FuncFirstParam&lt;T extends (...arg: any) =&gt; any&gt; = T extends (\n  ...arg: [infer R]\n) =&gt; any\n  ? R\n  : any\ntype TEvents = FuncFirstParam&lt;TableInstance[&quot;$emit&quot;]&gt;\n\ndeclare global {\n  interface IPaginationTable&lt;T extends Record&lt;string, any&gt; = any&gt; {\n    /**\n     * 满足loading的querySelector用\n     */\n    class?: string\n    tableConfig: UnwrapNestedRefs&lt;{\n      tableData: T[]\n      tableTemplate: Array&lt;\n        Record&lt;&quot;label&quot; | &quot;prop&quot;, string&gt; &amp; { [k: string]: string }\n      &gt;\n    }&gt;\n    columnConfig?: UnwrapNestedRefs&lt;TElTableColumnConfig&lt;string&gt;&gt;\n    pagination?: UnwrapNestedRefs&lt;{\n      currentPageNum: number\n      pageSizes: number[]\n      total: number\n      pageSize: number\n    }&gt;\n    onClickRow?: (row: T) =&gt; any\n    rowStyle?: (data: { row: T; rowIndex: number }) =&gt; Object\n    events?: Partial&lt;Record&lt;TEvents, (...arg: any) =&gt; any&gt;&gt;\n  }\n  type TElTableColumnConfig&lt;T extends string&gt; = Partial&lt;\n    Record&lt;\n      T,\n      {\n        type?: &quot;input&quot; | &quot;select&quot; | &quot;color&quot;\n        options?: { value: string; tip?: string; label: string }[] | string[]\n        cannotedit?: true\n        cannotshow?: true\n      }\n    &gt;\n  &gt;\n\n  type TTableDataItem&lt;T extends string[]|readonly string[]&gt; = {\n\t   [k in ArrayKey&lt;T&gt;]: string\n\t  \n  } &amp; { [k: string] : any}\n\n\n  type TTableTemplateItem = Record&lt;'label'|'prop',string&gt;\n}\n//table.ts\n\nexport function getTableTemplate&lt;T extends string[]|readonly string[]&gt;({props,labels}:{props:T,labels: string[]}){\n\tif(props.length!==labels.length){\n\t\tthrow new Error('length is diff between labels and props')\n\t}\n\n\treturn props.map((prop,i)=&gt;({prop,label:labels[i]}))\n}\n</code></pre>\n<pre><code class=\"language-vue\">&lt;script lang=&quot;ts&quot; setup&gt;\nimport { computed, toRefs,reactive } from 'vue'\nimport {paginationTable} from '.'\n\nconst props = withDefaults(defineProps&lt;paginationTable.IPaginationTable&gt;(),{\n    pagination:()=&gt;reactive({  currentPageNum:1, pageSizes:[2,5,10], total:0, pageSize:5 }),\n    columnConfig:()=&gt;reactive({}),\n\tevents:()=&gt;reactive({})\n\t\n})\nconst displayData = computed(()=&gt;{\n    const {pageSize: size,currentPageNum: page,total} = toRefs(props.pagination)\n    total.value = props.tableConfig.tableData.length\n     const res = props.tableConfig.tableData.filter((x,i)=&gt;i&lt;size.value*page.value&amp;&amp;i&gt;=size.value*(page.value-1))\n     return res\n})\n\n&lt;/script&gt;\n\n\n&lt;template&gt;\n\t&lt;div class=&quot;paginationTableContainer&quot;&gt;\n    &lt;div class=&quot;paginationTable&quot; &gt;\n        &lt;ElTable border stripe :class=&quot;class&quot; :data=&quot;displayData&quot; fit flexible highlight-current-row \n\t\t height=&quot;100%&quot; :row-style=&quot;(rowStyle as any)&quot;\n\t      v-on=&quot;events&quot;\n\t\t  &gt;\n            &lt;template v-for=&quot;item of props.tableConfig.tableTemplate&quot; &gt;\n                &lt;ElTableColumn min-width=&quot;150px&quot; v-if=&quot;!columnConfig[item.prop] || !columnConfig[item.prop].cannotshow&quot;  :label=&quot;item.label&quot; :prop=&quot;item.prop&quot; :key=&quot;item.prop&quot;\n                   align=&quot;center&quot; resizable show-overflow-tooltip&gt;\n                    &lt;template v-if=&quot;columnConfig[item.prop] &amp;&amp; columnConfig[item.prop].type=='color'&quot; #default=&quot;scope&quot;&gt;\n                        &lt;ElColorPicker :model-value=&quot;scope.row[item.prop]&quot;  disabled&gt;&lt;/ElColorPicker&gt;\n                    &lt;/template&gt;\n                &lt;/ElTableColumn&gt;\n           &lt;/template&gt;\n        &lt;/ElTable&gt;\n    &lt;/div&gt;\n    &lt;ElPagination  v-model:page-size=&quot;pagination.pageSize&quot; v-model:current-page=&quot;pagination.currentPageNum&quot;\n               :total=&quot;pagination.total&quot; :page-sizes=&quot;pagination.pageSizes&quot; layout=&quot;total, sizes, prev, pager, next, jumper&quot;\n            &gt;&lt;/ElPagination&gt;\n\t\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>使用</p>\n<pre><code class=\"language-vue\">&lt;script lang=&quot;ts&quot; setup&gt;\nimport { reactive, ref,onBeforeMount } from 'vue';\nimport {formTemplate,conditions,buttonTemplate} from '.'\nimport {TButtonProp,TTableItem} from 'backupModel'\nimport {backupModelList as backupModelListApi} from '@/api/backupModel'\nimport { ElMessage, ElNotification} from 'element-plus';\nimport PaginationTable from '@/components/publicComponents/paginationTable/index.vue'\nimport { paginationTable } from 'customComponent'\nimport { excelOut } from '@/utils/excelHelper';\nimport { getExcelData, sleep } from '@/utils/common';\nimport {TFormDataProp} from 'backupModel'\n\nonBeforeMount(()=&gt;{\n     backupModelListApi.getTableTemplate().then(v=&gt;{\n         if(v.status){\n             tableTemplate.value = v.data\n         }\n     })\n})\n\nconst formData = ref(conditions)\nconst tableData = ref&lt;TTableItem[]&gt;([])\nconst tableTemplate = ref&lt;Array&lt;{prop:keyof TTableItem,label: string}&gt;&gt;([])\nlet currentRow:TTableItem = null\nconst tableConfig:Partial&lt;paginationTable.IPaginationTable&lt;TTableItem&gt;&gt; = {\n    pagination:reactive({\n        currentPageNum:1,\n        pageSizes:[10,15,20],\n        total:0,\n        pageSize:15\n      }),\n\t  events:{\n\t\t'row-click':(row:TTableItem)=&gt;{\t\t\t\n            currentRow = row\n\t\t},\n\t\t'row-dblclick':(row:TTableItem)=&gt;{\n\t\t\t// console.log(row);\n\t\t    formData.value.workOrderNumber = row.workOrderNumber\n\t\t}\n\t  }\n}\n\nconst buttonClick = &lt;T extends TButtonProp&gt;(type: T)=&gt;{\n    const strategy:Record&lt;TButtonProp,()=&gt;any&gt; = {\n         search(){\n            // if(!formData.value.mouldSteelGrade){\n            //     ElMessage.info('模具钢号为空')\n            //     return\n            // }\n            backupModelListApi.search({...formData.value,dom:'.tableContainer'}).then(v=&gt;{\n                 if(v.status &amp;&amp; v.data){\n                    //  ElMessage.success('查询成功')\n                     tableData.value = v.data\n                 }else{\n                     ElMessage.info('查询失败')\n                     tableData.value = []\n                 }\n            })\n         },\n         backupFinish(){\n            if(!currentRow){\n                 ElMessage.info('请选择要备模行')\n                 return\n            }\n\t\t\tif(currentRow.workOrderNumber!==formData.value.workOrderNumber){\n\t\t\t\tElMessage.info('请选择要备模行')\n\t\t\t\treturn\n\t\t\t}\n\n\n\n            backupModelListApi.backupFinish({...currentRow,dom:'.tableContainer',mouldSteelGrade:formData.value.mouldSteelGrade}).then(v=&gt;{\n                if(v.status &amp;&amp; v.data){\n                     ElMessage.success('备模成功')\n                     strategy.search()\n                }else{\n                    ElMessage.error('备模失败')\n                }\n                \n            })\n         },\n         excelOut(){\n            if(!tableData.value.length){\n                 ElMessage({type:'info',message:&quot;无数据可以导出&quot;})\n                 return\n            }\n            const excelData = getExcelData({name:&quot;备模清单&quot;,tableTemplate: tableTemplate.value,tableData:tableData.value})\n            excelOut(excelData.name,excelData.headers as any,excelData.series)\n         }\n    }\n    strategy[type]()\n}\n\nconst visibleChange = (prop:TFormDataProp,visible:boolean)=&gt;{\n\tconst strategy:Partial&lt;Record&lt;TFormDataProp,()=&gt;any&gt;&gt; = {\n\t\t mouldSteelGrade:()=&gt;{\n\t\t\tif(visible){\n\t\t\t\tconst mouldSteelGrade = ref()\n\t\t\t\tconst templateRow = formTemplate.find(x=&gt;x.prop===prop);\n\t\t\t\t(templateRow as any).loading = true\n                backupModelListApi.getMouldSteelGradeFromMSch(formData.value).then(v=&gt;{\n\t\t\t\t\tif(v.status){\n\t\t\t\t\t\ttemplateRow.option = v.data\n\t\t\t\t\t}else{\n\t\t\t\t\t\tElNotification({\n\t\t\t\t\t\t\ttitle:`getMouldSteelGradeFromMSch error`,\n\t\t\t\t\t\t\ttype:'error',\n\t\t\t\t\t\t\tmessage:v.data as any\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}).finally(()=&gt;{\n\t\t\t\t\t(templateRow as any).loading = false\n\t\t\t\t})\n\t\t\n\t\t\t}\n\t\t }\n\t}\n\tstrategy[prop] &amp;&amp; strategy[prop]()\n}\n\n\n\n// console.log(formTemplate);\n\n\n&lt;/script&gt;\n\n\n&lt;template&gt;\n    &lt;div class=&quot;backupModelList&quot;&gt;\n        &lt;div class=&quot;header&quot;&gt;\n            &lt;ElForm class=&quot;myForm&quot;&gt;\n                &lt;!-- 之前的display:inline-block;不想改,就在下面加了一个flex的div --&gt;\n                &lt;div&gt;\n                    &lt;ElFormItem v-for=&quot;item of formTemplate&quot; :label=&quot;item.label&quot; :key=&quot;item.prop&quot;&gt;\n                        &lt;ElSelect v-model=&quot;formData[item.prop]&quot; clearable v-if=&quot;item.type &amp;&amp; item.type==='select'&quot; \n\t\t\t\t\t\t @visible-change=&quot;visible=&gt;visibleChange(item.prop,visible)&quot;\n\t\t\t\t\t\t :loading=&quot;(item as any).loading&quot;\n\t\t\t\t\t\t &gt;\n\t\t\t\t\t\t\t&lt;template v-if=&quot;item.option&quot;&gt;\n\t\t\t\t\t\t\t\t&lt;ElOption v-for=&quot;op of item.option&quot; :key=&quot;op&quot; :value=&quot;op&quot; :label=&quot;op&quot;&gt;&lt;/ElOption&gt;\n\t\t\t\t\t\t\t&lt;/template&gt;\n                        &lt;/ElSelect&gt;\n                        &lt;ElInput v-else v-model=&quot;formData[item.prop]&quot;&gt;&lt;/ElInput&gt;\n                    &lt;/ElFormItem&gt;\n                &lt;/div&gt;\n                \n            &lt;/ElForm&gt;\n            &lt;div class=&quot;buttonContainer&quot;&gt;\n                &lt;ElButton v-for=&quot;item of buttonTemplate&quot; :key=&quot;item.prop&quot; :icon=&quot;item.icon&quot; :type=&quot;item.type&quot; @click=&quot;buttonClick(item.prop)&quot;&gt;\n                {{ item.label }}\n                &lt;/ElButton&gt;\n            &lt;/div&gt;\n                              \n        &lt;/div&gt;\n        &lt;div class=&quot;tableContainer&quot;&gt;\n            &lt;PaginationTable :table-config=&quot;{tableTemplate,tableData}&quot; :pagination=&quot;tableConfig.pagination&quot; \n\t\t\t:events=&quot;tableConfig.events&quot;&gt;&lt;/PaginationTable&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n<p>此时也还没有从vue2中完成出来，虽然确实写在了一起，但感觉莫名有点乱。</p>\n<h4>2.  React勉強を経て</h4>\n<p>クラスや OOP には何の問題もありませんが、ts のクラスは少し奇妙です。バックエンドのようにプロパティをプライベートにしたい場合、get と set を介してのみアクセスできます。書く分には問題ないのですが、LoopしたいときやObject.keysやReflect.ownKeysなどを持ちたいときはprivateプロパティを持ち出すことになります。だってtsがコンパイルされると消えてしまいます。 もちろん、新しい Proxy を介して ownKeys を設定することもできますが、これは複雑すぎると感じ、将来的に他の操作があるかどうかもわかりません。 #prop を使うと互換性が悪く、見ていて不快になります。だから非常に混乱しています。</p>\n<p>Reactをクラスコンポーネントから関数コンポーネントまで学んでから、忘れていた関数が本当に素晴らしいってに気づきました。突然、啓発されたような気分になり、hooksって神かも。</p>\n<p>この時点で、スタイルが再び変更され、Composition API が採用され始めました。</p>\n<pre><code class=\"language-ts\">// useForm.ts\nexport function useForm(){\n\tconst formTemplate = getFormTemplate({\n\t\tprops,\n        //整个系统中某些数据库中列太常用，就设置成了enum\n\t\tlabels:[EModuleLabels.makeMachine,EModuleLabels.mouldSteelGrade]\n\t})\n\t\n\tconst formData = reactive(getFormData({props})) \n\treturn {\n       formData,\n\t   formTemplate\n\t}\n}\n</code></pre>\n<pre><code class=\"language-ts\">// useButton.ts\nconst strategy:Record&lt;TProps,(...arg: any)=&gt;any&gt; = {\n\tsearch({formData,getTableData}:IUseButtonProps&lt;TFormData&gt;){\n\t\tgetTableData &amp;&amp; formData &amp;&amp; getTableData(formData)\n\t},\n\texport({exportExcel}:IUseButtonProps&lt;any&gt;){\n\t\texportExcel &amp;&amp; exportExcel()\n\t}\n}\n\nexport function useButton&lt;T extends Record&lt;string,any&gt;&gt;(options: IUseButtonProps&lt;T&gt;) {\n  const buttonTemplate = getButtonTemplate({\n    props: buttonProps,\n    labels: buttonLabels,\n    icons: {\n      search: Search,\n      export: Download,\n    },\n    types: {\n      search: &quot;primary&quot;,\n      export: &quot;success&quot;,\n    },\n  })\n  \n  function buttonClickHandler(item:IButtonItem&lt;TProps&gt;){\n\t  strategy[item.prop]? strategy[item.prop](options):''\n  }\n  \n  return {\n    buttonTemplate,\n\tbuttonClickHandler\n  }\n}\n</code></pre>\n<pre><code class=\"language-ts\">// useTable.ts\nexport function useTable(){\n\tconst tableData = ref&lt;TTableDataItem&lt;any&gt;[]&gt;([])\n\tconst tableTemplate = reactive&lt;Record&lt;'label'|'prop',string&gt;[]&gt;([])\n    \n    let loadingInstance:LoadingInstance\n\tfunction getTableTemplate(){\n\t\tendTime.getTableTemplate().then(v=&gt;{\n\t\t\t// console.log(v);\n\t\t\tif(v.status){\n\t\t\t\ttableTemplate.splice(0,tableTemplate.length,...v.data)\n\t\t\t}\n\t\t\t\n\t\t})\n\t}\n\tgetTableTemplate()\n\tfunction getTableData&lt;T extends TFormData&gt;(formData:T){\n\t\tif(loadingInstance){\n\t\t\treturn\n\t\t}\n\t\t loadingInstance = ElLoadingService({\n\t\t\ttarget:'.paginationTable'\n\t\t})\n\t\t return  endTime.getTableData(formData).then(v=&gt;{\n\t\t\t if(v.status){\n\t\t\t\t tableData.value = v.data\n\t\t\t\t ElMessage.success('查询成功')\n\t\t\t }else{\n\t\t\t\tElMessage.error('查询失败')\n\t\t\t }\n\t\t  }).catch(e=&gt;{\n\t\t\tElNotification({\n\t\t\t\tmessage:e instanceof Error?e.message:e,\n\t\t\t\ttitle:'error'\n\t\t\t})\n\t\t  }).finally(()=&gt;{\n\t\t\tloadingInstance?.close()\n\t\t\tloadingInstance = null\n\t\t  })\n\t}\n\treturn {\n\t\ttableTemplate,\n\t\ttableData,\n\t\tgetTableData\n\t}\n}\n</code></pre>\n<p>これで、vue ファイルが非常に見やすくなりました。</p>\n<pre><code class=\"language-vue\">&lt;script lang=&quot;ts&quot; setup&gt;\nimport { useButton } from './useButton';\nimport { useForm } from './useForm';\nimport FormCondition from '@/components/publicComponents/formCondition/index.vue'\nimport Buttons from &quot;@/components/publicComponents/buttons/index.vue&quot;\nimport PaginationTable  from '@/components/publicComponents/paginationTable/index.vue'\nimport { useTable } from './useTable';\nimport { useExportExcel } from '@/hooks/useExportExcel'\nimport { onMounted, reactive } from 'vue';\n\nconst {formData,formTemplate} = useForm()\n\nconst {tableData,tableTemplate,getTableData} = useTable()\n\nconst {exportExcel} = useExportExcel({tableData,tableTemplate})\n\nconst {buttonTemplate, buttonClickHandler} = useButton({formData,exportExcel,getTableData})\n\n\nconst tableSetting:Partial&lt;IPaginationTable&lt;any&gt;&gt; = {\n\tpagination:reactive({\n      currentPageNum: 1,\n      pageSizes: [15,20,30],\n      total: 0,\n      pageSize: 20\n    })\n}\n\nonMounted(()=&gt;{\n\tbuttonClickHandler({prop:&quot;search&quot;,label:''})\n})\n\n\n&lt;/script&gt;\n\n&lt;template&gt;\n\t&lt;div class=&quot;end-time-container&quot;&gt;\n          &lt;FormCondition :template=&quot;formTemplate&quot; :formdata=&quot;formData&quot;&gt;\n\t\t\t&lt;template #last&gt;\n\t\t\t\t&lt;Buttons :template=&quot;buttonTemplate&quot; @button-click=&quot;buttonClickHandler&quot;&gt;&lt;/Buttons&gt;\n\t\t\t&lt;/template&gt;\n\t\t  &lt;/FormCondition&gt;\n\t\t  &lt;PaginationTable :table-config=&quot;{tableData,tableTemplate}&quot; :pagination=&quot;tableSetting.pagination&quot;&gt;&lt;/PaginationTable&gt;\n\n\t&lt;/div&gt;\n&lt;/template&gt;\n</code></pre>\n",
    },
  },
  4: {
    code: 200,
    data: {
      id: 4,
      title: "Big Data Board",
      description: "Big Data Board can see different chart about production",
      scanNumber: "0",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "%E7%94%9F%E7%94%A3%E8%A8%AD%E5%82%99%E7%8A%B6%E6%85%8B%E7%AE%A1%E7%90%86%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0",
          name: "生産設備状態管理システム",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            { anchor: "%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%A7%8B%E9%80%A0", name: "プロジェクト構造", tag: "h2", children: [] },
            { anchor: "prototype-extend", name: "prototype　extend", tag: "h2", children: [] },
            {
              anchor: "%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89",
              name: "カスタムメソッド",
              tag: "h2",
              children: [{ anchor: "%E6%94%B9%E8%89%AF%E3%81%95%E3%82%8C%E3%81%9F%E3%82%AB%E3%83%AB%E3%83%BC%E3%82%BB%E3%83%AB", name: "改良されたカルーセル", tag: "h3", children: [] }],
            },
            {
              anchor: "%E5%85%B1%E9%80%9A%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88",
              name: "共通コンポーネント",
              tag: "h2",
              children: [
                { anchor: "echarts%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88", name: "echartsコンポーネント", tag: "h3", children: [] },
                { anchor: "upload-excel%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88", name: "upload excelンポーネント", tag: "h3", children: [] },
              ],
            },
            { anchor: "store", name: "Store", tag: "h2", children: [] },
            { anchor: "route", name: "Route", tag: "h2", children: [] },
            { anchor: "%E3%81%BE%E3%81%A8%E3%82%81", name: "まとめ", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="%E7%94%9F%E7%94%A3%E8%A8%AD%E5%82%99%E7%8A%B6%E6%85%8B%E7%AE%A1%E7%90%86%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0" tabindex="-1">生産設備状態管理システム</h1>\n<p>この時に、私の Vue の動作には問題はありませんが、いくつかのモジュールのアイデアやロジックが非常に変に感じられ、また、私の Vue がエレガントに書かれていないように感じます。その際、比較的高品質なコードをいくつか参考し、これをベースに新しく学習した typescript を加えてこのプロジェクトを開始しました。</p>\n<h2 id="%E6%95%88%E6%9E%9C" tabindex="-1">效果</h2>\n<p><img src="' +
        images.msp0 +
        '" alt="msp0"></p>\n<h2 id="%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%A7%8B%E9%80%A0" tabindex="-1">プロジェクト構造</h2>\n<p>プロジェクト構造は現在のプロジェクトにほぼ似ていますが、Utils ディレクトリがなく、一部のツールは外部に記述されています。 typescript に詳しくないため、types ディレクトリは存在しません。</p>\n<p><img src="' +
        images.msp0struct +
        "\" alt=\"image-20240827200012949\"></p>\n<h2 id=\"prototype-extend\" tabindex=\"-1\">prototype　extend</h2>\n<p>Typescript を使用すると、最終的にtypeを便利に使えます。</p>\n<pre><code class=\"language-ts\">declare module &quot;vue/types/vue&quot; {\n  interface Vue {\n    $message:typeof Message;\n    $axios: typeof Axios;\n    $echarts: EChartsHelper;\n    $MessageBox:ElMessageBox;\n  }\n}\n//main.ts\nVue.config.productionTip = false\nVue.prototype.$axios = Axios\nVue.prototype.$echarts = EChartsHelper\nVue.prototype.$MessageBox = MessageBox\nObject.prototype[Symbol.iterator] = function * &lt;T&gt;(this:T){\n  for(let i in this){\n    yield {key:i,value:this[i]}\n  }\n}\n</code></pre>\n<h2 id=\"%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89\" tabindex=\"-1\">カスタムメソッド</h2>\n<p>現時点で作成されたHelperのほとんどは、馴染みさを増やすために使っております。</p>\n<pre><code class=\"language-ts\">class EChartsHelper{\n    private Mychart: EChartsType\n    \n    constructor(dom:HTMLElement|undefined|null,theme='lightGreen'){\n        if(dom){\n            this.Mychart = echarts.init(dom,theme)\n            this.Mychart.off('click')\n         }else{\n            throw new Error('echarts init failed')\n         }  \n    }\n    /**\n     * @type\n     * 普通合并，永远不会删除组件 */\n    updateMyChart(obj: object): void\n    /**\n     * @param notMerge 为true 则全部删除，默认false不写\n     */\n    updateMyChart(obj: object,notMerge:boolean): void\n    /**\n     * \n     * @param notMerge 默认false不需要传 \n     * @param replaceMerge 哪些组件需要替换更新——有就更新，没有就删除\n     */\n    updateMyChart(obj: object,{replaceMerge}: {replaceMerge: Array&lt;string&gt;|string}): void\n    updateMyChart(obj:object,s?:any):void {\n        if(s){\n            if(typeof s == 'boolean'){}\n            else{\n               if(s.replaceMerge &amp;&amp; (Array.isArray(s.replaceMerge)|| typeof s.replaceMerge=='string')){}\n               else{\n                   throw new Error('ECharts setOption params error')\n               }\n            }\n            this.Mychart.setOption(obj as echarts.EChartsCoreOption,s)\n        }\n        this.Mychart.setOption(obj as echarts.EChartsCoreOption)\n    }\n    // setOn(event: string,series='',F: Function){\n    //     this.Mychart.on(event,'series',()=&gt;{\n    //         F()\n    //     })\n    // }\n    setOn(event: string,F:Function): void\n    setOn(event: string,F: Function,series: string): void\n    setOn(event: string,F: Function,c?: any): void{\n        if(!c){\n            c = 'series'\n        }\n        this.Mychart.on(event,c,(param: object)=&gt;{\n                    F(param)\n                })\n    }\n    setLoading(){\n        this.Mychart.showLoading()\n    }\n    hideLoading(){\n        this.Mychart.hideLoading()\n    }\n    triggerAction(action: string, name: string){\n        this.Mychart.dispatchAction({type:action,name})\n    }\n    get chart(){\n        return this.Mychart\n    }\n\n    get width(){\n       return this.Mychart.getWidth()*0.8\n    }\n    resize(){\n        this.Mychart.resize()\n    }\n   dispose(){\n       this.Mychart.dispose()\n   }\n   static of(dom: HTMLElement|undefined|null,theme='lightGreen'){\n        return new EChartsHelper(dom,theme)\n    }\n\n}\n</code></pre>\n<pre><code class=\"language-ts\">class AxiosHelper{\n     private static axios:AxiosStatic = axios\n     static async getData(url: string): Promise&lt;any&gt;\n     static async getData(url: string,type: string): Promise&lt;any&gt;\n     static async getData(url: string,data:{[k: string]:any}): Promise&lt;any&gt;\n     static async getData(url: string,data:{[k: string]:any},type: string): Promise&lt;any&gt;\n     static async getData(url: string,b?:any,c?: string){\n         if(b){\n             if(typeof b == 'object'){\n                 if(c &amp;&amp; typeof c=='string'){\n                     return this.request(url,b,c as Method)\n                 }else{\n                     return this.request(url,b)\n                 }\n             }else{\n                 if(typeof b == 'string'){\n                     return this.requstUrl(url,b)\n                 }else{\n                    throw new Error('参数格式错误')\n                }        \n             }\n         }else{\n            //  b=&quot;POST&quot; \n             return  this.requstUrl(url)\n         }\n\n     }\n\n     static async request(url: string,data:{} = {},type: Method =&quot;post&quot; ){\n       return await this.axios({\n            url: url,\n            data: qs.stringify(data),\n            method:type\n         }).then(value=&gt;{\n             if(value.data){\n                 return value.data\n             }else{\n                 throw new Error(&quot;无数据&quot;+url);\n             }\n         },reason=&gt;{throw reason}).catch((e: Error)=&gt;{console.error(e)})\n         \n\n     }\n     static async requstUrl(url: string,b='POST'){\n        return await this.axios({\n            url: url,\n            method:b as Method\n         }).then(value=&gt;{\n             if(value.data){\n                 return value.data\n             }else{\n                 throw new Error(&quot;无数据&quot;);\n             }\n         },reason=&gt;{throw reason}).catch((e: Error)=&gt;{console.error(e)})\n     }\n     static get Axios(){\n         return this.axios\n     }\n\n     \n\n} \n</code></pre>\n<p>カルーセルページツール。書く前に長い間考えました。今はとても低く見えます。</p>\n<pre><code class=\"language-ts\">class Carousel{\n    /**\n     * 所有可选页面\n     */\n     private pageNames: string[]\n     /**\n      * 控制轮播开始与暂停\n      */\n     private canCarousel = true\n     /**\n      * 获取下一个轮播页面名\n      */\n     private nextPage: Generator&lt;string | void, void, unknown&gt; = this.getNextPage()\n     /**\n      * 每个页面停留时间\n      */\n     private interval:number;\n     constructor(config: typeof carouselConfig){\n        const {carouselInterval,loopIndex} = config\n        this.interval = carouselInterval\n        this.pageNames = loopIndex\n     }\n\n    private *getNextPage(){\n         const currentPage = getCookie('currentPageName')\n         /**\n          * \n          * 从循环的下一个页面开始\n          * */\n         let p =  this.pageNames\n         if(p.includes(currentPage)){\n            p = p.slice(p.indexOf(currentPage)+1)\n            p = p.length?p:this.pageNames   \n         }\n        let t = this.pages(p)\n        let res = t.next()\n        while(true){\n            if(res.done){\n                t = this.pages()\n                res = t.next()\n            }\n            yield res.value\n            res = t.next()\n        } \n    }\n     private *pages(pages = this.pageNames){\n        if(!pages.length)\n           yield ''\n        \n        for(let i of pages){\n            yield i\n        }\n     }\n     start(){\n       this.canCarousel = true\n       this.carousel() \n     }\n     // 主要逻辑其实只是这里\n     async carousel(){\n        const next = this.nextPage.next()\n        if(next.value &amp;&amp; store.getters.getLoginIdentity){\n            const path = getPathByPageName(next.value as string)\n            this.canCarousel &amp;&amp; Router.push(path).catch(e=&gt;{\n                Router.push({name:&quot;back&quot;})\n                setTimeout(()=&gt;{\n                    Router.replace(path)\n                },500)\n            })\n        }\n        await sleep(this.interval)\n        this.canCarousel &amp;&amp; this.carousel()\n     }\n\n     stopCarousel(){\n         this.canCarousel = false\n     }\n     static of(){\n         return new Carousel(carouselConfig)\n     }\n     setNextPage(){\n        this.nextPage = this.getNextPage()\n     }\n}\n</code></pre>\n<p>主に 2 つの問題があるようです。</p>\n<ol>\n<li>単機能の原則に違反します。</li>\n</ol>\n<p>​    これは明らかにカルーセルをルーティングするためのツールですが、そのほとんどは無限ループを実行しています。実際、主なロジックは再生と停止を制御することです。次のものに無制限にアクセスでき、個別に上げることができます。</p>\n<ol start=\"2\">\n<li>\n<p>きちんと止められない</p>\n<p>極端な場合、停止が呼び出されたとき、その時点ではスリープ状態であり、スリープが終了する前に再開しても実際には意味がありません。</p>\n</li>\n</ol>\n<h3 id=\"%E6%94%B9%E8%89%AF%E3%81%95%E3%82%8C%E3%81%9F%E3%82%AB%E3%83%AB%E3%83%BC%E3%82%BB%E3%83%AB\" tabindex=\"-1\">改良されたカルーセル</h3>\n<p>無限Loop</p>\n<pre><code class=\"language-ts\">type Item&lt;T&gt; = T extends Iterable&lt;infer R&gt;?R:never\nclass LoopIteratorData&lt;T extends Iterable&lt;TItem&gt;,TItem = Item&lt;T&gt;&gt;{\n\tprivate _generator: Generator&lt;TItem,TItem,any&gt;\n\tprivate _index = 0\n\tprivate _destroyed = false\n\tconstructor(private _data:T){\n\t\tthis.createGenerator()\n\t}\n\tprivate createGenerator(){\n\t\tthis._generator = LoopIteratorData.createGenerator(this._data)\n\t\tthis._index = 0\n\t}\n\tnext():{value:TItem,index:number}{\n\t\tif(this._destroyed){\n\t\t\tthrow new Error('loop is over')\n\t\t}\n\t\tconst value = this._generator.next()\n\t\tif(!value.done){\n\t\t\treturn {value:value.value,index:this._index++}\n\t\t}else{\n\t\t\tthis.createGenerator()\n            return this.next()\n\t\t}\n\t}\n\tdestory(){\n\t\ttry{\n\t\t\tthis._destroyed = true\n\t\t\tthis._generator.throw('手动停止')\n\t\t}catch(e){\n\t\t}\n\t}\n    //创建生成器直接挂在了类构造器上了\n    static createGenerator&lt;T extends Iterable&lt;TItem&gt;,TItem = Item&lt;T&gt;&gt;(data:T){\n\t\tfunction *g(){\n            for(let i of data){\n\t\t\t\tyield i\n\t\t\t}\n\t\t} \n\t\treturn g() as Generator&lt;TItem,TItem,any&gt;\n        \n\t}\n}\n</code></pre>\n<p>カルーセルメソッド。実は<code>_loopInstance</code>は  <code>interface ILoopInstance{ next():{value:TItem,index:number}}</code>をimplementさえすればいい</p>\n<pre><code class=\"language-ts\">interface ICarouselExecuteObject&lt;T extends Iterable&lt;TItem&gt;&gt;{\n    exec(value: {value:TItem,index:number}):void\n}\n\nclass Carousel&lt;T extends Iterable&lt;TItem&gt;&gt;{\n    private _timer: number\n    constructor(private _loopInstance: LoopIteratorData&lt;T&gt;,\n                private _executeInstance: ICarouselExecuteObject&lt;T&gt;,\n                private _interval = 5000\n                ){}\n    start(){\n        if(this.isLooping){\n            console.warn(&quot;is looping&quot;)\n            return\n        }\n        this.carouselIt()\n    }\n    stop(){\n        this._timer &amp;&amp; clearInterval(this._timer)\n        this._timer = null\n    }\n    private carouselIt(){\n        this._timer = setTimeout(()=&gt;{\n            this._executeInstance.exec(_loopInstance.next())\n            this.carouselIt()\n        },this._interval)\n    }\n    get isLooping(){\n        return !!this._timer\n    }\n    \n}\n</code></pre>\n<p>これは、単一関数の原則に準拠しているだけでなく、<code>implements ICarouselExecuteObject </code>を満足している限り、カルーセルで何をしたいかは関係ありません。こんな感じで、少なくとも今はまだかなり優雅な気分です。</p>\n<h2 id=\"%E5%85%B1%E9%80%9A%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\" tabindex=\"-1\">共通コンポーネント</h2>\n<h3 id=\"echarts%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\" tabindex=\"-1\">echartsコンポーネント</h3>\n<p>粒度が大きすぎる気がします。プロップにはタイプがなく、明らかに ts です。</p>\n<pre><code class=\"language-ts\">export default Vue.extend({\n    data(){\n        return {\n            myChart:null as null|EChartsHelper,\n        }\n    },\n    props:[&quot;custom&quot;,'dataset'],\n    created(){\n       this.initPie() \n    },\n    beforeDestroy(){\n        this.myChart?.dispose()\n        this.myChart = null\n    }\n    ,methods:{\n       initPie(){\n           if(!this.custom || !this.custom.title){\n               return\n           }\n           const div = document.getElementById(`${this.custom.title}`)\n          \n           if(!div){\n               return      \n           }\n            this.myChart = EChartsHelper.of(div)\n            this.dataset &amp;&amp; this.myChart.updateMyChart(this.dataset)\n            this.myChart.setOn('click',(params: {[k:string]:any})=&gt;{\n                 let index = params.seriesIndex as number|undefined     \n                 this.$emit('clickPie',this.custom.title,getType(index))\n               })\n           }\n           \n       }\n\n    },\n  \n    watch:{\n        dataset:{\n            handler(){         \n                this.myChart?.updateMyChart({dataset:{source:this.dataset},title})\n            }\n          }\n        },\n       async menuOpen(){ \n           const timer = setInterval(()=&gt;{\n               this.myChart?.resize()  \n            },1000)\n            setTimeout(() =&gt; {\n                clearInterval(timer)\n            }, 1000);      \n        }, \n    },\n    \n      computed:{\n        ...mapGetters({\n            menuOpen:&quot;menuOpen&quot;,\n        }),\n    \n    },\n})\n\n</code></pre>\n<h3 id=\"upload-excel%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88\" tabindex=\"-1\">upload excelンポーネント</h3>\n<p>ファイルの中身を読み込むのかはHooksなどを使うとコード量が減って読みやすくなるような気がします。</p>\n<pre><code class=\"language-ts\">&lt;template&gt;\n  &lt;div&gt;\n    &lt;input ref=&quot;excel-upload-input&quot; class=&quot;excel-upload-input&quot; type=&quot;file&quot; accept=&quot;.xlsx, .xls&quot; @change=&quot;handleClick&quot;&gt;\n     &lt;el-button :loading=&quot;loading&quot;  size=&quot;mini&quot; type=&quot;primary&quot; @click=&quot;handleUpload&quot;&gt;\n        选择\n      &lt;/el-button&gt;\n      &lt;el-button size=&quot;mini&quot; type=&quot;primary&quot; @click=&quot;uploadExcel&quot;&gt;上传&lt;/el-button&gt;\n      &lt;div class=&quot;myFile&quot;&gt;\n            &lt;div v-if=&quot;excelData.fileName&quot; class=&quot;fileName&quot;&gt;\n                {{excelData.fileName}} \n                &lt;span&gt;(数据无误,请点击上传)&lt;/span&gt;\n            &lt;/div&gt;\n            &lt;div v-else&gt;\n                未选择文件&lt;span&gt;(请选择上传文件)&lt;/span&gt;\n            &lt;/div&gt;\n      &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport XLSX from 'xlsx'\nexport default {\n  props: {\n     onUpload:Function\n    ,dataFormat:{\n        required:true,\n        default:[],\n        type:Array\n    }\n  },\n  data() {\n    return {\n      loading: false,\n      excelData: {\n        header: null,\n        results: null,\n        fileName:null\n      },\n      \n    }\n  },\n  methods: {\n    uploadExcel(){\n       this.onUpload &amp;&amp; this.onUpload(JSON.stringify(this.excelData.results))\n    },\n    generateData({ header, results }) {\n      this.excelData.header = header\n      results?.shift()\n      this.excelData.results = results\n    },\n    handleUpload() {\n      this.$refs['excel-upload-input'].click()\n    },\n    handleClick(e) {\n      const files = e.target.files\n      const rawFile = files[0] // only use files[0]\n      if (!rawFile) return\n      this.readerData(rawFile)\n    },\n    readerData(rawFile) {\n      const name = rawFile.name\n      this.loading = true\n      return new Promise((resolve, reject) =&gt; {\n        const reader = new FileReader()  \n        reader.onload = e =&gt; {  \n          const data = e.target.result\n          const workbook = XLSX.read(data, { type: 'array' })\n          const firstSheetName = workbook.SheetNames[0]\n          const worksheet = workbook.Sheets[firstSheetName]\n          const header = this.getHeaderRow(worksheet)\n          if(this.dataFormat &amp;&amp; this.dataFormat.length){\n              /*\n              *@param {[{prop:string,label: string}]} ar1\n               * @param {string[]} ar2\n               */\n              const checkFormat = (ar1 ,ar2)=&gt;{\n                  if(ar1.length!=ar2.length)\n                     return false\n                  for(let i of ar1){\n                      if(!ar2.includes(i.label)){\n                          return false\n                      }\n                  }\n                  return true\n              }\n              if(!checkFormat(this.dataFormat,header)){\n                  this.loading = false\n                  reject('上传格式有误')\n                  return\n              }\n\n          }\n          const results = XLSX.utils.sheet_to_json(worksheet,{header:this.dataFormat.map(v=&gt;v.prop)})\n          this.generateData({ header, results })\n          this.excelData.fileName = name\n          this.loading = false\n          resolve()\n        }\n        reader.readAsArrayBuffer(rawFile)\n      }).catch(e=&gt;{\n           this.$message({\n                      type:'warning',\n                      message:e\n           })\n      })\n    },\n    getHeaderRow(sheet) {\n      const headers = []\n      const range = XLSX.utils.decode_range(sheet['!ref'])\n      let C\n      const R = range.s.r\n      /* start in the first row */\n      for (C = range.s.c; C &lt;= range.e.c; ++C) { /* walk every column in the range */\n        const cell = sheet[XLSX.utils.encode_cell({ c: C, r: R })]\n        /* find the cell in the first row */\n        let hdr = 'UNKNOWN ' + C // &lt;-- replace with your desired default\n        if (cell &amp;&amp; cell.t) hdr = XLSX.utils.format_cell(cell)\n        headers.push(hdr)\n      }\n      return headers\n    },\n    isExcel(file) {\n      return /\\.(xlsx|xls|csv)$/.test(file.name)\n    }\n  }\n}\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"store\" tabindex=\"-1\">Store</h2>\n<p>モジュールがないとまだ非常に混んでて、URLみたいな一部は環境変数で処理できますので、Storeにある必要はないと思います。主な機能はユーザー情報を保存し、メニューが展開されたかどうかを記録することでechart のサイズを変更する。</p>\n<pre><code class=\"language-ts\">export default new Vuex.Store({\n  state: {\n    userName:null as null|string,\n    login:false,\n    frameLabels:null as null|Iterable&lt;{key:string,value:string|null|number}&gt;,\n    pageName:'S4大数据',\n    url:isOnline?onlineUrl:testUrl,\n\n    continue:true,\n    frameLabelsTimer:null as null|number,\n    countDownTimer:null as null|number,\n    menuOpen:true,\n    imgSrc:&quot;&quot;,\n    ...\n  },\n   getters:{...},\n   mutations:{...},\n   actions:{...}\n}\n</code></pre>\n<h2 id=\"route\" tabindex=\"-1\">Route</h2>\n<p>個人的にこのプロジェクトの最大の欠点は、ルートは設定されているが、メニューの内容は手動で設定する必要があること、それにハードコードだと思われています。当時、私はルートにmetaを付けてもいいのを知りませんでした。</p>\n<pre><code class=\"language-ts\">const menuName = ['一阶','二阶',...]\nconst menuRouter:{[k in number]:RawLocation} = {\n    0:{\n        name:'step1',params:{\n            pageName:'一阶'\n        }\n    },\n    1:{\n        name:&quot;step2&quot;,\n        params:{\n            pageName:'二阶'\n        }\n    \n    },\n  ...    \n]\n\n</code></pre>\n<pre><code class=\"language-vue\">&lt;el-menu-item-group&gt;\n      &lt;el-menu-item  v-for=&quot;(item,index) in menuName&quot; :key=&quot;index&quot; :index=&quot;getIndex(index)&quot; @click=&quot;turn2Page(index)&quot;\n      class=&quot;S4Item&quot;&gt;{{item}}&lt;/el-menu-item&gt;\n&lt;/el-menu-item-group&gt;\n</code></pre>\n<h2 id=\"%E3%81%BE%E3%81%A8%E3%82%81\" tabindex=\"-1\">まとめ</h2>\n<p>この期間に、複雑な問題を解決する能力を身につけてきたように感じますが、いくつかの基本的なプログラミングの考え方や原則については十分に学習していません。つまり、基礎思想とかが十分ではないため、出てくるコードはこのとおりです。あまりにも読みにくくて、保守しにくい。そのため、Vue の原則、設計原則、アルゴリズムについては後ほど補足していきます。</p>\n",
    },
  },
  3: {
    code: 200,
    data: {
      id: 3,
      title: "wechat mini app",
      description: "微信小程序レコード",
      scanNumber: "1",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "wechat",
          name: "wechat",
          tag: "h1",
          children: [
            { anchor: "%E8%AA%8D%E8%A8%BC", name: "認証", tag: "h2", children: [] },
            {
              anchor: "mvvm%E6%93%8D%E4%BD%9C",
              name: "MVVM操作",
              tag: "h2",
              children: [
                { anchor: "%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8", name: "基本使用", tag: "h3", children: [] },
                { anchor: "%E9%80%9A%E4%BF%A1", name: "通信", tag: "h3", children: [] },
              ],
            },
          ],
        },
      ],
      htmlContent:
        "<h1 id=\"wechat\" tabindex=\"-1\">wechat</h1>\n<h2 id=\"%E8%AA%8D%E8%A8%BC\" tabindex=\"-1\">認証</h2>\n<p>フロントエンド</p>\n<pre><code class=\"language-ts\">// app.ts\n enum LoginStatus{\n\tlogining = 'logining',\n\tlogined = 'logined',\n\tunlogin = 'unlogin'\n }\n\n async onShow(){\n   let pages = getCurrentPages();\n   //进入小程序\n   if(pages.length == 0) {\n\t   wx.setStorageSync('loginStatus',LoginStatus.logining)\n       const res = await checkIdentity()\n       if(!res){\n         wx.showToast({\n           title: '身份认证失败',\n         })\n\t\t  wx.setStorageSync('loginStatus',LoginStatus.unlogin)\n       }else{ \n\t\t wx.setStorageSync('loginStatus',LoginStatus.logined)\n         wx.setStorageSync('userInfo',{userid:res.id,token:res.token,factory:res.factory,access:res.access})\n         wx.showToast({\n           title: `${res.id}\n              \\r\\nversion:${wx.getAccountInfoSync().miniProgram.version}` ,\n         })\n       }\n    }\n}\n\n//utils.ts\n/**\n * 返回工号token,根据企业微信还是手机微信统一返回固定格式\n */\nasync function checkIdentity(){\n  const {environment} = await getEnvironment() as {environment:string}  \n  if(environment &amp;&amp; environment=='wxwork'){\n      return qyLogin() \n  }else{\n      return wxLogin()\n  }\n}\n\n/**\n * 微信认证,就是拿code换id\n */\nasync function wxLogin(){\n  const code = await new Promise(resolve=&gt;{\n      wx.login({\n        success:res=&gt;{\n          resolve(res.code)\n        },\n      })\n  })\n  //自己封装了一下wx.request(),以前写的，感觉写的不是很好\n  return requestData(`${loginUrl}login`,{code},&quot;POST&quot;,{\n    'content-type': 'application/x-www-form-urlencoded'\n  },setSessionId) as Promise&lt;IUserInfo&gt;\n}\n</code></pre>\n<p>バックエンドもコードに基づいて ID をもらいます。トークンを生成して返す。</p>\n<pre><code class=\"language-c#\">        /// &lt;summary&gt;\n        /// 通过openid认证\n        /// &lt;/summary&gt;\n        /// &lt;returns&gt;&lt;/returns&gt;\n        public static string auth2(string code)\n        {\n            string res = string.Empty;\n            string openid = GetOpenid(code);\n            string url = string.Format(@&quot;https://qyapi.weixin.qq.com/cgi-bin/user/convert_to_userid?access_token={0}&quot;, GetAccessToken());\n            string responseText = HttpHelper.Instance.post(url, &quot;{\\&quot;openid\\&quot;:\\&quot;&quot; + openid + &quot;\\&quot;}&quot;);\n            WeChatUserInfoFromOpenId codeEn = JsonHelper.GetEntity&lt;WeChatUserInfoFromOpenId&gt;(responseText);\n            if (!string.IsNullOrEmpty(codeEn.errmsg) &amp;&amp; codeEn.errmsg.Equals(&quot;ok&quot;))\n            {\n                res = codeEn.userid;\n            }\n            return res;\n        }\n</code></pre>\n<p>その時に書いたのは、40秒以内に検証が通るかどうかを判定するというものでしたが、今はこの無限ループよりもイベントバスなどを使ったほうがずっと良いのではないかと感じています。</p>\n<pre><code class=\"language-ts\">  async onShow(){\n      wx.showLoading({title:'加载中'})\n      const result = await isIdentityCheckFinished()\n      if(!result){\n        wx.redirectTo({\n          'url':'../errorPage/index',\n        })\n        return\n      }\n      wx.hideLoading()\n      this.init()\n  }\n\n\n/**\n * 认证是否执行完成\n */\nconst isIdentityCheckFinished= async (count = 20)=&gt;{\n  while(count--){\n\tconst status = wx.getStorageSync('loginStatus')\n\tif(status===LoginStatus.logining){\n       await sleep(2)\n\t}else{\n\t\treturn wx.getStorageSync('loginStatus') === LoginStatus.logined\n\t}\n  }\n  return false\n}\n</code></pre>\n<h2 id=\"mvvm%E6%93%8D%E4%BD%9C\" tabindex=\"-1\">MVVM操作</h2>\n<h3 id=\"%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\" tabindex=\"-1\">基本使用</h3>\n<p>これは vue と比較できますが、composition api はありません。\n以前書いたVue のテンプレートとデータを生成する方法を直接使用でき、テンプレートの構文も非常に似ていました。ラベルはちょっと違いだけ。</p>\n<pre><code class=\"language-html\">   &lt;view class=&quot;inspectionItem&quot; wx:for=&quot;{{templateData}}&quot; wx:key=&quot;prop&quot;&gt; \n      &lt;block wx:if=&quot;{{item.prop=='remark'}}&quot;&gt;\n        &lt;wux-cell wx:if=&quot;{{showRemark}}&quot;&gt;\n          &lt;view  class=&quot;InspectionItemLabel&quot; &gt;\n              {{item.label}}\n          &lt;/view&gt;  \n          &lt;wux-textarea  bind:change='onChange' data-prop=&quot;{{item.prop}}&quot; rows='3' placeholder='请输入' placeholder-style='font-weight:10'&gt;&lt;/wux-textarea&gt;\n        &lt;/wux-cell&gt; \n      &lt;/block&gt;\n      &lt;block wx:elif=&quot;{{item.prop=='haveProblem'}}&quot;&gt;\n        &lt;wux-picker options=&quot;{{['是','否']}}&quot; value=&quot;{{ formData[item.prop] }}&quot;  bind:confirm=&quot;onConfirm&quot;\n        data-prop=&quot;{{item.prop}}&quot;\n      &gt;\n        &lt;wux-cell  is-link extra=&quot;{{ formData[item.prop][0] }}&quot;&gt;\n          &lt;view class=&quot;InspectionItemLabel&quot; &gt;\n              {{item.label}}\n          &lt;/view&gt;  \n        &lt;/wux-cell&gt;\n      &lt;/wux-picker&gt;\n      &lt;/block&gt; \n   &lt;/view&gt;\n   ……\n   &lt;wux-button block type=&quot;balanced&quot; wux-class='myButton' bind:click='submit'\n      &gt;&lt;wux-icon type=&quot;ios-save&quot; size=&quot;16&quot; /&gt; 提交&lt;/wux-button\n    &gt;\n</code></pre>\n<p>唯一の違いは、reactivityがなく、React のように手動で設定する必要があることです。</p>\n<pre><code class=\"language-ts\">Page({\n   data:{\n     formData,\n     templateData,\n     ……\n   },\n   onLoad(){\n\t  //调用一些后台api\n   },\n   //监听input的change事件\n   onChange(){\n\t  ···\n      setFormValue()\n   },\n    setFormValue(prop: Insection,value: any){\n      this.setData({\n        [`formData.${prop}`]:value\n      })\n   },\n   submit(){\n\t  validate(this.data.formData) &amp;&amp; submitApi(this.data.formData)\n   }\n\n})\n</code></pre>\n<h3 id=\"%E9%80%9A%E4%BF%A1\" tabindex=\"-1\">通信</h3>\n<p>親子コンポーネントはイベントを通じて使用できます。開いているページにも表示されるコミュニケーションを開くには、通常 <code>eventChannel</code> を使用します。 Vue を使用した経験があって、これは Vue オブザーバー モードに似たパブリッシュ/サブスクライブ モードである<code>event bus</code>であることがわかります。</p>\n<pre><code class=\"language-ts\"> wx.navigateTo({\n             url:'../resolve/index',\n             events:{\n               research:()=&gt;{\n                this.getList()\n              },\n             },\n            success:(res)=&gt;{\n                res.eventChannel.emit('navSuccess',item,this.data.searchCondition)\n            }\n})\n\nonLoad(){\n\tconst eventChannel = this.getOpenerEventChannel();\n\tthis.eventChannel.on('navSuccess',(condition:Record&lt;string,string&gt;)=&gt;{\n\t\t\t\tthis.setData({\n\t\t\t\t\tcondition\n\t\t\t\t})\n\t\t\t\t\n\t})\n}\n\n</code></pre>\n",
    },
  },
  2: {
    code: 200,
    data: {
      id: 2,
      title: "human management",
      description: "簡単な人员管理システム",
      scanNumber: "1",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86",
          name: "人员管理",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            { anchor: "%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89", name: "バックエンド", tag: "h2", children: [] },
            { anchor: "%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89", name: "フロントエンド", tag: "h2", children: [] },
            { anchor: "%E3%81%BE%E3%81%A8%E3%82%81", name: "まとめ", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent: `<h1 id=\"%E4%BA%BA%E5%91%98%E7%AE%A1%E7%90%86\" tabindex=\"-1\">人员管理</h1>\n<h2 id=\"%E6%95%88%E6%9E%9C\" tabindex=\"-1\">效果</h2>\n<p><img src=\"${images.human}\" alt=\"human\"></p>\n<h2 id=\"%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89\" tabindex=\"-1\">バックエンド</h2>\n<p>社内は.Net Framework4.0を使ってる人が多い\nRoute</p>\n<pre><code class=\"language-C#\">//  Route 对应 handler  xxx.ashx\n public class basicInfo : IHttpHandler{\n basicInfo_BLL bInfo = new basicInfo_BLL();\n public void ProcessRequest(HttpContext context)\n        {\n\t\t\t//CORS\n            context.Response.ContentType = &quot;text/plain&quot;;\n            context.Response.AddHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n            context.Response.AddHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, PUT, DELETE, OPTIONS&quot;);\n            context.Response.AddHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type&quot;);\n            string action = context.Request[&quot;action&quot;];\n\t\t\t//路由还不是Rest风格\n            switch (action)\n            {\n                case &quot;getTable&quot;:\n                    getTable(context);\n                    break;\n                // ...\n\n            }\n}\nprivate void getTable(HttpContext context){\n            //自己写的Action,统一处理错误\n            Try(() =&gt;\n            {\n                context.Response.Write(bInfo.search(context.Request[&quot;dept&quot;], context.Request[&quot;id&quot;],...);\n            });\n}\n\n}\n\n\n</code></pre>\n<p>BLL 略</p>\n<pre><code class=\"language-C#\">    public class basicInfo_BLL\n    {\n        basicInfo_DAL bInfo = new basicInfo_DAL();\n        public string search(string dept,string id,string name,string line,string position)\n        {\n            string condition = getCondition(dept, &quot;dept&quot;) + getCondition(id, &quot;id&quot;) + getCondition(name, &quot;cName&quot;) + getCondition(line, &quot;line&quot;) + getCondition(position,&quot;position&quot;);\n            return bInfo.search(condition);\n \n        }\n\t\t...\n\t}\n</code></pre>\n<p>DAL は主に直接 SQL Sentence + Linq</p>\n<pre><code class=\"language-ts\">  public List&lt;basicData_Model&gt; SearchList(string condition){\n\n     string factory = &quot;MSM0&quot;;\n            string cmd2 = string.Format(@&quot;select * from\n(\n     select company,dept,id,cName,eName,line,position,gender,enterDate,leaveDate,homeAddress,telephone,wechat,email,emergencyContact,station,responseRegion,factory,region,rownumber,EMSIdentity \n\t from HM_BasicInfo where isValid ='Y' and factory='{1}' {0}\n) A\nleft join\n(\n\t select value2 ,value6 shiftAB,term hmProperty,rowNum EMSRowNum,value1,value4 from EMS_Maintain \n\t\twhere system_type='打卡看板' and value4 = 'MSM0'  and term in ('领班','出席信息','组长','工程师') and validYN = 'Y'\n) B on id = value2 and  factory = value4 and region = value1 and EMSIdentity=hmProperty order by rownumber desc&quot;, condition, factory);\n\n            List&lt;basicData_Model&gt; list = SqlHelper.GetList&lt;basicData_Model&gt;(cmd2).Select(x =&gt;\n            {\n                x.emergencyContact = x.emergencyContact.Trim();\n                x.leaveDate = System.Text.RegularExpressions.Regex.IsMatch(x.leaveDate, @&quot;1900.*&quot;) ? &quot;&quot; : DateTime.Parse(x.leaveDate).ToString(&quot;yyyy-MM-dd&quot;);\n\n                x.enterDate = DateTime.Parse(x.enterDate).ToString(&quot;yyyy-MM-dd&quot;);\n                return x;\n            }).ToList();\n            return list;\n        }\n</code></pre>\n<h2 id=\"%E3%83%95%E3%83%AD%E3%83%B3%E3%83%88%E3%82%A8%E3%83%B3%E3%83%89\" tabindex=\"-1\">フロントエンド</h2>\n<p>徐々に現在のスタイルに近づきつつありますが、まだまだです。この初期化は jQuery に戻ったような感じで、モジュール性のメリットがまったく理解できません。</p>\n<pre><code class=\"language-ts\">     init(){\n           let labels =['公司别','部门','工号','姓名','英文名','线别','职务','性别',\n           '入职日','离职日期','户籍地址','电话','微信','邮箱','紧急联络人','班别','人员属性','设备别','负责区域(线体)','厂别','车间']\n           let prop = ['company','dept','id','cName','eName','line','position','gender','enterDate',\n           'leaveDate','homeAddress','telephone','wechat','email','emergencyContact','shiftAB','hmProperty','station','responseRegion','factory','region']\n           let table = {\n                label:[],\n                height:window.innerHeight*0.75,\n                data:[]\n           }\n           let widthArr = {\n               'company':'70px',\n               'line':'70px',\n               'gender':'50px',\n               'shiftAB':'50px',\n               'station':'200px',\n               'responseRegion':'200px',\n               'homeAddress':'180px'\n           }\n           for(let i = 0;i&lt;labels.length;i++){\n              table.label.push({label:labels[i],prop:prop[i],width:widthArr[prop[i]]})\n           }\n           this.tableData = table   \n           this.paginationData = {\n               sizes : [10,15,20,30],\n               size:20,\n               total:null,\n               currentPage:1\n           }\n           Promise.resolve().then(()=&gt;{\n               let array = ['homeAddress','telephone','wechat','email','emergencyContact','station','responseRegion']\n               this.editableData = array\n               this.testInput = {\n                    email:x=&gt; /^([a-zA-Z]|[0-9])(\\w|\\-)+@[a-zA-Z0-9]+\\.([a-zA-Z]{2,4})$/.test(x),\n                    telephone:x=&gt;/^1\\d{10}$/.test(x),\n                    wechat:x=&gt;/^1\\d{10}$/.test(x),\n                    emergencyContact:x=&gt;/^1[3|4|5|8][0-9]\\d{4,8}$/.test(x),\n                    homeAddress:x=&gt;/[\\u4e00-\\u9fa5]+/.test(x),\n               }\n\n           }).then(()=&gt;{\n               this.getSelectInfo()\n           })\n           \n\n        },\n</code></pre>\n<p>もちろん、私はいくつかの共有メソッドを作成しようと試み始めましたが、でもまだまだです。それに依然として CommonJ のようにインポートされています。もちろん、webpack は気にしませんけど。</p>\n<pre><code class=\"language-ts\">async function getData(url,param={},type='post'){\n    let axios = require('axios')\n    function PostData(){\n        let qs = require('qs')\n        return  qs.stringify(param,{ indices: false })\n    }\n   return axios[type](url,type===&quot;post&quot;?PostData():{params:param}).then(value=&gt;value.data,reason=&gt;{console.error(reason); throw reason}).catch((e)=&gt;{})\n}\n\nasync function excelOut(name='excel',header=[],series=[]){\n    const ExportJsonExcel = require(&quot;js-export-excel&quot;);\n    let option = {\n        fileName:name,\n        datas:[{\n            sheetHeader:header,\n            // sheetName: &quot;sheet&quot;,\n            sheetData:series\n         }]\n    }\n    setTimeout(() =&gt; {\n        let toExcel = new ExportJsonExcel(option); //new\n        toExcel.saveExcel();\n    }, 0); \n}\n</code></pre>\n<p>データ管理は混んでて、明らかにデータは親コンポーネントにある方がいいですね。 formData か tableData かは簡単に貰えない。</p>\n<pre><code class=\"language-ts\">&lt;template&gt;\n    &lt;div&gt;\n        &lt;Selects ref=&quot;Inputs&quot; @updateTable=&quot;updateTable&quot; @saveData=&quot;saveData&quot; @excelOut=&quot;excelOut&quot; @addItem=&quot;addItem&quot; /&gt;\n        &lt;Table ref=&quot;Table&quot; @rowClick=&quot;updateInputs&quot; style=&quot;margin:1.5% 0&quot;/&gt;     \n    &lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n    components:{\n        Selects:()=&gt;import('@/components/basicInfo/selects'),\n        Table:()=&gt;import('@/components/basicInfo/basicInfoTB')\n    },\n    methods:{\n        \n        updateTable(value){},\n        updateInputs(row){\n             this.$refs.Inputs.setInputValue(row)\n        },\n        saveData(){\n            this.$refs.Table.saveData()\n        },\n        excelOut(){\n            this.$refs.Table.excelOut()\n        },\n        addItem(row){\n            this.$refs.Table.addItem(row)\n        },\n    }\n}\n</code></pre>\n<h2 id=\"%E3%81%BE%E3%81%A8%E3%82%81\" tabindex=\"-1\">まとめ</h2>\n<p>現時点では、Vue についてある程度の理解があり、特定の機能を実装することもできるはずですが、モジュールの考え方とコンポーネント間の関係がまだ非常に不足しています。全体として、非常に混乱しており、美しさに欠けています。</p>\n`,
    },
  },
  1: {
    code: 200,
    data: {
      id: 1,
      title: "初めてのVueページ",
      description: "Vue を使用して作成された最初のかんばんボード",
      scanNumber: "2",
      commentNumber: "0",
      createDate: "2024-09-23",
      toc: [
        {
          anchor: "%E5%88%9D%E3%82%81%E3%81%A6%E3%81%AEvue%E3%83%9A%E3%83%BC%E3%82%B8",
          name: "初めてのVueページ",
          tag: "h1",
          children: [
            { anchor: "%E6%95%88%E6%9E%9C", name: "效果", tag: "h2", children: [] },
            { anchor: "template", name: "template", tag: "h2", children: [] },
            {
              anchor: "options",
              name: "options",
              tag: "h2",
              children: [
                { anchor: "data", name: "data", tag: "h3", children: [] },
                { anchor: "method", name: "method", tag: "h3", children: [] },
                { anchor: "computed", name: "computed", tag: "h3", children: [] },
              ],
            },
            { anchor: "%E3%81%BE%E3%81%A8%E3%82%81", name: "まとめ", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent: `<h1 id="%E5%88%9D%E3%82%81%E3%81%A6%E3%81%AEvue%E3%83%9A%E3%83%BC%E3%82%B8" tabindex="-1">初めてのVueページ</h1>\n<h2 id="%E6%95%88%E6%9E%9C" tabindex="-1">效果</h2>\n<p><img src="${images.firstVue}" alt="firstVue"></p>\n<h2 id="template" tabindex="-1">template</h2>\n<p>hard codeで書かれたことが多すぎて、computed にパラメータを渡すのもあまり良くなくて、 styleじゃなくてclassに切り替えた方が快適かも、table-columnの中のv-if多すぎ……</p>\n<pre><code class="language-ts"> &lt;el-table\n      ref=&quot;lightTable&quot;\n      tooltip-effect=&quot;dark&quot;\n      style=&quot;width: 100%&quot;\n      :height=&quot;tableHeight&quot;\n      border\n      :data=&quot;tableData&quot;\n      @select=&quot;hide&quot;\n      @cell-mouse-enter=&quot;getMSG&quot;\n      :header-cell-class-name=&quot;cellClass&quot;\n    &gt;\n      &lt;el-table-column type=&quot;selection&quot; align=&quot;center&quot;&gt; &lt;/el-table-column&gt;\n\n      &lt;el-table-column label=&quot;线体&quot; align=&quot;center&quot; prop=&quot;line&quot;&gt;\n      &lt;/el-table-column&gt;\n      &lt;el-table-column\n        v-for=&quot;i in stations&quot;\n        :key=&quot;i&quot;\n        :label=&quot;i&quot;\n        align=&quot;center&quot;\n        :prop=&quot;i&quot;\n      &gt;\n        &lt;template slot-scope=&quot;scope&quot;&gt;\n          &lt;div\n            v-if=&quot;scope.row[scope.column.property] === \'bgcRunning\'&quot;\n            @click=&quot;turnTOWeb&quot;\n            :style=&quot;bgcComputed(\'bgcRunning\')&quot;\n          &gt;\n            &amp;emsp;\n          &lt;/div&gt;\n          &lt;div\n            v-else-if=&quot;scope.row[scope.column.property] == \'bgcWaitRepair\'&quot;\n            :style=&quot;bgcComputed(\'bgcWaitRepair\')&quot;\n            @click=&quot;turnTOWeb&quot;\n          &gt;\n            &amp;emsp;\n          &lt;/div&gt;\n\t\t//   ...\n\n        &lt;/template&gt;\n      &lt;/el-table-column&gt;\n    &lt;/el-table&gt;\n</code></pre>\n<h2 id="options" tabindex="-1">options</h2>\n<h3 id="data" tabindex="-1">data</h3>\n<p>物が多すぎてごちゃごちゃしてます。データにスタイル設定を含める必要はありません。</p>\n<pre><code class="language-ts">  data(){\n\treturn {\n\t\t    tableData: [],\n\t\t\tstations: [], //列\n\t\t\tlines: [],    //行\n\t\t\tdisLine: [],  //只显示被勾选的行\n\t\t\ttableHeight: &quot;1000px&quot;,\n\t\t\ttimer1: null,  //短轮训timer\n\t\t\ttimer2: null,\n\t\t\t/**\n\t\t\t * @type {\n\t\t\t *     {\n\t\t\t *        [line,statin]: value\n\t\t\t *     }\n\t\t\t * }\n\t\t\t */\n\t\t\tBoardInfo: &quot;&quot;,  //存放灯号信息,明明是个对象 \n\t\t\tbgcRunning: [{ &quot;background-color&quot;: &quot;#00B050&quot; }], //正常运行的特殊颜色，下同\n\t\t\tbgc: [\n\t\t\t\t//通用属性\n\t\t\t\t{ &quot;border-radius&quot;: &quot;50%&quot; },\n\t\t\t\t{ width: &quot;20px&quot; },\n\t\t\t\t{ height: &quot;20px&quot; },\n\t\t\t\t{ &quot;margin-left&quot;: &quot;50%&quot; },\n\t\t\t\t{ transform: &quot;translateX(-50%)&quot; },\n\t\t\t],\n\t\t\tbgc5MinsUnRepair: [{ &quot;background-color&quot;: &quot;red&quot; }],\n\t\t\tbgc5MinsRepairing: [{ &quot;background-color&quot;: &quot;#FF9900&quot; }],\n\t\t\tbgcGrayFlash: [{ &quot;background-color&quot;: &quot;gray&quot; }],\n\t\t\tbgcBlueFlash: [{ &quot;background-color&quot;: &quot;#0000FF&quot; }],\n\t\t\tbgcWaitRepair: [{ &quot;background-color&quot;: &quot;red&quot; }],\n\t\t\tbgcNoEquipment: [{ &quot;background-color&quot;: &quot;white&quot; }],\n\t\t\tbgcUnUse: [{ &quot;background-color&quot;: &quot;#A6A6A6&quot; }],\n\t\t\tbgcBlue: [{ &quot;background-color&quot;: &quot;#0000FF&quot; }],\n\t\t\tbgcRepairing: [{ &quot;background-color&quot;: &quot;#FF9900&quot; }],\n\n\t\t\tbgcContrl: true, //控制闪烁\n\t}\n  }\n</code></pre>\n<h3 id="method" tabindex="-1">method</h3>\n<pre><code class="language-ts">//Boardinfo=&gt;tableData\n\nmethods:{\n\t//太可怕了，居然会操作字符串,而且需要分if else吗\nDisplay() {\n      //显示控制，生成表格对应的json\n      if (this.disLine.length === 0) {\n        //全部显示\n        var Lines = this.lines;\n        var tboby = &quot;&quot;;\n        var Boardinfo = this.BoardInfo;\n        var Station = this.stations;\n        for (var i = 0; i &lt; Lines.length; i++) {\n          if (i != 0) {\n            tboby += \'{&quot;line&quot;:&quot;\' + Lines[i] + \'&quot;,\';\n          } else {\n            tboby += \'[{&quot;line&quot;:&quot;\' + Lines[i] + \'&quot;,\';\n          }\n\n          for (var j = 0; j &lt; Station.length; j++) {\n            var station = Station[j];\n            var bgc = &quot;&quot;;\n            //判断JSON Array中是否包含value2=line value3=station。如果有的话，那么就取当前JSON中的值\n            var JsonKey = Lines[i] + &quot;,&quot; + station;\n            if (this.isHasAttr(Boardinfo, JsonKey)) {\n              switch (Boardinfo[JsonKey]) {\n                case &quot;1&quot;:\n                  bgc = &quot;bgcRunning&quot;;\n                  break;\n                case &quot;2&quot;:\n                  bgc = &quot;bgcWaitRepair&quot;;\n                  break;\n                case &quot;3&quot;:\n                  bgc = &quot;bgc5MinsUnRepair&quot;;\n                  break;\n                case &quot;4&quot;:\n                  bgc = &quot;bgcRepairing&quot;;\n                  break;\n                case &quot;5&quot;:\n                  bgc = &quot;bgc5MinsRepairing&quot;;\n                  break;\n                case &quot;6&quot;:\n                  bgc = &quot;bgcUnUse&quot;; //bgcNoEquipment\n                  break;\n                case &quot;7&quot;:\n                  bgc = &quot;bgcGrayFlash&quot;;\n                  break;\n                case &quot;8&quot;:\n                  bgc = &quot;bgcBlue&quot;;\n                  break;\n                case &quot;9&quot;:\n                  bgc = &quot;bgcBlueFlash&quot;;\n                  break;\n              }\n            }\n            if (j != Station.length - 1) {\n              tboby += \'&quot;\' + station + \'&quot;:\' + \'&quot;\' + bgc + \'&quot;,\';\n            } else {\n              tboby += \'&quot;\' + station + \'&quot;:\' + \'&quot;\' + bgc + \'&quot;\';\n            }\n          }\n          if (i != Lines.length - 1) {\n            tboby += &quot;},&quot;;\n          } else {\n            tboby += &quot;}]&quot;;\n          }\n        }\n        this.tableData = JSON.parse(tboby);\n      } else {\n        var Lines = this.disLine;\n        var tboby = &quot;&quot;;\n        var Boardinfo = this.BoardInfo;\n        var Station = this.stations;\n        for (var i = 0; i &lt; Lines.length; i++) {\n          if (i != 0) {\n            tboby += \'{&quot;line&quot;:&quot;\' + Lines[i] + \'&quot;,\';\n          } else {\n            tboby += \'[{&quot;line&quot;:&quot;\' + Lines[i] + \'&quot;,\';\n          }\n        //   ……\n        this.tableData = JSON.parse(tboby);\n      }\n    },\n\t //通过时间间隔改变控制属性，结合computed中 bgcComputed达到闪烁目的\n\t bgcControl() {\n      this.bgcContrl = !this.bgcContrl;\n    },\n}\n</code></pre>\n<h3 id="computed" tabindex="-1">computed</h3>\n<pre><code class="language-ts">  computed: {\n    bgcComputed() {\n      return function (x) {\n        var BGC = [];\n        switch (x) {\n          case &quot;bgcRunning&quot;:\n            BGC = this.bgcRunning;\n            return this.bgc.concat(BGC);\n          // break;\n          case &quot;bgcWaitRepair&quot;:\n            BGC = this.bgcWaitRepair;\n            return this.bgc.concat(BGC);\n          // break;\n          case &quot;bgc5MinsUnRepair&quot;:\n            BGC = this.bgc5MinsUnRepair;\n            break;\n          case &quot;bgcRepairing&quot;:\n            BGC = this.bgcRepairing;\n            // break;\n            return this.bgc.concat(BGC);\n          case &quot;bgc5MinsRepairing&quot;:\n            BGC = this.bgc5MinsRepairing;\n            break;\n          case &quot;bgcUnUse&quot;:\n            BGC = this.bgcUnUse;\n            // break;\n            return this.bgc.concat(BGC);\n          case &quot;bgcGrayFlash&quot;:\n            BGC = this.bgcGrayFlash;\n            break;\n          case &quot;bgcBlue&quot;:\n            BGC = this.bgcBlue;\n            return this.bgc.concat(BGC);\n          // break;\n          case &quot;bgcBlueFlash&quot;:\n            BGC = this.bgcBlueFlash;\n            break;\n        }\n        var res = this.bgcContrl ? this.bgc.concat(BGC) : this.bgc;\n        return res;\n      };\n    },\n  },\n</code></pre>\n<h2 id="%E3%81%BE%E3%81%A8%E3%82%81" tabindex="-1">まとめ</h2>\n<p>今からして見れば、このページは難しくないようです。しかし、初心者、特に ES6 や CSS に慣れていない人にとっては、まだ少し難しいです。</p>\n<p>今これを書くとしたら、すべてのtableのデータはcomputedで制御することになります。</p>\n<pre><code class="language-ts">  data(){\n\treturn {\n\t\t//获取行列直接计算出全部的数据\n\t\ttableData:[],\n\t\tdisplayLines:[]\n\t}\n  },\n  methods:{\n\t setTableData(){\n\t\t const res = [] \n\t\t for(let i of Object.keys(BoardInfo)){\n\t\t\tconst [line,station] = i.split(&quot;,&quot;)\n\t\t\tres.push({line,station,value:BoardInfo[i]})\n\t\t }\n\t\t this.tableData = res\n\t }\n  },\n  computed:{\n\tdisplayTableData(){\n        return this.tableData.filter(x=&gt;displayLines.includes(x.line))\n\t}\n  }\n\n</code></pre>\n<p>ちらつき効果は明白で、単純なアニメーションを使用して完成させることができます。これを制御するために js を使用する必要はありません。</p>\n<pre><code class="language-less">@bgcWaitRepair: red;\n.bgc{\n\t&amp;.bgcWaitRepair{\n\t\tbackground:@bgcWaitRepair;\n\t\tanimation: flicker .3s infinite;\n\t}\n}\n@keyframes flicker {\n\t0%{\n\t\topacity:1;\n\t}\n\t50%{\n\t\topacity:0;\n\t}\n\t100%{\n\t\topacity:1;\n\t}\n};\n</code></pre>\n`,
    },
  },
} as unknown as Record<any, IResponse<IDetailArticle>>
