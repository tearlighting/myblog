import { IArticles, IBlogCategory, ICommentItem, IDetailArticle } from "blog"

export const blogtype = {
  code: 200,
  data: [
    { id: 62, name: "HTML", articleCount: 0, order: 1 },
    { id: 64, name: "JavaScript", articleCount: 1, order: 2 },
    { id: 65, name: "CSS", articleCount: 1, order: 3 },
    { id: 66, name: "TypeScript", articleCount: 0, order: 4 },
    { id: 63, name: "Node", articleCount: 1, order: 5 },
    { id: 67, name: "Webpack", articleCount: 1, order: 6 },
    { id: 68, name: "Vue", articleCount: 0, order: 7 },
    { id: 69, name: "React", articleCount: 0, order: 8 },
    { id: 70, name: "Algorithm", articleCount: 0, order: 9 },
    { id: 71, name: "Design Pattern", articleCount: 0, order: 10 },
    { id: 72, name: "Browser", articleCount: 0, order: 11 },
    { id: 73, name: "Network", articleCount: 1, order: 12 },
    { id: 74, name: "NPM", articleCount: 1, order: 13 },
    { id: 75, name: "Others", articleCount: 0, order: 14 },
  ],
} as unknown as IResponse<IBlogCategory[]>

export const blogs4JP = {
  code: 200,
  data: {
    total: 6,
    rows: [
      {
        thumb: require("@/assets/Node.png"),
        id: 2,
        title: "NodeJs勉強",
        description: "常に懸念しているエンジニアリングの問題は、ノードを学習することでのみ理解できます。従来のバックエンドの経験とフロントエンドの経験がある人にとっては、難しいことではありません。",
        scanNumber: "4",
        commentNumber: "4",
        createDate: "2024-09-16",

        toc: [
          {
            anchor: "node",
            name: "node",
            tag: "h1",
            children: [
              {
                anchor: "%E6%A6%82%E8%A6%81",
                name: "概要",
                tag: "h2",
                children: [
                  { anchor: "what's-node", name: "what's node", tag: "h3", children: [] },
                  { anchor: "%E3%81%AA%E3%81%9C%E3%83%8E%E3%83%BC%E3%83%89%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E3%81%AE%E3%81%8B", name: "なぜノードが必要なのか", tag: "h3", children: [] },
                  { anchor: "%E7%89%B9%E5%BE%B4", name: "特徴", tag: "h3", children: [] },
                ],
              },
              { anchor: "global", name: "global", tag: "h2", children: [] },
              {
                anchor: "%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E5%8C%96-commonjs",
                name: "モジュール化 commonJs",
                tag: "h2",
                children: [
                  { anchor: "%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E6%A4%9C%E7%B4%A2", name: "モジュール検索", tag: "h3", children: [] },
                  { anchor: "module", name: "module", tag: "h3", children: [] },
                  { anchor: "require", name: "require", tag: "h3", children: [] },
                  { anchor: "nodejs-%E3%81%A7-es-module-%E4%BD%BF%E3%81%88%E3%82%8B%E3%81%8B", name: "NodeJS で ES Module 使えるか", tag: "h3", children: [] },
                ],
              },
              {
                anchor: "%E5%86%85%E9%83%A8%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB",
                name: "内部モジュール",
                tag: "h2",
                children: [
                  { anchor: "os", name: "os", tag: "h3", children: [] },
                  { anchor: "path", name: "path", tag: "h3", children: [] },
                  { anchor: "url", name: "url", tag: "h3", children: [] },
                  { anchor: "util", name: "util", tag: "h3", children: [] },
                  { anchor: "fs", name: "fs", tag: "h3", children: [] },
                  { anchor: "stream", name: "stream", tag: "h3", children: [] },
                  { anchor: "net-net", name: "net net", tag: "h3", children: [] },
                  { anchor: "events", name: "events", tag: "h3", children: [] },
                ],
              },
              { anchor: "%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB", name: "ライフサイクル", tag: "h2", children: [] },
              { anchor: "node-orm", name: "node ORM", tag: "h2", children: [{ anchor: "sequelize", name: "Sequelize", tag: "h3", children: [] }] },
              { anchor: "logjs", name: "logjs", tag: "h2", children: [] },
              {
                anchor: "express-(%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E7%9B%B4%E6%8E%A5%E5%87%A6%E7%90%86%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93)",
                name: "Express (非同期エラーを直接処理できません)",
                tag: "h2",
                children: [
                  { anchor: "rest-style", name: "rest style", tag: "h3", children: [] },
                  { anchor: "route", name: "Route", tag: "h3", children: [] },
                  { anchor: "middleware", name: "middleWare", tag: "h3", children: [] },
                  { anchor: "cookie%2Csession%2Cjwt", name: "cookie,session,jwt", tag: "h3", children: [] },
                  { anchor: "session", name: "session", tag: "h3", children: [] },
                  { anchor: "jwt", name: "jwt", tag: "h3", children: [] },
                  { anchor: "cors", name: "CORS", tag: "h3", children: [] },
                ],
              },
              {
                anchor: "%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89-%E4%B8%89%E5%B1%A4%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3",
                name: "バックエンド 三層アーキテクチャ",
                tag: "h2",
                children: [],
              },
              { anchor: "service", name: "Service", tag: "h2", children: [] },
              { anchor: "dao", name: "DAO", tag: "h2", children: [] },
            ],
          },
        ],
        htmlContent:
          '<h1 id="node" tabindex="-1">node</h1>\n<h2 id="%E6%A6%82%E8%A6%81" tabindex="-1">概要</h2>\n<h3 id="what\'s-node" tabindex="-1">what\'s node</h3>\n<p>js 実行環境\n通常:\nブラウザ側 =&gt; <code>JavaScript</code>\nノード =&gt; <code>nodeJs</code></p>\n<h3 id="%E3%81%AA%E3%81%9C%E3%83%8E%E3%83%BC%E3%83%89%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E3%81%AE%E3%81%8B" tabindex="-1">なぜノードが必要なのか</h3>\n<p>ブラウザでは js インタプリタ+webapi(Dom Bom ajax)のみ提供\n制限された機能</p>\n<ol>\n<li>ファイルの読み取りと書き込みの制限</li>\n<li>クロスドメインの問題\nnode js + NodeApi でコンピュータ(システム)を完全制御可能\nアプリケーションやサーバーアプリケーションを開発できる</li>\n</ol>\n<h3 id="%E7%89%B9%E5%BE%B4" tabindex="-1">特徴</h3>\n<p>シングルスレッド IO\n計算にては従来のバックエンドほど良くありません</p>\n<h2 id="global" tabindex="-1">global</h2>\n<p><code>Window</code>と一緒</p>\n<pre><code class="language-ts">       const global = {\n    \t  setTimeout():Object{\n\n    \t  },\n    \t  setImmediate(){\n\n    \t  },\n    \t  setInterval(){\n\n    \t  },\n    \t  console,\n\n    \t  process:{\n    \t\t  //命令行目录\n    \t\t   cwd(){},\n    \t\t   //强制退出node进程\n    \t\t   exit(){},\n    \t\t   //命令行中参数\n    \t\t   argv,\n    \t\t   //操作系统\n    \t\t   platform,\n    \t\t   //杀进程\n    \t\t   kill(pid){},\n    \t\t   //环境变量\n    \t\t   env\n    \t  },\n\n\n   /**\n\t* コンピュータのメモリアドレスの最新単位はバイトで、1バイト＝8ビット（1ビットは2進数）となります。 *4bit は 2^4=16 *0-15 の範囲の数値を表現できます。つまり、16 進数を使用するだけです\n    * はバイトバイトを表します。このバッファでは 16 進数が使用されます\n    */\n    \t  Buffer,\n\n\n       }\n\t   //`Window`と一緒\n       global.global = global\n\n       //グローバルだがglobalにはない\n       __dirname,\n       __filename,\n\n</code></pre>\n<h2 id="%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E5%8C%96-commonjs" tabindex="-1">モジュール化 commonJs</h2>\n<h3 id="%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E6%A4%9C%E7%B4%A2" tabindex="-1">モジュール検索</h3>\n<pre><code class="language-ts">\t   // 1.絶対パス\n\t   require(\'D:\\\\XXXX\')\n\t   //2. 相対パス\n\t\t//1)\n\t\trequire(\'./src\')\n\t\t//2)\n\t\trequire(\'axios\')\n\t    //  見つかったら絶対パスに変換してインポートします。\n\n\t//    サフィックス\n\t//   オートコンプリート\n\tjs json node mjs\n\n\t// ファイル名の検索順序\n\t     require(\'./src\')\n\t\t //  1.ファイルとして\n\t\t src.js/json/node/mjs\n\t\t// 2.packageとして\n\t\t ./src/main/index.js\n\n</code></pre>\n<h3 id="module" tabindex="-1">module</h3>\n<p>現在のモジュールに関する記録された情報</p>\n<pre><code class="language-js">\t{\n\t\t//绝对路径当id\n\t\tid: \'E:\\\\Tlight\\\\node\\\\dist\\\\module.js\',\n\t\tpath: \'E:\\\\Tlight\\\\node\\\\dist\',\n\t\texports: {},\n\t\tfilename: \'E:\\\\Tlight\\\\node\\\\dist\\\\module.js\',\n\t\tloaded: false,\n\t\tchildren: [],\n\t\tpaths: [    //这就是一层一层往上找包的原因\n\t\t\t\'E:\\\\Tlight\\\\node\\\\dist\\\\node_modules\',\n\t\t\t\'E:\\\\Tlight\\\\node\\\\node_modules\',\n\t\t\t\'E:\\\\Tlight\\\\node_modules\',\n\t\t\t\'E:\\\\node_modules\'\n\t\t]\n\t}\n</code></pre>\n<h3 id="require" tabindex="-1">require</h3>\n<pre><code class="language-js">{\n\t//返回绝对路径\n  resolve: [Function: resolve] { paths: [Function: paths] }, //静态方法\n  //入口模块\n  main: {\n    id: \'.\',\n    path: \'E:\\\\Tlight\\\\node\\\\dist\',\n    exports: {},\n    filename: \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\',\n    loaded: false,\n    children: [],\n    paths: [\n      \'E:\\\\Tlight\\\\node\\\\dist\\\\node_modules\',\n      \'E:\\\\Tlight\\\\node\\\\node_modules\',\n      \'E:\\\\Tlight\\\\node_modules\',\n      \'E:\\\\node_modules\'\n    ]\n  },\n  extensions: [Object: null prototype] { //自动解析的文件类型\n    \'.js\': [Function (anonymous)],\n    \'.json\': [Function (anonymous)],\n    \'.node\': [Function (anonymous)]\n  },\n  //缓存的模块对象\n  cache: [Object: null prototype] {\n    \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\': {\n      id: \'.\',\n      path: \'E:\\\\Tlight\\\\node\\\\dist\',\n      exports: {},\n      filename: \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\',\n      loaded: false,\n      children: [],\n      paths: [Array]\n    }\n  }\n}\n</code></pre>\n<p>例えば、一つの Module があって、理解できますか。</p>\n<pre><code class="language-js">console.log(__dirname, __filename)\nmodule.exports = {\n  a: 1,\n}\nexports.b = 2\nthis.c = 3\n</code></pre>\n<p><strong>require 原理</strong></p>\n<pre><code class="language-js">   function require(modulePath){\n\t  //step1 絶対パスに変換する\n\t  const absolutePath = xxx(modulePath)\n\t  //step2 キャッシュされているかどうかを確認する\n\t  if(require.cache[absolutePath]){\n\t\t //されたら、キャッシュされた結果を直接返します。\n\t\t return require.cache[absolutePath].result\n\t  }\n\t  //step3 ファイルの内容を読み取る\n      const fileContent = xxx()\n\t  //step4 関数にラップされる\n\t  function _temp(module,exports, require,__dirname,__filename){\n\t\t...fileContent\n\t\t// console.log(__dirname, __filename);\n\t\t// module.exports = {\n\t\t// a: 1,\n\t\t// };\n\t\t// exports.b = 2;\n\t\t// this.c = 3;\n\t  }\n\n\t  //5.モジュールオブジェクトの作成\n\t  module.exports = {}\n\t  const exports = module.exports\n\n\t  _temp.call(module.exports,module,exports,require,module.path,module.filename)\n\n\t  require.cache[module.id] = module.exports\n      return module.exports\n   }\n\n</code></pre>\n<p><code>exports === this</code></p>\n<h3 id="nodejs-%E3%81%A7-es-module-%E4%BD%BF%E3%81%88%E3%82%8B%E3%81%8B" tabindex="-1">NodeJS で ES Module 使えるか</h3>\n<pre><code class="language-mjs">// 子模块\nexport const a = 1\nexport default 1\n</code></pre>\n<pre><code class="language-mjs">// 父模块\nimport * as obj from &quot;./es.mjs&quot;\nconsole.log(obj)\n</code></pre>\n<p>使えますが、相互運用性の問題があります。自分使う時は統一されたべき。もちろん webpack とか を使えば解決できます。\n私の現在の ts は Object.defineProperty(exports, &quot;＿esModule&quot;, { value: true }); をコンパイルしました。</p>\n<p>es モジュールの静的読み込みを、require と同様の関数環境に変換します。</p>\n<h2 id="%E5%86%85%E9%83%A8%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB" tabindex="-1">内部モジュール</h2>\n<blockquote>\n<p><a href="https://nodejs.org/docs/">詳細ドキュメント</a></p>\n</blockquote>\n<h3 id="os" tabindex="-1">os</h3>\n<pre><code class="language-ts">//システム改行文字\nconsole.log(os.EOL)\n//アーキテクチャ x64\nconsole.log(os.arch())\n//cpus\nconsole.log(os.cpus())\n//freeメモリ\nconsole.log(os.freemem())\n// ユーザーディレクトリ\nconsole.log(os.homedir())\n//ホスト名\nconsole.log(os.hostname())\n//ディレクトリ\nconsole.log(os.tmpdir())\n</code></pre>\n<h3 id="path" tabindex="-1">path</h3>\n<p>filename d:\\xxx.txt 絶対パス\nbasename xxx.txt</p>\n<pre><code class="language-ts">const basename = path.basename(&quot;xxx/xxxx/a.txt&quot;, &quot;html&quot;)\nconsole.log(basename)\nconst dir = path.dirname(&quot;xxx/xxxx/a.txt&quot;)\nconsole.log(dir)\n\nconst ext = path.extname(&quot;xxx/xxx/a.txt&quot;)\nconsole.log(ext)\n\nconst fullpath = path.join(&quot;d:/t&quot;, &quot;a&quot;, &quot;index&quot;, &quot;./test&quot;)\nconsole.log(fullpath)\n\n//分隔符\\\nconst separate = path.sep\nconsole.log(separate)\n\n//;\nconst d = path.delimiter\nconsole.log(process.env.PATH?.split(d))\n\nconst validpath = path.normalize(&quot;D:/a/b/index.ts&quot;)\nconsole.log(validpath)\n\nconst relativePath = path.relative(&quot;a/b/c&quot;, &quot;a/index&quot;)\nconsole.log(relativePath)\n\n//是相当于命令行\nconst absolutePath = path.resolve(&quot;./a.js&quot;)\nconst absolutePathBymodule = path.resolve(__dirname, &quot;./a.js&quot;)\nconsole.log(absolutePath, absolutePathBymodule, __dirname)\n</code></pre>\n<h3 id="url" tabindex="-1">url</h3>\n<pre><code class="language-ts">const u = new url.URL(&quot;http://qcscimdb.benq.corp.com:81/MAI1InspectionResolve/#/home?user=Tlight.HY.Xia&quot;)\nconsole.log(u, u.searchParams.has(&quot;user&quot;))\n\nfor (let key of u.searchParams) {\n  console.log(key)\n}\nconst config = {\n  href: &quot;http://qcscimdb.benq.corp.com:81/MAI1InspectionResolve&quot;,\n  origin: &quot;http://qcscimdb.benq.corp.com:81&quot;,\n  protocol: &quot;http:&quot;,\n  username: &quot;&quot;,\n  password: &quot;&quot;,\n  host: &quot;qcscimdb.benq.corp.com:81&quot;,\n  hostname: &quot;qcscimdb.benq.corp.com&quot;,\n  port: &quot;81&quot;,\n  pathname: &quot;/MAI1InspectionResolve/&quot;,\n  search: &quot;&quot;,\n  hash: &quot;#/home?user=Tlight&quot;,\n}\n\nconsole.log(url.format(config))\n</code></pre>\n<h3 id="util" tabindex="-1">util</h3>\n<pre><code class="language-ts">util.isDeepStrictEqual({ 1: 1 }, { 1: 2 })\nutil.promisify(delay2)\nutil.callbackify(delay)\n</code></pre>\n<h3 id="fs" tabindex="-1">fs</h3>\n<p>ファイル io にて, CPU はメモリのみを処理し、動作するにはファイルをメモリに読み込む必要がありますが、io 操作は CPU ,メモリよりもはるかに遅くなります。</p>\n<pre><code class="language-ts">Stats {\n  dev: 24198785,\n  mode: 33206,\n  nlink: 1,\n  uid: 0,\n  gid: 0,\n  rdev: 0,\n  blksize: 4096,\n  ino: 281474979039900,\n  size: 0,\n  blocks: 0,\n  atimeMs: 1718958726062.4705,\n  mtimeMs: 1718958640012.3835,\n  ctimeMs: 1718958640012.3835,\n  birthtimeMs: 1718957669240.9294,\n  //访问\n  atime: 2024-06-21T08:32:06.062Z,\n  //修改\n  mtime: 2024-06-21T08:30:40.012Z,\n  //访问状态修改\n  ctime: 2024-06-21T08:30:40.012Z,\n  birthtime: 2024-06-21T08:14:29.241Z\n}\n\n\nconst getAbsolutePath = (relativePath: string) =&gt; {\n  const res = path.resolve(__dirname, relativePath);\n  //   console.log(res, __dirname);\n\n  return res;\n};\nfs.readFile(getAbsolutePath(&quot;./fs.txt&quot;), (err, res) =&gt; {\n  //   console.log(res);\n\n  fs.writeFile(\n    getAbsolutePath(&quot;./fs.txt&quot;),\n    os.EOL + &quot;abc&quot;,\n    {\n      flag: &quot;a&quot;, //追加内容\n    },\n    () =&gt; {}\n  );\n  fs.writeFile(\n    getAbsolutePath(&quot;./fs2.txt&quot;),\n    Buffer.from(&quot;text from buffer&quot;),\n    () =&gt; {}\n  );\n  //    fs.promises.stat(getAbsolutePath(&quot;./fs2.txt&quot;));\n  fs.promises.stat(getAbsolutePath(&quot;./&quot;)).then((v) =&gt; {\n    console.log(v.isDirectory);\n  });\n  fs.promises.readdir(getAbsolutePath(&quot;./&quot;)).then((v) =&gt; {\n    console.log(v);\n  });\n\n  fs.promises\n    .access(getAbsolutePath(&quot;test&quot;), constants.F_OK)\n    .catch((v) =&gt; {\n      console.log(v);\n      return fs.promises.mkdir(getAbsolutePath(&quot;test&quot;));\n    })\n    .then((v) =&gt; {\n      fs.promises.readFile(getAbsolutePath(&quot;./fs.txt&quot;)).then((res) =&gt; {\n        fs.promises.writeFile(getAbsolutePath(&quot;test/test.txt&quot;), res);\n      });\n    });\n});\n</code></pre>\n<h3 id="stream" tabindex="-1">stream</h3>\n<p>先ほどの方法を使用すると、大量のメモリが消費されます。stream を推奨する。</p>\n<ol>\n<li>readable</li>\n<li>writable</li>\n<li>duplex\n解决背压：rs.pipe(ws)</li>\n</ol>\n<h3 id="net-net" tabindex="-1">net net</h3>\n<p>接続が確立された後、ソケットは duplex になります。</p>\n<p>TCP/IP プロトコルを使用した http リクエストの実現</p>\n<pre><code class="language-ts">import { parseHtml } from &quot;.&quot;\nimport net from &quot;net&quot;\n\nconst server = net.createServer()\nserver.listen(&quot;8585&quot;)\n\nserver.on(&quot;connection&quot;, (socket) =&gt; {\n  socket.on(&quot;data&quot;, (chunk) =&gt; {\n    console.log(parseHtml(chunk.toString(&quot;utf-8&quot;)))\n  })\n  const res = `\nHTTP/1.1 200 Ok\nContent-Type: image/jpeg\n\n\n `\n  socket.write(res.trimStart())\n  socket.end()\n  //   server.close()\n})\n</code></pre>\n<h3 id="events" tabindex="-1">events</h3>\n<p>自分も書いてみた</p>\n<pre><code class="language-ts">import events, { EventEmitter } from &quot;events&quot;\n\nconst em = new EventEmitter()\n\nem.on(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test1&quot;)\n})\n\nem.on(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test2&quot;)\n})\nem.once(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test3&quot;)\n})\nconsole.log(em.listeners(&quot;test&quot;))\n\nem.emit(&quot;test&quot;)\nconsole.log(em.listeners(&quot;test&quot;))\n</code></pre>\n<h2 id="%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB" tabindex="-1">ライフサイクル</h2>\n<p>event loop ----timers timers 队列(要运算) 存放计时器回调 注：队列内容来着于计时器线程，需要计算;setTimeout 底层最小值为 1\n|\nnexttrick |\npromise |\n(每次循环先要 |\n清空的微队列; |\nnexttrick |\n优先级最高) pull 轮询队列 除了 timers，checks 。包括文件读取，用户请求;如果所有队列都空了,且有要等待的会卡在这;其他队列有东西了,就会从这里开始走一个新的循环\n|\n|\n|\n-----checks checks 队列 setImmediate 回调队列</p>\n<h2 id="node-orm" tabindex="-1">node ORM</h2>\n<p>object relation mapping</p>\n<h3 id="sequelize" tabindex="-1">Sequelize</h3>\n<p>自分でいくつかの一般的な方法を試し、記憶を促進するためのクラスを作成しました。</p>\n<pre><code class="language-ts">interface ISequelizeHelperInit {\n  user: string\n  password: string\n  database: string\n  host: string\n  dialect: Dialect\n}\nclass SequelizeHelper {\n  private _sequelize: Sequelize\n  private _connectedModels: Set&lt;typeof Model&gt; = new Set()\n  private constructor({ user, password, database, host, dialect }: ISequelizeHelperInit) {\n    this._sequelize = new Sequelize(database, user, password, {\n      host,\n      dialect,\n      logging: (err) =&gt; logHelper.sqlLogger.debug(err),\n    })\n  }\n  get instance() {\n    return this._sequelize\n  }\n  /**\n   * 默认alter: true,会改表\n   * @param association\n   * @param arg\n   * @returns\n   */\n  async initModels(\n    association?: (() =&gt; any) | null,\n    ...arg: Array&lt;{\n      model: ModelStatic&lt;Model&lt;any, any&gt;&gt;\n      attributes: ModelAttributes&lt;\n        Model,\n        // \'foreign keys\' are optional in Model.init as they are added by association declaration methods\n        Optional&lt;Attributes&lt;Model&gt;, BrandedKeysOf&lt;Attributes&lt;Model&gt;, symbol&gt;&gt;\n      &gt;\n      options: Partial&lt;InitOptions&lt;Model&lt;any, any&gt; | any&gt;&gt;\n    }&gt;\n  ) {\n    // return await Promise.all(\n\n    arg.map(async (m) =&gt; {\n      //@ts-ignore\n      m.model.init(m.attributes, {\n        sequelize: this._sequelize,\n        ...m.options,\n      })\n\n      //   return m.model.sync({\n      //     alter: true\n      //   })\n    })\n    association &amp;&amp; association()\n\n    // )\n    const res = await this._sequelize.sync({ alter: true }).catch(() =&gt; false)\n    // association()\n    if (!!res) {\n      arg.forEach((m) =&gt; {\n        this._connectedModels.add(m.model)\n      })\n    }\n    return !!res\n  }\n  async testConnection() {\n    try {\n      await this._sequelize.authenticate()\n      return true\n    } catch (error) {\n      console.error(&quot;Unable to connect to the database:&quot;, error)\n      return false\n    }\n  }\n  bulkCreate&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, instances: Partial&lt;InstanceType&lt;T&gt;&gt;[]) {\n    console.log(instances)\n\n    //@ts-ignore\n    this.hasModel(model) &amp;&amp; model.bulkCreate(instances)\n  }\n  hasModel(v: typeof Model) {\n    if (!this._connectedModels.has(v)) {\n      console.error(&quot;please init first&quot;)\n      throw &quot;&quot;\n    }\n    return true\n  }\n\n  /**\n   *\n   * @param model\n   * @param instance\n   * @returns\n   * 只做记录Sequelize的数据库操作\n   * 不强制使用 Service层一个ts文件只操作一个类,不混杂\n   */\n  insert2Model&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, instance: Partial&lt;InstanceType&lt;T&gt;&gt;) {\n    //@ts-ignore\n    return this.hasModel(model) &amp;&amp; model.create(instance).then((res) =&gt; res.toJSON())\n  }\n  updateModel&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: { [key in keyof Attributes&lt;InstanceType&lt;T&gt;&gt;]?: Attributes&lt;InstanceType&lt;T&gt;&gt;[key] }, conditions: Partial&lt;InstanceType&lt;T&gt;&gt;) {\n    //@ts-ignore\n\n    return this.hasModel(model) &amp;&amp; model.update(modelInstance, { where: { ...conditions } })\n  }\n  deleteFromModel&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n      model.destroy({\n        where: {\n          ...modelInstance,\n        },\n      })\n    )\n  }\n\n  select&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model.findAll({\n        where: {\n          ...modelInstance,\n        },\n      })\n    )\n  }\n  selectSetWhere&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, func: () =&gt; WhereOptions&lt;InferAttributes&lt;InstanceType&lt;T&gt;&gt;&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model\n        .findAll({\n          where: func(),\n        })\n        .then((res) =&gt; res.map((m) =&gt; m.toJSON()))\n    )\n  }\n  selectPageData&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;, page = 1, limit = 10) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n      model\n        .findAndCountAll({\n          where: {\n            ...modelInstance,\n          },\n          offset: (page - 1) * +limit,\n          limit: +limit,\n        })\n        .then(({ rows, count }) =&gt; {\n          return {\n            count,\n            rows: rows.map((m) =&gt; m.toJSON()),\n          }\n        })\n    )\n  }\n  selectAssolationData&lt;T extends typeof Model&lt;any, any&gt;&gt;(\n    model: T,\n    {\n      func = function () {\n        return {}\n      },\n      includes = null,\n    }: {\n      func: () =&gt; WhereOptions&lt;InferAttributes&lt;InstanceType&lt;T&gt;&gt;&gt;\n      includes: Model&lt;any, any&gt;[]\n    }\n  ) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model\n        .findAll({\n          where: func(),\n          ...(includes\n            ? {\n                include: includes,\n              }\n            : {}),\n        })\n        .then((res) =&gt; res.map((m) =&gt; m.toJSON()))\n    )\n  }\n\n  static _instance: SequelizeHelper\n  static getInstance(data: ISequelizeHelperInit): SequelizeHelper {\n    if (this._instance) {\n      return this._instance\n    }\n    this._instance = new SequelizeHelper(data)\n    return this.getInstance(data)\n  }\n}\n\n/**\n * 设置模型统一配置，在SequelizeHelper里面统一注册\n * @param param0\n * @returns\n */\nfunction setModel&lt;T extends Model, M extends InstanceType&lt;ModelStatic&lt;T&gt;&gt;&gt;({\n  model,\n  attributes,\n  options = {},\n}: {\n  model: ModelStatic&lt;T&gt;\n  attributes: ModelAttributes&lt;M, Optional&lt;Attributes&lt;M&gt;, BrandedKeysOf&lt;Attributes&lt;M&gt;, never&gt;&gt;&gt;\n  options?: Partial&lt;InitOptions&lt;T&gt;&gt;\n}) {\n  return {\n    model,\n    attributes,\n    options,\n  }\n}\n</code></pre>\n<p><strong>使用</strong>\n初期化</p>\n<pre><code class="language-ts">const sequelizeHelperInstance = SequelizeHelper.getInstance({\n  ...(require(&quot;./config.json&quot;) as Record&lt;&quot;user&quot; | &quot;password&quot;, string&gt;),\n  database: process.env.DB_NAME,\n  dialect: process.env.DB_Type,\n  host: process.env.DB_HOST,\n})\n\nsequelizeHelperInstance.testConnection().then(() =&gt; {\n  console.log(&quot;db connect success&quot;)\n})\n</code></pre>\n<p>モデルの定義</p>\n<pre><code class="language-ts">export class Blog extends Model&lt;InferAttributes&lt;Blog, { omit: &quot;id&quot; | &quot;blogType&quot; }&gt;, InferCreationAttributes&lt;Blog, { omit: &quot;id&quot; | &quot;blogType&quot; }&gt;&gt; implements IBlog {\n  declare id: string\n  declare title: string\n  declare description: string\n  declare toc: string\n  declare htmlContent: string\n  declare thumb: string\n  declare scanNumber: string\n  declare commentNumber: string\n  declare createDate: string\n  declare isValid: &quot;Y&quot; | &quot;N&quot;\n  declare blogType: string\n}\n\nexport const blogSetting = setModel({\n  model: Blog,\n  attributes: {\n    title: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    description: {\n      allowNull: true,\n      type: DataTypes.STRING,\n      defaultValue: 0,\n    },\n    toc: {\n      type: DataTypes.TEXT,\n      allowNull: false,\n    },\n    htmlContent: {\n      type: DataTypes.TEXT,\n      allowNull: false,\n    },\n    isValid: {\n      type: DataTypes.STRING(1),\n      allowNull: false,\n      defaultValue: &quot;Y&quot;,\n    },\n    thumb: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    scanNumber: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    commentNumber: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    createDate: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n  },\n  options: {\n    tableName: &quot;blog&quot;,\n  },\n})\n</code></pre>\n<p>一致化</p>\n<pre><code class="language-ts">sequelizeHelperInstance.initModels(association, AdminSetting, homeSetting, blogTypeSetting, blogSetting, messageSetting)\n</code></pre>\n<h4>MD5</h4>\n<p>暗号化のみ可能ですが、復号化はできません。暗号化結果は固定されており、パスワードの暗号化に使用されます。</p>\n<h2 id="logjs" tabindex="-1">logjs</h2>\n<pre><code class="language-ts">import log, { getLogger } from &quot;log4js&quot;\nlog.configure({\n  appenders: {\n    sql: {\n      type: &quot;dateFile&quot;,\n      filename: path.resolve(__dirname, &quot;../../../logs&quot;, &quot;sql&quot;, &quot;logs.log&quot;),\n      layout: {\n        type: &quot;pattern&quot;,\n        pattern: &quot;%c [%d{yyyy-MM-dd hh:mm:ss}] [%p] %m %n&quot;,\n      },\n      keepFileExt: true,\n    },\n    default: {\n      type: &quot;stdout&quot;,\n      //   filename: path.resolve(__dirname, &quot;logs&quot;, &quot;default&quot;, &quot;logs.log&quot;),\n      //   keepFileExt: true\n    },\n  },\n  categories: {\n    sql: {\n      appenders: [&quot;sql&quot;],\n      level: &quot;all&quot;,\n    },\n    default: {\n      appenders: [&quot;default&quot;],\n      level: &quot;all&quot;,\n    },\n  },\n})\n\nprocess.on(&quot;exit&quot;, () =&gt; {\n  log.shutdown()\n})\n\nexport default {\n  sqlLogger: getLogger(&quot;sql&quot;),\n  logger: getLogger(&quot;default&quot;),\n}\n</code></pre>\n<h2 id="express-(%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E7%9B%B4%E6%8E%A5%E5%87%A6%E7%90%86%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93)" tabindex="-1">Express (非同期エラーを直接処理できません)</h2>\n<p>http モジュールを直接使用することに問題はありません。URL パスを介してさまざまなメソッドを呼び出すには、多くの判断が必要です。データはストリーム メソッドを介して送信されるため、parseHtml を手動で受け入れる必要があります。</p>\n<h3 id="rest-style" tabindex="-1">rest style</h3>\n<pre><code class="language-ts">/api/user get 取得\n/api/ユーザー post 保存\n/api/user put 変更を加えます\n/api/user delete 削除\n</code></pre>\n<h3 id="route" tabindex="-1">Route</h3>\n<p>またモジュール化可能\n<strong>自分で書いてみたルーティング設定</strong></p>\n<pre><code class="language-ts">type Method = &quot;all&quot; | &quot;get&quot; | &quot;post&quot; | &quot;put&quot; | &quot;delete&quot; | &quot;patch&quot; | &quot;options&quot; | &quot;head&quot;\n\n/**\n * base route config\n */\ninterface IRouterItem {\n  method: Method\n  url: string\n  handler: (request: Request, response: Response) =&gt; Promise&lt;any&gt;\n  needAuth?: boolean\n  canCORS?: boolean\n}\n</code></pre>\n<p>Router 管理統一</p>\n<pre><code class="language-ts">export class RouterHelper {\n  /**\n   * all routes\n   */\n  private _routerCache: Record&lt;string, IRouterItem[]&gt; = {}\n  private constructor(private _app: Express) {}\n  registerRouter(baseUrl: string, router: Router, routerItems: IRouterItem[]) {\n    if (this._routerCache[baseUrl]) {\n      throw new Error(&quot;this baseUrl has been used&quot;)\n    }\n    this.addRouters(router, routerItems)\n    this._app.use(baseUrl, router)\n    this._routerCache[baseUrl] = routerItems\n  }\n  private addRouters(router: Router, routerItems: IRouterItem[]) {\n    routerItems.forEach((item) =&gt; {\n      router[item.method](item.url, response2Client(item.handler))\n    })\n  }\n  /**\n   *\n   * @param param0\n   * @returns\n   * get current route config\n   * 查询对应路由配置\n   */\n  getRouterItem&lt;T extends { baseUrl: string; url: string; method: Method }&gt;({ baseUrl, url, method }: T) {\n    // console.log(this._routerCache)\n\n    for (let baseurl in this._routerCache) {\n      for (let item of this._routerCache[baseurl]) {\n        if (method.toUpperCase() === item.method.toUpperCase() &amp;&amp; pathToRegexp(handlePathEnd(baseurl + item.url)).test((baseUrl + url).split(&quot;?&quot;)[0])) return item\n      }\n    }\n  }\n\n  private static _instance: RouterHelper\n  static Instance(app: Express): RouterHelper {\n    if (this._instance) {\n      return this._instance\n    } else {\n      this._instance = new RouterHelper(app)\n      return this.Instance(app)\n    }\n  }\n}\n\n/**\n * 处理路径类似 /login/ 与 /login 冲突问题\n * @param path\n * @returns\n */\nfunction handlePathEnd(path: string) {\n  if (path.slice(-1) === &quot;/&quot;) {\n    return handlePathEnd(path.slice(0, path.length - 1))\n  }\n  return path\n}\n/**\n * response method,it can response data that func return\n * 套了一层，配置路由时不用关心如何返回数据\n * @param func\n * @returns\n */\nconst response2Client = (func: IRouterItem[&quot;handler&quot;]): RequestHandler =&gt; {\n  return async function (request, response, next) {\n    try {\n      const res = await func(request, response)\n      // console.log(res, getResponseData(res), response.headersSent)\n      response.send(getResponseData(res))\n    } catch (err) {\n      //   console.log(err)\n      next(err)\n    }\n  }\n}\n</code></pre>\n<p>定義を容易にするために hook 作成しました。</p>\n<pre><code class="language-ts">export function useRoutes({ router = express.Router(), routerItems, baseUrl }: { router?: Router; routerItems: IRouterItem[]; baseUrl: string }) {\n  function registerRouter(RouterHelperInstance: RouterHelper) {\n    RouterHelperInstance.registerRouter(baseUrl, router, routerItems)\n  }\n\n  return {\n    registerRouter,\n  }\n}\n</code></pre>\n<p><strong>使用</strong></p>\n<pre><code class="language-ts">const { registerRouter } = useRoutes({\n  routerItems: [\n    {\n      method: &quot;get&quot;,\n      url: &quot;/&quot;,\n      async handler(request) {\n        return blogServiceInstance.getBlogsPagenation(request.query as any)\n      },\n      canCORS: true,\n      //   needAuth: true\n    },\n    //...\n  ],\n  baseUrl: &quot;/api/blog&quot;,\n})\n\nexport { registerRouter }\n</code></pre>\n<h3 id="middleware" tabindex="-1">middleWare</h3>\n<pre><code class="language-ts">app.get(\n  &quot;/abc/:id&quot;,\n  () =&gt; {\n    // middleWare1\n    next()\n  },\n  () =&gt; {\n    // middleWare2\n  }\n)\n</code></pre>\n<p>どの middleWare でも応答できますが、応答できるのは 1 回だけです\n後続の middleWare を実行したい場合は、手動で next を呼び出す必要があります。\n応答はありませんが、最後の middleWare が next を呼び出しましたと,404 になります。\nnext(new Error())/throw new error を呼び出すと、後続の例外処理 middleWare が検索されます。</p>\n<pre><code class="language-ts">//useの使用範囲が広く、一致しているbaseURlを取得できます。\napp.use(&quot;/abc&quot;, (err, req, res, next) =&gt; {\n  console.log(err)\n  if (err) {\n    res.send({\n      err: &quot;err&quot;,\n    })\n  }\n})\n</code></pre>\n<p>自分で書いた middleWare\nauthorization</p>\n<pre><code class="language-ts">export function authorizationMiddleWare(): RequestHandler {\n  return function (request, response, next) {\n    let { baseUrl, url, method } = request\n    //統一されたRouterからsearch\n    const routerItem = RouterHelperInstance?.getRouterItem({ baseUrl, url, method: method as any })\n    if (!routerItem) {\n      throw new NotFoundError(&quot;path not found:&quot; + baseUrl + url + &quot;,method&quot; + method)\n    } else {\n      if (routerItem.needAuth) {\n        const res = JWTHelperIns.validateJwtToken(request)\n        if (res &amp;&amp; res.loginId) {\n          request.user = res\n          next()\n        } else {\n          throw new ForbiddenError(&quot;authorization fail,please login again&quot;)\n        }\n      } else {\n        next()\n      }\n    }\n  }\n}\n</code></pre>\n<p>cors</p>\n<pre><code class="language-ts">export default function (): RequestHandler {\n  return function (request, response, next) {\n    //クロスドメイン\n    if (&quot;origin&quot; in request.headers) {\n      let { method, path, baseUrl } = request\n      if (method.toUpperCase() === &quot;OPTIONS&quot;) {\n        method = request.headers[&quot;access-control-request-method&quot;]\n      }\n      const currentRouter = RouterHelperInstance.getRouterItem({\n        baseUrl,\n        method: method as any,\n        url: path,\n      })\n\n      //クロスドメインを許可する\n      if (currentRouter?.canCORS &amp;&amp; whiteList.includes(request.headers.origin)) {\n        //1.簡単なリクエスト　 access-control-allow-origin許可\n        if (typeof request.headers.origin !== &quot;undefined&quot;) {\n          response.header(&quot;access-control-allow-origin&quot;, request.headers.origin)\n        }\n        //2. OPTIONS　リクエスト\n        if (request.method.toUpperCase() === &quot;OPTIONS&quot;) {\n          response.header(&quot;access-control-allow-headers&quot;, request.headers[&quot;access-control-request-headers&quot;])\n          response.header(&quot;access-control-allow-methods&quot;, request.headers[&quot;access-control-request-method&quot;])\n          //未来多少秒内不要发预检了\n          response.header(&quot;access-control-max-age&quot;, &quot;3600&quot;)\n        }\n        //3.credentialsリクエスト\n        response.header(&quot;access-control-allow-credentials&quot;, &quot;true&quot;)\n      }\n      //OPTIONS　リクエスト　return\n      if (request.method.toUpperCase() === &quot;OPTIONS&quot;) {\n        return response.status(200).end()\n      }\n    }\n    next()\n  }\n}\n</code></pre>\n<p>error</p>\n<pre><code class="language-ts">export function errorHandler(): ErrorRequestHandler {\n  return function (err, request, response, next) {\n    const { message, code } = getResponseErrorData(err)\n    response.status(code).send({ message, code })\n  }\n}\n\nenum EServiceErrorCode {\n  UploadError = &quot;413&quot;,\n  ForbiddenError = &quot;401&quot;,\n  ValidateError = &quot;406&quot;,\n  NotFoundError = &quot;406&quot;,\n  UnknownError = &quot;500&quot;,\n}\n\n/**\n * base class\n */\nabstract class SeviceError extends Error {\n  code: EServiceErrorCode\n  constructor(message: string, code: EServiceErrorCode) {\n    super(message)\n    this.code = code\n  }\n}\n\nclass UploadError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.UploadError)\n  }\n}\n\nclass ForbiddenError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.ForbiddenError)\n  }\n}\n\nclass ValidateError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.ValidateError)\n  }\n}\n\nclass NotFoundError extends SeviceError {\n  constructor(res = &quot;file/api not found&quot;) {\n    super(res, EServiceErrorCode.NotFoundError)\n  }\n}\n\nclass UnknownError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.UnknownError)\n  }\n}\n</code></pre>\n<h3 id="cookie%2Csession%2Cjwt" tabindex="-1">cookie,session,jwt</h3>\n<p>どうやってコントロールするのか、あるいは誰なのかをどうやって確認するのか、それは捏造された情報ではありません。 http はステートレスだからです。</p>\n<p>クライアントが存在します。<code>key=value;path=/;domain=?;expire=?;max-age=?secure;httponly</code></p>\n<p>ブラウザは Cookie ルールを自動的に保存します。</p>\n<ol>\n<li>有効期限が切れていない</li>\n<li>ドメイン (ベースドメイン) を比較し、ポートとは関係がありません。</li>\n<li>path を比較</li>\n<li>secure = true のみ https\n条件が満たされると、ブラウザはリクエスト ヘッダーに Cookie を自動的に追加します。</li>\n</ol>\n<p><strong>key,path,domain</strong> のみがすべて同じであり、これは同じ Cookie です。</p>\n<pre><code class="language-ts">interface Cookie{\n   [key: string]: sting\n\n   /**\n\t* デフォルトの現在のリクエストパスを設定しないでください\n    */\n   path?: string\n\n   domain?: string\n   /**\n\t* GMT时间，UTC时间\n\t* new Date().toGMTString()\n\t* \'Mon, 01 Jul 2024 10:43:49 GMT\'\n    */\n   expire?: string\n   /**\n\t* 何秒後に期限切れになるか\n    */\n   max-age?: string  //既没有max-age也没有expire的话，就是回话解说词\n\n   /**\n\t* 設定は https のみに使える\n    */\n   secure?:boolean\n\n   /**\n　　　*サーバー側のみ設定可能\n　　　*送信時のみ使用する設定の場合、jsは使用できません。\n　　　*jsを使用するとxxr（クロスサイトスクリプティング攻撃）が発生する可能性があります\n　　　* たとえば、iframe が Web サイトに埋め込まれている場合、その js はソース Web サイトの Cookie にアクセスできます。\n    */\n   httponly\n}\n</code></pre>\n<h3 id="session" tabindex="-1">session</h3>\n<p>サーバー側にあります。sessionid はサーバーのリソースを占有し、Cookie を通じてクライアントに渡されます。セッション ID で確認します。</p>\n<h3 id="jwt" tabindex="-1">jwt</h3>\n<p>しかし、ブラウザがなければ、 cookie はまったく存在しません。JSON WEB TOKEN の誕生\njwt は response のどこいてもいい，cookie，headers，body</p>\n<p>ちなみに、<code>OAuth2</code> だったら、 そういう形</p>\n<pre><code class="language-ts">GET PATH HTTP/1.1\n...\nauthorization： bearer jwt\n...\n\n</code></pre>\n<pre><code class="language-ts">   interface JWT{\n\t   header: {\n\t\t  //    タイプ\n\t\t  typ:&quot;JWT&quot;,\n\t\t  //    signature署名アルゴリズム\n\t\t  alg: string|&quot;H256&quot;|...\n\t   }\n\t   //主体信息\n\t   payload: {\n          //    any\n\t   }\n\t   //改ざんされないことを保証\n\t   signature: string\n   }\n    instance:  base64(header).base64(payload).signature\n    // 服务器端判断\n\tH256(header,payload,secret) === signature\n</code></pre>\n<p>自分で書いた Helper</p>\n<pre><code class="language-ts">enum Oath2Token {\n  key = &quot;bearer&quot;,\n}\n\nclass JWTHelper {\n  /**\n   * add token to cookie and authorization\n   * @param res\n   * @param payload\n   * @param maxAge ms\n   */\n  publish(res: Response, payload = {}, maxAge = 3600 * 24 * 1000) {\n    const token = jwt.sign(payload, this._secret, {\n      expiresIn: maxAge,\n    })\n\n    res.header(&quot;authorization&quot;, token)\n    res.header(&quot;access-control-expose-headers&quot;, &quot;Authorization&quot;)\n  }\n  validateJwtToken(request: Request) {\n    let token: string = request.cookies ? request.cookies[this._cookieKey] : &quot;&quot;\n    if (!token) {\n      token = request.headers.authorization\n    } else {\n      //if token from cookie, add bearer\n      token = &quot;bearer &quot; + token\n    }\n\n    if (!token) {\n      throw new ForbiddenError(&quot;don\'t have token&quot;)\n    }\n    //oatu2 の bearer処理\n    const tokenArr = token.split(&quot; &quot;)\n    if (tokenArr.length === 2) {\n      if (tokenArr[0].toLowerCase() !== Oath2Token.key) {\n        throw new Error(&quot;token format error&quot;)\n      }\n      token = tokenArr[1]\n    }\n\n    try {\n      const res = jwt.verify(token, this._secret) as ILoginReturn\n      return res\n    } catch (e) {\n      throw e\n    }\n  }\n  constructor(private _secret: string, private _cookieKey: string) {}\n}\n\nconst defaultSetting = {\n  secret: Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-8),\n  cookieKey: &quot;token&quot;,\n}\n\nconst JWTHelperIns = new JWTHelper(defaultSetting.secret, defaultSetting.cookieKey)\n\nexport default JWTHelperIns\n</code></pre>\n<h3 id="cors" tabindex="-1">CORS</h3>\n<ol>\n<li>jsonp\nお勧めしない。 script タグは get リクエストのみを送信できます (リソース ファイルはドメインを越えて送信できます)。</li>\n</ol>\n<pre><code class="language-ts">//back end\nconst res = {}\nresponse.header(&quot;content-type&quot;, &quot;application/javascript&quot;)\nresponse.send(`callback${JSON.stringify(res)}`)\n\n//front end\nfunction jsonp(url) {\n  const el = document.createElement(&quot;script&quot;)\n  el.src = url\n  document.body.appendChild(el)\n  el.onload = () =&gt; {\n    el.remove()\n  }\n}\n\nfunction callback(data) {}\n</code></pre>\n<ol start="2">\n<li>\n<p>CORS cross origin resource sharing</p>\n<ol>\n<li>簡単なリクエスト\nmethod: get post head(ダウンロード)\nheader 追加情報はありません\ncontent-type : text/pain;multipart/form-data;application/x-www-form-urlencoded</li>\n</ol>\n<p>ブラウザは自動的 origin を追加します\nバックエンドでは Access-Control-Allow-Origin:<code>*/特定のドメイン名(お勧め)</code></p>\n<ol start="2">\n<li>\n<p>OPTIONS リクエスト\n簡単なリクエストじゃないと、 OPTIONS リクエストになります\nブラウザでは\nOPTIONS /path HTTP/1.1\nAccess-Control-Request-Method:GET\nAccess-Control-Request-Headers:a\nOrigin:xxxx</p>\n<p>バックエンドでは\nAccess-Control-Request-Method:GET\nAccess-Control-Request-Headers:a\naccess-control-max-age:?:&quot;3600&quot; //次の数秒間はいらない</p>\n</li>\n</ol>\n<p>３ 身分証明を持ってる(cookie とか)\n&quot;access-control-allow-credentials&quot;：&quot;true&quot;\n<strong>PS： <code>Access-Control-Allow-Origin:*</code> はダメ</strong></p>\n</li>\n</ol>\n<h2 id="%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89-%E4%B8%89%E5%B1%A4%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3" tabindex="-1">バックエンド 三層アーキテクチャ</h2>\n<h2 id="route-1" tabindex="-1">Route</h2>\n<pre><code class="language-tex"> 外部APIを提供する expressとか使う    以上があります\n</code></pre>\n<h2 id="service" tabindex="-1">Service</h2>\n<p>业务逻辑</p>\n<p>ここでは、単純に合法かどうかを判断するために私が書いたデコレータを使用します。</p>\n<pre><code class="language-ts">class AdminService {\n  /**\n   *\n   * @param param0\n   * @returns\n   */\n  @FuncIntercepter({}, { groups: [&quot;checkUserValid&quot;] })\n  async isUserValidate(@ParamType(AdminValidate) { loginId, loginPwd }: Partial&lt;IAdmin&gt;) {\n    loginPwd = md5(loginPwd)\n    const res = await AdminDaoInstance.queryUser({ loginId, loginPwd })\n    if (res &amp;&amp; res.dataValues) {\n      return { res: true, row: res.dataValues }\n    }\n    return { res: false }\n  }\n  /**\n   * set Authorization header\n   * @param response\n   * @param param1\n   */\n  @FuncIntercepter()\n  async setAuthorization(response: Express.Response, @ParamType(AdminValidate) { loginId, name, remember, role }: Partial&lt;ILoginData&gt;) {\n    remember = remember ? +remember : 1\n    JWTHelperIns.publish(response as any, { loginId, name, role }, 60 * 60 * 24 * remember)\n  }\n  @FuncIntercepter()\n  async updateUserPwd&lt;T extends IUpdateUserPwd&gt;(@ParamType(AdminValidate) { loginId, loginPwd, oldPwd, name }: T) {\n    const { res, row } = await this.isUserValidate({ loginId, loginPwd: oldPwd })\n    if (res &amp;&amp; row) {\n      // console.log(row);\n      const { id } = row as IAdmin\n      return await AdminDaoInstance.updateUser(\n        {\n          loginPwd: md5(loginPwd),\n          name,\n        },\n        { id }\n      )\n    } else {\n      throw new ValidateError(&quot;old password error&quot;)\n    }\n  }\n}\n</code></pre>\n<h2 id="dao" tabindex="-1">DAO</h2>\n<p>通常は ORM を使用してデータベースと対話します。</p>\n<pre><code class="language-ts">class AdminDao {\n  async queryUser({ loginId, loginPwd }: Pick&lt;IAdmin, &quot;loginId&quot; | &quot;loginPwd&quot;&gt;) {\n    return await Admin.findOne({\n      where: {\n        loginId,\n        loginPwd,\n        isValid: &quot;Y&quot;,\n      },\n    })\n  }\n  async updateUser(newInfo: Partial&lt;IAdmin&gt;, where: Partial&lt;IAdmin&gt;) {\n    return await Admin.update(newInfo, {\n      where,\n    })\n  }\n}\n</code></pre>\n',
        category: { id: 63, name: "Node" },
      },
      {
        thumb: require("@/assets/JS.png"),

        id: 3,
        title: "JS補い",
        description: "高度な JS 学習。主に ES6 のギャップを確認して埋めることについてです。原理を理解することによってのみ、それらをより適切に適用できます。",
        scanNumber: "0",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "js",
            name: "js",
            tag: "h1",
            children: [
              { anchor: "%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF(construct)", name: "コンストラクタ(construct)", tag: "h2", children: [] },
              { anchor: "property-descriptor", name: "property descriptor", tag: "h2", children: [] },
              {
                anchor: "es6",
                name: "ES6",
                tag: "h2",
                children: [
                  { anchor: "1.-symbol", name: "1. symbol", tag: "h3", children: [] },
                  { anchor: "2.-iterator", name: "2. iterator", tag: "h3", children: [] },
                  { anchor: "3.-generator", name: "3. generator", tag: "h3", children: [] },
                  { anchor: "4.-reflect", name: "4. Reflect", tag: "h3", children: [] },
                  { anchor: "5.-proxy", name: "5. proxy", tag: "h3", children: [] },
                ],
              },
            ],
          },
        ],
        htmlContent:
          '<h1 id="js" tabindex="-1">js</h1>\n<h2 id="%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF(construct)" tabindex="-1">コンストラクタ(construct)</h2>\n<ol>\n<li><strong>js 内のすべてのオブジェクトはコンストラクターを通じて生成されます</strong></li>\n</ol>\n<pre><code class="language-ts">      const obj = {1:1} =&gt; const o = new Object()  o[1] = 1\n      const arr = [1,2] =&gt; const arr2 = new Array(1,2)\n      const sum = (a,b)=&gt;a+b =&gt; const sum = new Function(\'a\',\'b\',\'return a+b\')\n</code></pre>\n<ol start="2">\n<li><strong>prototype 三角関係</strong></li>\n</ol>\n<p><code>new instance</code>たびに大量の重複コンテンツが生成され、大量のメモリを占有します。特に方法です。\n<code>function (object)</code> には<code>prototype(これも object)</code>というプロパティがあります。instance の<code>__proto__</code>がそれを指します。したがって、パブリックメンバーは <code>prototype</code> に配置されます</p>\n<ol start="3">\n<li>\n<p><code>this</code> <strong>呼び出す時に決まる</strong>\n特別のシーン：</p>\n<ol>\n<li><code>()=&gt;{}</code>\n<code>this</code>は定義の時に決定される</li>\n<li><code>手動で指定する</code></li>\n</ol>\n<pre><code class="language-ts">     function a(){\n       ...\n     }\n     a() &lt;=&gt; a.call()\n\n     a.call(this,...argment)\n     a.apply(this,...arg:[])\n\n</code></pre>\n</li>\n<li>\n<p><code>prototype chain</code> いわば<code>__proto__</code>にて</p>\n<ol>\n<li><code>instanceof</code>\n<strong><code>__proto__</code>/constructor.prototype</strong> にあるか。シンプルに<code>is</code>として理解されます</li>\n<li><code>Object.getPrototypeOf(o)</code>\nprototype を取得する。 直接<code>__proto__</code>を使うのはよくない。</li>\n<li><code>const obj = Object.create(target)</code>\n<code>Object.getPrototypeOf(obj)===target</code></li>\n<li><code>Object.setPrototypeOf(a1,a2)</code>\nprototype の設置</li>\n<li>継承\nUser.call(this,name)\nObject.setPrototypeOf(VipUser.prototype,User.prototype)\n<strong>PS: 今は Reflect.setPrototypeOf，Reflect.getPrototypeOf もできます</strong></li>\n</ol>\n</li>\n</ol>\n<h2 id="property-descriptor" tabindex="-1"><code>property descriptor</code></h2>\n<pre><code class="language-ts">interface Descriptor {\n  value: 2\n  writable: true\n  enumerable: true //for in, Object.keys() in は__proto__も見る\n  configurable: true //property descriptor変更できるかどうか\n  get: () =&gt; {}\n  set: () =&gt; {}\n}\nObject.defineProperty(obj, &quot;key&quot;, {})\n</code></pre>\n<p><strong>注: get,set と value,writable 相互排他</strong>\n<strong>get,set のおかけで、操作性の向上</strong></p>\n<h2 id="es6" tabindex="-1">ES6</h2>\n<h3 id="1.-symbol" tabindex="-1">1. symbol</h3>\n<p>略する</p>\n<h3 id="2.-iterator" tabindex="-1">2. iterator</h3>\n<pre><code class="language-ts">function next() {\n  return { done: boolen, value: T }\n}\n</code></pre>\n<p><strong>iterator protocol</strong></p>\n<p>对象 具有知名符合属性<code>symbol.iterator</code>,并且该属性是一个迭代器创建函数，iterable\nオブジェクトには<code>symbol.iterator</code>というプロパティがあり、この value は<code>next</code>。</p>\n<h3 id="3.-generator" tabindex="-1">3. generator</h3>\n<p><strong>コンストラクター Generator によって作成されたオブジェクト。enerator は iterator <code>next 付き</code> と<code>iterable object</code> (<code>[symbol.iterator]プロパティがあり</code>) の両方です`</strong></p>\n<ol>\n<li>\n<p>generator は return でき</p>\n<pre><code class="language-ts">\tfunction *g(){\n\t\tyield 2\n\t\treturn 1\n\t}\n\tconst g = g()\n\tg.next() {done: false,value:2}\n\tg.next() {done: true, value:1}\n\tg.next() {done: true,value: undefined}\n</code></pre>\n</li>\n<li>\n<p>next()は param 持ってます</p>\n<pre><code class="language-ts">\tfunction *g(){\n\t\tlet i = yield 2\n\t\tyield i + 1\n\t}\n\tconst g = g()\n\tg.next() {done: false,value:2}\n\tg.next(10) {done: true, value:11}\n\tg.next() {done: true,value: undefined}\n</code></pre>\n<p><strong>初めて の next() の param は意味ない</strong></p>\n</li>\n<li>\n<p>generator nesting</p>\n<pre><code class="language-ts">function *g(){\n\tyield 2\n\treturn 1\n}\nfunction *g2(){\n\tyield *g()\n\tyield 3\n}\nconst g = g2()\ng.next() {done: false,value:2}\ng.next() {done: false, value:3}\ng.next() {done: true,value: undefined}\n</code></pre>\n</li>\n<li>\n<p>その他\n<strong>return</strong></p>\n<pre><code class="language-ts">function* g() {\n  yield 2\n  return 1\n}\nconst g = g()\ng.return(0)\n</code></pre>\n<p><strong>throw</strong></p>\n<pre><code class="language-ts">function* g() {\n  yield 2\n  return 1\n}\nconst g = g()\ng.throw(new Error())\n</code></pre>\n</li>\n</ol>\n<h3 id="4.-reflect" tabindex="-1">4. Reflect</h3>\n<p>基礎となる関数にアクセスするため API。 関数型プログラミング</p>\n<h3 id="5.-proxy" tabindex="-1">5. proxy</h3>\n<p>vue のトラック操作やトリガー操作など、通常は Reflect と一緒に、いくつかの基礎となる操作をインターセプトします。</p>\n<pre><code class="language-ts">const targetProxy = new Proxy(target, {\n  set() {\n    const type = target.hasOwnProperty(key) ? ETriggerType.set : ETriggerType.add\n\n    const oldValue = target[key]\n    // const oldLength = Array.isArray(target) ? target.length : null\n\n    const res = Reflect.set(target, key, newValue, receiver)\n\n    if (isChanged(oldValue, newValue)) {\n      //アップデートを配布する\n      trigger({\n        target,\n        type,\n        key: key as any,\n      })\n    }\n    return res\n  },\n  get() {\n    const res = Reflect.get(target, key, receiver)\n\n    //依存関係をインターセプトして収集する\n    track({\n      target,\n      key,\n      type: ETrackType.get,\n    })\n    if (res instanceof Object &amp;&amp; typeof res === &quot;object&quot;) {\n      return reactive(res)\n    }\n    return res\n  },\n})\n</code></pre>\n<p>詳細については、「Vue」を参照してください。</p>\n',
        category: { id: 64, name: "JavaScript" },
      },
      {
        thumb: require("@/assets/CSS.png"),

        id: 4,
        title: "よく使われるCSS3のまとめ",
        description: "HTML5+CSS3 は開発エクスペリエンスを大幅に向上させました。js は非常に重要ですが、css も不可欠です。ccs3 で追加された新しいコンテンツを見てみましょう",
        scanNumber: "1",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88",
            name: "レイアウト",
            tag: "h1",
            children: [
              {
                anchor: "%E3%83%95%E3%83%AC%E3%83%83%E3%82%AF%E3%82%B9%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9",
                name: "フレックスボックス",
                tag: "h2",
                children: [
                  {
                    anchor:
                      "%E3%83%95%E3%83%AC%E3%82%AD%E3%82%B7%E3%83%96%E3%83%AB%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%81%A8%E3%83%95%E3%83%AC%E3%82%AD%E3%82%B7%E3%83%96%E3%83%AB%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B",
                    name: "フレキシブルコンテナとフレキシブルプロジェクトを生成する",
                    tag: "h3",
                    children: [],
                  },
                  { anchor: "%E6%96%B9%E5%90%91%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B", name: "方向を変える", tag: "h3", children: [] },
                  { anchor: "%E4%B8%BB%E8%BB%B8%E9%85%8D%E7%BD%AE", name: "主軸配置", tag: "h3", children: [] },
                  { anchor: "%E5%81%B4%E8%BB%B8%E9%85%8D%E7%BD%AE", name: "側軸配置", tag: "h3", children: [] },
                  {
                    anchor: "%E6%9F%94%E8%BB%9F%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0",
                    name: "柔軟なプロジェクトのスケーリング",
                    tag: "h3",
                    children: [],
                  },
                  { anchor: "%E3%82%B9%E3%83%94%E3%83%B3%E3%83%89%E3%83%AB%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%A9%E3%83%83%E3%83%97", name: "スピンドルラインラップ", tag: "h3", children: [] },
                ],
              },
              {
                anchor: "%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89",
                name: "グリッド",
                tag: "h2",
                children: [
                  {
                    anchor: "%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B",
                    name: "グリッドレイアウトを生成する",
                    tag: "h3",
                    children: [],
                  },
                  { anchor: "%E8%A1%8C%E3%81%A8%E5%88%97%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B", name: "行と列を定義する", tag: "h3", children: [] },
                  { anchor: "%E4%B8%A6%E3%81%B9%E6%9B%BF%E3%81%88%E6%96%B9%E5%90%91%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B", name: "並べ替え方向を変更する", tag: "h3", children: [] },
                  { anchor: "%E3%82%BB%E3%83%AB%E9%96%93%E3%81%AE%E3%82%AE%E3%83%A3%E3%83%83%E3%83%97", name: "セル間のギャップ", tag: "h3", children: [] },
                  { anchor: "%E3%82%BB%E3%83%AB%E5%86%85%E3%81%AE%E6%95%B4%E5%88%97", name: "セル内の整列", tag: "h3", children: [] },
                  { anchor: "%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E9%A0%85%E7%9B%AE%E3%81%AE%E9%85%8D%E7%BD%AE", name: "グリッド項目の配置", tag: "h3", children: [] },
                ],
              },
            ],
          },
          {
            anchor: "%E3%83%93%E3%82%B8%E3%83%A7%E3%83%B3",
            name: "ビジョン",
            tag: "h1",
            children: [
              {
                anchor: "%E5%BD%B1",
                name: "影",
                tag: "h2",
                children: [
                  { anchor: "%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6", name: "ボックスシャドウ", tag: "h3", children: [] },
                  { anchor: "%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6", name: "テキストシャドウ", tag: "h3", children: [] },
                ],
              },
              { anchor: "%E8%A7%92%E3%81%8C%E4%B8%B8%E3%81%84", name: "角が丸い", tag: "h2", children: [] },
              { anchor: "%E8%83%8C%E6%99%AF%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3", name: "背景のグラデーション", tag: "h2", children: [] },
              {
                anchor: "%E5%A4%89%E6%8F%9B",
                name: "変換",
                tag: "h2",
                children: [
                  { anchor: "translate", name: "translate", tag: "h3", children: [] },
                  { anchor: "scale", name: "scale", tag: "h3", children: [] },
                  { anchor: "rotate", name: "rotate", tag: "h3", children: [] },
                  { anchor: "%E5%A4%89%E5%BD%A2%E5%8E%9F%E7%82%B9%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B", name: "変形原点を変更する", tag: "h3", children: [] },
                  { anchor: "%E8%A4%87%E6%95%B0%E3%81%AE%E5%A4%89%E5%BD%A2%E3%81%AE%E9%87%8D%E3%81%AD%E5%90%88%E3%82%8F%E3%81%9B", name: "複数の変形の重ね合わせ", tag: "h3", children: [] },
                ],
              },
            ],
          },
          {
            anchor: "%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B8%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3",
            name: "トランジションとアニメーション",
            tag: "h1",
            children: [
              { anchor: "transition", name: "transition", tag: "h2", children: [] },
              { anchor: "%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3", name: "アニメーション", tag: "h2", children: [] },
            ],
          },
          {
            anchor: "%E3%81%9D%E3%81%AE%E4%BB%96",
            name: "その他",
            tag: "h1",
            children: [
              { anchor: "%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E8%A8%AD%E5%AE%9A", name: "ボックスのサイズ設定", tag: "h2", children: [] },
              { anchor: "%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3", name: "フォントアイコン", tag: "h2", children: [] },
              { anchor: "%E7%94%BB%E5%83%8F%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E3%81%AE%E9%81%A9%E5%BF%9C", name: "画像コンテンツの適応", tag: "h2", children: [] },
              { anchor: "%E3%83%93%E3%83%A5%E3%83%BC%E3%83%9D%E3%83%BC%E3%83%88%E5%8D%98%E4%BD%8D", name: "ビューポート単位", tag: "h2", children: [] },
              { anchor: "%E6%93%AC%E4%BC%BC%E8%A6%81%E7%B4%A0%E3%82%BB%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC", name: "擬似要素セレクター", tag: "h2", children: [] },
              { anchor: "%E3%82%B9%E3%83%A0%E3%83%BC%E3%82%BA%E3%81%AA%E3%82%B9%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%AB", name: "スムーズなスクロール", tag: "h2", children: [] },
            ],
          },
        ],
        htmlContent:
          '<h1 id="%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88" tabindex="-1">レイアウト</h1>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511102802.png" alt="image-20210511102549096"></p>\n<p><strong>フローティング</strong>: テキストの折り返し効果を作成します</p>\n<p><strong>フレックスボックス</strong>: 単一行または単一列のレイアウト</p>\n<p><strong>グリッド</strong>: 複数行および複数列のレイアウト</p>\n<h2 id="%E3%83%95%E3%83%AC%E3%83%83%E3%82%AF%E3%82%B9%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9" tabindex="-1">フレックスボックス</h2>\n<blockquote>\n<p>詳細なドキュメントについては、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">MDN</a> を参照してください。</p>\n<p>【フレキシブルボックスゲーム】(https://flexboxfroggy.com/)</p>\n</blockquote>\n<h3 id="%E3%83%95%E3%83%AC%E3%82%AD%E3%82%B7%E3%83%96%E3%83%AB%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%81%A8%E3%83%95%E3%83%AC%E3%82%AD%E3%82%B7%E3%83%96%E3%83%AB%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B" tabindex="-1">フレキシブルコンテナとフレキシブルプロジェクトを生成する</h3>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511112624.png" alt="image-20210511112624876"></p>\n<p><strong>デフォルトでは</strong> 弾性アイテムは主軸に沿って順番に配置され、交差軸は引き伸ばされます。</p>\n<h3 id="%E6%96%B9%E5%90%91%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B" tabindex="-1">方向を変える</h3>\n<p>スピンドルの方向は<code>flex-direction</code>で変更できます。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511112510.png" alt="image-20210511112510632"></p>\n<h3 id="%E4%B8%BB%E8%BB%B8%E9%85%8D%E7%BD%AE" tabindex="-1">主軸配置</h3>\n<p><code>justify-content</code>属性を使用すると、主軸の配置に影響を与えることができます。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511113617.png" alt="image-20210511113617325"></p>\n<h3 id="%E5%81%B4%E8%BB%B8%E9%85%8D%E7%BD%AE" tabindex="-1">側軸配置</h3>\n<p><code>align-items</code>属性を通じて、交差軸の配置に影響を与えることができます。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511114016.png" alt="image-20210511114016304"></p>\n<h3 id="%E6%9F%94%E8%BB%9F%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0" tabindex="-1">柔軟なプロジェクトのスケーリング</h3>\n<p>いわゆる伸縮性とは、<strong>弾性容器</strong>に<strong>余分な空間</strong>がある場合に<strong>主軸方向</strong>に伸ばす必要があるかどうか、および<strong>弾性容器</strong>に<strong>余裕がある</strong>場合に<strong>圧縮する必要があるかどうかを指します</strong>.スペースが不足しています<strong>柔軟な項目</strong>の <code>flex</code> 属性を使用して、伸縮率と圧縮率を設定します: <code>flex: 伸縮率、圧縮率、初期サイズ</code></p>\n<p>ストレッチの例:</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511120916.png" alt="image-20210511120916571"></p>\n<p>圧縮の例:</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511121459.png" alt="image-20210511121459341"></p>\n<p>デフォルトでは、<code>flex: 0 1 auto</code>です。</p>\n<h3 id="%E3%82%B9%E3%83%94%E3%83%B3%E3%83%89%E3%83%AB%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%A9%E3%83%83%E3%83%97" tabindex="-1">スピンドルラインラップ</h3>\n<p>デフォルトでは、スピンドルの残量が不足している場合、圧縮率に従って圧縮が行われますが、スピンドル行折り返しが設定されている場合は、圧縮は行われず、そのまま行折り返しで表示されます。</p>\n<p><code>flex-wrap:wrap</code> を <strong>flex コンテナ</strong>に設定して、主軸をラップします。</p>\n<img src="http://mdrs.yuanjin.tech/img/20210511123310.png" alt="image-20210511123310673" style="zoom:50%;" />\n<blockquote>\n<p>それにも関わらず、複数の行と列にはグリッド レイアウトが推奨されます。</p>\n</blockquote>\n<h2 id="%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89" tabindex="-1">グリッド</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout">MDN 詳細ドキュメント</a></p>\n<p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">Ruan Yifeng グリッド レイアウト チュートリアル</a></p>\n<p>【グリッドレイアウトゲーム】(https://cssgridgarden.com/)</p>\n</blockquote>\n<p><strong>グリッド レイアウトは、複数行および複数列のレイアウトの究極のソリューションです</strong></p>\n<h3 id="%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B" tabindex="-1">グリッドレイアウトを生成する</h3>\n<img src="http://mdrs.yuanjin.tech/img/20210511165317.png" alt="image-20210511165317363" style="zoom:50%;" />\n<p>コンテナがグリッド レイアウトを生成すると、そのすべての子要素は <strong>グリッド アイテム</strong>になります</p>\n<h3 id="%E8%A1%8C%E3%81%A8%E5%88%97%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B" tabindex="-1">行と列を定義する</h3>\n<p><code>grid-template-rows</code>: 行を定義します</p>\n<p><code>grid-template-columns</code>: 列を定義します</p>\n<p><strong>それらの構文は同じです</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511172305.png" alt="image-20210511172305100"></p>\n<h3 id="%E4%B8%A6%E3%81%B9%E6%9B%BF%E3%81%88%E6%96%B9%E5%90%91%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B" tabindex="-1">並べ替え方向を変更する</h3>\n<p>属性 <code>grid-auto-flow:column</code> を使用して子要素を列に配置します</p>\n<img src="http://mdrs.yuanjin.tech/img/20210511173447.png" alt="image-20210511173447321" style="zoom:50%;" />\n<h3 id="%E3%82%BB%E3%83%AB%E9%96%93%E3%81%AE%E3%82%AE%E3%83%A3%E3%83%83%E3%83%97" tabindex="-1">セル間のギャップ</h3>\n<pre><code class="language-css">row-gap: 10px; /* 行のギャップは 10px です */\ncolumn-gap: 20px; /* 列のギャップは 20px です */\ngap: 10px 20px; /* 行のギャップは 10 ピクセル、列のギャップは 20 ピクセル */\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512132025.png" alt="image-20210512132025687"></p>\n<h3 id="%E3%82%BB%E3%83%AB%E5%86%85%E3%81%AE%E6%95%B4%E5%88%97" tabindex="-1">セル内の整列</h3>\n<p>デフォルトでは、グリッド項目はセル内で水平方向と垂直方向に伸びてセルを埋め尽くします。</p>\n<p>属性 <code>justify-items</code> を使用して <strong>水平</strong> 配置を設定できます。</p>\n<p>属性 <code>align-items</code> を使用して垂直方向の配置を設定できます。</p>\n<p>それらの可能な値は同じです。</p>\n<pre><code class="language-css">justify-items: start 左 | end 右 | center 中 | stretch ストレッチ;\nalign-items: start 上 | end 下 | center 中 | stretch ストレッチ;\n</code></pre>\n<img src="http://mdrs.yuanjin.tech/img/20210511174450.png" alt="image-20210511174450356" style="zoom:50%;" />\n<p>短縮属性<code>place-items: 垂直配置水平配置</code>を使用して、両方の値を同時に設定できます。</p>\n<pre><code class="language-css">place-items: start center; /* 垂直方向は上、水平方向は中央揃え */\n</code></pre>\n<h3 id="%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E9%A0%85%E7%9B%AE%E3%81%AE%E9%85%8D%E7%BD%AE" tabindex="-1">グリッド項目の配置</h3>\n<p>デフォルトでは、グリッド項目は次々とセルに配置され、各グリッドが 1 つのセルを占有します。</p>\n<p>ただし、グリッド項目に<code>grid-area</code>属性を設定して、この動作を変更できます。</p>\n<p>使用方法:</p>\n<pre><code class="language-css">grid-area: 開始行番号/開始列番号/終了行番号/終了列番号;\n</code></pre>\n<img src="http://mdrs.yuanjin.tech/img/20210511180028.png" alt="image-20210511180027983" style="zoom:50%;" />\n<h1 id="%E3%83%93%E3%82%B8%E3%83%A7%E3%83%B3" tabindex="-1">ビジョン</h1>\n<blockquote>\n<p>いわゆるビジュアルスタイルとは、テキストの色、背景色、背景画像など、ボックスの位置やサイズに影響を与えないスタイルを指します。</p>\n</blockquote>\n<h2 id="%E5%BD%B1" tabindex="-1">影</h2>\n<h3 id="%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6" tabindex="-1">ボックスシャドウ</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>ボックス全体の影は<code>box-shadow</code>プロパティで設定できます。</p>\n<p>以下にいくつかの例を示します</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/box-shadow.html?v=2" style="height:900px;"></iframe>\n<h3 id="%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6" tabindex="-1">テキストシャドウ</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>テキストの影は<code>text-shadow</code>で設定できます。</p>\n<p>以下にいくつかの例を示します</p>\n<h3 id="%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6-1" tabindex="-1">テキストシャドウ</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>テキストの影は<code>text-shadow</code>で設定できます。</p>\n<p>以下にいくつかの例を示します</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/text-shadow.html?v=3" style="height:500px;"></iframe>\n<h2 id="%E8%A7%92%E3%81%8C%E4%B8%B8%E3%81%84" tabindex="-1">角が丸い</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><code>border-radius</code>を設定することで、ボックスの角の丸みを設定できます</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512131026.png" alt="image-20210512131026084"></p>\n<p><code>border-radius</code> はさまざまな柔軟な方法で使用でき、次のコードをページに貼り付けてテストできます。</p>\n<pre><code class="language-css">border-radius: 10px; /* 4つの角の丸みを半径10pxで同時に設定します */\nborder-radius: 50%; /* 4 つのコーナー フィレットを同時に設定します。円の水平半径は幅の半分、垂直半径は高さの半分です */\nborder-radius: 10px 20px 30px 40px; /* 左上、右上、右下、左下の角の丸みをそれぞれ設定します */\n</code></pre>\n<h2 id="%E8%A7%92%E3%81%8C%E4%B8%B8%E3%81%84-1" tabindex="-1">角が丸い</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><code>border-radius</code>を設定することで、ボックスの角の丸みを設定できます</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512131026.png" alt="image-20210512131026084"></p>\n<p><code>border-radius</code> はさまざまな柔軟な方法で使用でき、次のコードをページに貼り付けてテストできます。</p>\n<pre><code class="language-css">border-radius: 10px; /* 4つの角の丸みを半径10pxで同時に設定します */\nborder-radius: 50%; /* 4 つのコーナー フィレットを同時に設定します。円の水平半径は幅の半分、垂直半径は高さの半分です */\nborder-radius: 10px 20px 30px 40px; /* 左上、右上、右下、左下の角の丸みをそれぞれ設定します */\n</code></pre>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/border-raduis.html?v=5" style="height:550px;">\n</iframe>\n<h2 id="%E8%83%8C%E6%99%AF%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3" tabindex="-1">背景のグラデーション</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><strong>背景画像</strong>を設定する場合、<code>url()</code> を使用して背景画像を読み込むことに加えて、<code>linear-gradient()</code> 関数を使用して背景のグラデーションを設定することもできます。</p>\n<p><code>linear-gradient()</code> はグラデーション画像を作成するために使用されます。構文は次のとおりです。</p>\n<pre><code class="language-css">/* グラデーションの背景を設定します。方向: 上から下、色: #e66465 から #9198e5 までのグラデーション */\nbackground: linear-gradient(to bottom, #e66465, #9198e5);\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512135028.png" alt="image-20210512135024676"></p>\n<h2 id="%E5%A4%89%E6%8F%9B" tabindex="-1">変換</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><code>transform</code>属性を使用すると、ボックスの形状を変更できます。</p>\n<p>このアトリビュートはさまざまな変形スキームをサポートしています。一般的なものは次のとおりです。</p>\n<ul>\n<li>translate 水平移動</li>\n<li>scale ズーム</li>\n<li>rotate 回転</li>\n</ul>\n<p><strong>どの変換であっても、視覚効果が変更されるだけであり、ボックスのレイアウトには影響しません</strong></p>\n<p><strong>変換ではブラウザのリフローや再レンダリングが発生しないため、非常に効率的です</strong></p>\n<h3 id="translate" tabindex="-1">translate</h3>\n<p><code>translate</code>を使用すると、相対位置決めと同様に、ボックスが元の位置からずれる可能性があります。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512140643.png" alt="image-20210512140622630"></p>\n<h3 id="scale" tabindex="-1">scale</h3>\n<p><code>translate</code> を使用して、元の寸法に基づいてボックスのスケールを作成します。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512141500.png" alt="image-20210512141500499"></p>\n<h3 id="rotate" tabindex="-1">rotate</h3>\n<p>元の画像に基づいて回転するには、<code>rotate</code>属性を使用します</p>\n<pre><code class="language-css">/* 元の画像を元に、時計回りに 45 度回転します */\ntransform: rotate(45deg);\n/* 元の画像を元に、時計回りに半回転します */\ntransform: rotate(0.5turn);\n</code></pre>\n<p>下のボタンをクリックして回転効果を試すことができます</p>\n<h2 id="%E8%83%8C%E6%99%AF%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3-1" tabindex="-1">背景のグラデーション</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><strong>背景画像</strong>を設定する場合、<code>url()</code> を使用して背景画像を読み込むことに加えて、<code>linear-gradient()</code> 関数を使用して背景のグラデーションを設定することもできます。</p>\n<p><code>linear-gradient()</code> はグラデーション画像を作成するために使用されます。構文は次のとおりです。</p>\n<pre><code class="language-css">/* グラデーションの背景を設定します。方向: 上から下、色: #e66465 から #9198e5 までのグラデーション */\nbackground: linear-gradient(to bottom, #e66465, #9198e5);\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512135028.png" alt="image-20210512135024676"></p>\n<h2 id="%E5%A4%89%E6%8F%9B-1" tabindex="-1">変換</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><code>transform</code>属性を使用すると、ボックスの形状を変更できます。</p>\n<p>このアトリビュートはさまざまな変形スキームをサポートしています。一般的なものは次のとおりです。</p>\n<ul>\n<li>translate 水平移動</li>\n<li>scale ズーム</li>\n<li>rotate 回転</li>\n</ul>\n<p><strong>どの変換であっても、視覚効果が変更されるだけであり、ボックスのレイアウトには影響しません</strong></p>\n<p><strong>変換ではブラウザのリフローや再レンダリングが発生しないため、非常に効率的です</strong></p>\n<h3 id="translate-1" tabindex="-1">translate</h3>\n<p><code>translate</code>を使用すると、相対位置決めと同様に、ボックスが元の位置からずれる可能性があります。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512140643.png" alt="image-20210512140622630"></p>\n<h3 id="scale-1" tabindex="-1">scale</h3>\n<p><code>translate</code> を使用して、元の寸法に基づいてボックスのスケールを作成します。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512141500.png" alt="image-20210512141500499"></p>\n<h3 id="rotate-1" tabindex="-1">rotate</h3>\n<p>元の画像に基づいて回転するには、<code>rotate</code>属性を使用します</p>\n<pre><code class="language-css">/* 元の画像を元に、時計回りに 45 度回転します */\ntransform: rotate(45deg);\n/* 元の画像を元に、時計回りに半回転します */\ntransform: rotate(0.5turn);\n</code></pre>\n<p>下のボタンをクリックして回転効果を試すことができます</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/rotate.html" style="height:400px;">\n</iframe>\n<h3 id="%E5%A4%89%E5%BD%A2%E5%8E%9F%E7%82%B9%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B" tabindex="-1">変形原点を変更する</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>変形原点の位置は、特定の変形動作に影響します。</p>\n<p>デフォルトでは、変換の原点はボックスの中心にありますが、<code>transform-origin</code> で変更できます。</p>\n<pre><code class="language-css">transform-origin: center; /* 原点をボックスの中心に設定します */\ntransform-origin: left top; /* 原点をボックスの左上隅に設定します */\ntransform-origin: right bottom; /* 原点をボックスの右下隅に設定します */\ntransform-origin: 30px 60px; /* 原点をボックス座標 (30, 60) に設定します */\n</code></pre>\n<p>試してみてください。まず [原点を設定] ボタンをクリックして原点 (図の赤い点でマーク) を設定し、次に [変形] ボタンをクリックして変形します。</p>\n<h3 id="%E5%A4%89%E5%BD%A2%E5%8E%9F%E7%82%B9%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B-1" tabindex="-1">変形原点を変更する</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>変形原点の位置は、特定の変形動作に影響します。</p>\n<p>デフォルトでは、変換の原点はボックスの中心にありますが、<code>transform-origin</code> で変更できます。</p>\n<pre><code class="language-css">transform-origin: center; /* 原点をボックスの中心に設定します */\ntransform-origin: left top; /* 原点をボックスの左上隅に設定します */\ntransform-origin: right bottom; /* 原点をボックスの右下隅に設定します */\ntransform-origin: 30px 60px; /* 原点をボックス座標 (30, 60) に設定します */\n</code></pre>\n<p>試してみてください。まず [原点を設定] ボタンをクリックして原点 (図の赤い点でマーク) を設定し、次に [変形] ボタンをクリックして変形します。</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/transform-origin.html?v2" style="height:600px;"></iframe>\n<h3 id="%E8%A4%87%E6%95%B0%E3%81%AE%E5%A4%89%E5%BD%A2%E3%81%AE%E9%87%8D%E3%81%AD%E5%90%88%E3%82%8F%E3%81%9B" tabindex="-1">複数の変形の重ね合わせ</h3>\n<p>複数のデフォメーション効果を一度に設定可能</p>\n<pre><code class="language-css">/* まず 45 度回転し、次に (100,100) を移動します */\ntransform: rotate(45deg) translate(100px, 100px);\n/* まず平行移動 (100, 100) し、次に 45 度回転します */\ntransform: translate(100px, 100px) rotate(45deg);\n</code></pre>\n<p>注: 回転すると座標系も回転するため、その後の変形効果に影響を与える可能性があります。</p>\n<p>次の例はこの点をよく示しています</p>\n<h3 id="%E8%A4%87%E6%95%B0%E3%81%AE%E5%A4%89%E5%BD%A2%E3%81%AE%E9%87%8D%E3%81%AD%E5%90%88%E3%82%8F%E3%81%9B-1" tabindex="-1">複数の変形の重ね合わせ</h3>\n<p>複数のデフォメーション効果を一度に設定可能</p>\n<pre><code class="language-css">/* まず 45 度回転し、次に (100,100) を移動します */\ntransform: rotate(45deg) translate(100px, 100px);\n/* まず平行移動 (100, 100) し、次に 45 度回転します */\ntransform: translate(100px, 100px) rotate(45deg);\n</code></pre>\n<p>注: 回転すると座標系も回転するため、その後の変形効果に影響を与える可能性があります。</p>\n<p>次の例はこの点をよく示しています</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/multi-transform.html" style="height:600px;"></iframe>\n<h1 id="%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B8%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3" tabindex="-1">トランジションとアニメーション</h1>\n<p>トランジションとアニメーションを使用して CSS プロパティの変更をよりスムーズに行う</p>\n<p><strong>トランジションとアニメーションは、すべての CSS プロパティに影響を与えることはできません</strong>、色、幅と高さ、フォント サイズなどの数値プロパティにのみ影響します。</p>\n<h2 id="transition" tabindex="-1">transition</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<pre><code class="language-css">transition: 遷移属性の持続時間 遷移関数の遷移遅延。;\n</code></pre>\n<ul>\n<li><strong>transition プロパティ</strong></li>\n</ul>\n<p>トランジションを適用する CSS プロパティ。たとえば、<code>transform</code>と入力すると、トランジションが <strong>transform</strong> 属性にのみ適用されることを意味します。</p>\n<p><code>all</code>を入力するか空白のままにすると、トランジションがすべての CSS 属性に適用されることを意味します。</p>\n<ul>\n<li><strong>間隔</strong></li>\n</ul>\n<p>CSS プロパティの変更の継続時間は単位である必要があります。たとえば、<code>3s</code>は 3 秒を意味し、<code>0.5s</code>または<code>500ms</code>は 500 ミリ秒を意味します。</p>\n<ul>\n<li><strong>遷移関数</strong></li>\n</ul>\n<p>これは本質的に CSS プロパティを変更するベジェ曲線関数であり、通常はプリセット値を直接使用します。</p>\n<p><code>ease-in-out</code>: スムーズな開始、スムーズな終了</p>\n<p><code>linear</code>: 線形変化</p>\n<p><code>ease-in</code>: スムーズなスタートのみ</p>\n<p><code>ease-out</code>: スムーズなエンディングのみ</p>\n<ul>\n<li><strong>移行遅延</strong></li>\n</ul>\n<p>記述ルールはデュレーションと同じで、トランジションエフェクトがトリガーされるまでの遅延時間を示します。これが入力されていない場合、遅延は発生しません。</p>\n<p><strong>JS では、要素の <code>transitionstart</code> および <code>transitionend</code> イベントをリッスンして、トランジションの開始時と終了時に別のことを行うことができます</strong></p>\n<h2 id="%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3" tabindex="-1">アニメーション</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><strong>アニメーションの本質は、事前定義された一連の CSS 変更ルールと、そのルールに名前を付けることです</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210513172902.png" alt="image-20210513172902413"></p>\n<p>その後、他の要素は次のようなルールを使用できます。</p>\n<pre><code class="language-css">animation: ルール名の長さ;\n</code></pre>\n<p>ルールを適用するときに詳細情報を指定することもできます</p>\n<pre><code class="language-css">animation: ルール名、継続時間、繰り返し回数、時間関数、アニメーションの方向、遅延時間;\n</code></pre>\n<p>いくつかの詳細:</p>\n<ul>\n<li>ルールを定義する場合、<code>0%</code>を<code>from</code>として記述できます</li>\n<li>ルールを定義する場合、<code>100%</code>を<code>to</code>と書くことができます。</li>\n<li>繰り返し回数が<code>無限</code>の場合、無限繰り返しを意味します</li>\n<li>アニメーションの方向が<code>交互</code>の場合、交互の逆方向を意味します。1 回目は順方向、2 回目は逆方向、3 回目は順方向、4 回目は逆方向、というようになります。</li>\n</ul>\n<p><strong>JS では、要素の <code>animationstart</code> および <code>animationnend</code> イベントをリッスンして、トランジションの開始時と終了時に別の処理を行うことができます</strong></p>\n<h1 id="%E3%81%9D%E3%81%AE%E4%BB%96" tabindex="-1">その他</h1>\n<h2 id="%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E8%A8%AD%E5%AE%9A" tabindex="-1">ボックスのサイズ設定</h2>\n<p>百聞は一見に如かず</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514150015.png" alt="image-20210514150015660"></p>\n<p>サイズを制御するには<code>border-box</code>を使用する方がより直感的であるため、多くの Web サイトでは次のコードを追加します。</p>\n<pre><code class="language-css">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2 id="%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3" tabindex="-1">フォントアイコン</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN font-face ディレクティブ</a></p>\n</blockquote>\n<p>css3 には <code>font-face</code> ディレクティブが追加されており、Web フォントをロードできるようになります。</p>\n<p>最も一般的なアプリケーションはフォント アイコンです。</p>\n<p><strong>フォント アイコンは基本的にテキストです。つまり、色は <code>color</code> によって設定され、サイズは <code>font-size</code> によって設定されます</strong></p>\n<p>中国で最も一般的に使用されているフォント アイコン プラットフォームは [Alibaba Vector Icon Library] (https://www.iconfont.cn/) です。</p>\n<p>プラットフォームにログインすると、すべてのフォントアイコンを無料で使用できます</p>\n<h2 id="%E7%94%BB%E5%83%8F%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E3%81%AE%E9%81%A9%E5%BF%9C" tabindex="-1">画像コンテンツの適応</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>css3 属性 <code>object-fit</code> は、マルチメディア コンテンツと要素が適応する方法を制御できます。これは通常、<code>img</code> 要素または <code>video</code> 要素で使用されます。</p>\n<p>百聞は一見に如かず</p>\n<p>下の図のすべての <code>img</code> 要素は幅と高さが固定されており、img からはみ出した部分は実際には表示されません。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514134908.png" alt="image-20210514134908778"></p>\n<h2 id="%E3%83%93%E3%83%A5%E3%83%BC%E3%83%9D%E3%83%BC%E3%83%88%E5%8D%98%E4%BD%8D" tabindex="-1">ビューポート単位</h2>\n<p>css3 は、それぞれ<code>ビューポートの幅</code>と<code>ビューポートの高さ</code>を表す単位として<code>vw</code>と<code>vh</code>の使用をサポートしています。</p>\n<p>たとえば、<code>1vh</code>はビューポートの高さの<code>1%</code>を表し、<code>100vw</code>はビューポートの幅の<code>100%</code>を表します。</p>\n<h2 id="%E6%93%AC%E4%BC%BC%E8%A6%81%E7%B4%A0%E3%82%BB%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC" tabindex="-1">擬似要素セレクター</h2>\n<p><code>::before</code> および <code>::after</code> セレクターを使用すると、CSS を通じて 1 つの要素に対して 2 つの子要素を生成できます。</p>\n<img src="http://mdrs.yuanjin.tech/img/20210514140049.png" alt="image-20210514140049244" style="zoom:50%;" />\n<p>疑似要素を使用して、HTML 内で空の要素が多すぎることを避ける</p>\n<p><strong>疑似要素には <code>content</code> 属性が必要です。コンテンツが必要ない場合は、<code>content:\'\'</code> を設定します。</strong></p>\n<h2 id="%E3%82%B9%E3%83%A0%E3%83%BC%E3%82%BA%E3%81%AA%E3%82%B9%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%AB" tabindex="-1">スムーズなスクロール</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>スクロールをよりスムーズにするには <code>scroll-behavior:smooth</code> を使用します</p>\n<p>MDN 効果を参照</p>\n<h1 id="%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B8%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3-1" tabindex="-1">トランジションとアニメーション</h1>\n<p>トランジションとアニメーションを使用して CSS プロパティの変更をよりスムーズに行う</p>\n<p><strong>トランジションとアニメーションは、すべての CSS プロパティに影響を与えることはできません</strong>、色、幅と高さ、フォント サイズなどの数値プロパティにのみ影響します。</p>\n<h2 id="transition-1" tabindex="-1">transition</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<pre><code class="language-css">transition: 遷移属性の持続時間 遷移関数の遷移遅延。;\n</code></pre>\n<ul>\n<li><strong>transition プロパティ</strong></li>\n</ul>\n<p>トランジションを適用する CSS プロパティ。たとえば、<code>transform</code>と入力すると、トランジションが <strong>transform</strong> 属性にのみ適用されることを意味します。</p>\n<p><code>all</code>を入力するか空白のままにすると、トランジションがすべての CSS 属性に適用されることを意味します。</p>\n<ul>\n<li><strong>間隔</strong></li>\n</ul>\n<p>CSS プロパティの変更の継続時間は単位である必要があります。たとえば、<code>3s</code>は 3 秒を意味し、<code>0.5s</code>または<code>500ms</code>は 500 ミリ秒を意味します。</p>\n<ul>\n<li><strong>遷移関数</strong></li>\n</ul>\n<p>これは本質的に CSS プロパティを変更するベジェ曲線関数であり、通常はプリセット値を直接使用します。</p>\n<p><code>ease-in-out</code>: スムーズな開始、スムーズな終了</p>\n<p><code>linear</code>: 線形変化</p>\n<p><code>ease-in</code>: スムーズなスタートのみ</p>\n<p><code>ease-out</code>: スムーズなエンディングのみ</p>\n<ul>\n<li><strong>移行遅延</strong></li>\n</ul>\n<p>記述ルールはデュレーションと同じで、トランジションエフェクトがトリガーされるまでの遅延時間を示します。これが入力されていない場合、遅延は発生しません。</p>\n<p><strong>JS では、要素の <code>transitionstart</code> および <code>transitionend</code> イベントをリッスンして、トランジションの開始時と終了時に別のことを行うことができます</strong></p>\n<h2 id="%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3-1" tabindex="-1">アニメーション</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><strong>アニメーションの本質は、事前定義された一連の CSS 変更ルールと、そのルールに名前を付けることです</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210513172902.png" alt="image-20210513172902413"></p>\n<p>その後、他の要素は次のようなルールを使用できます。</p>\n<pre><code class="language-css">animation: ルール名の長さ;\n</code></pre>\n<p>ルールを適用するときに詳細情報を指定することもできます</p>\n<pre><code class="language-css">animation: ルール名、継続時間、繰り返し回数、時間関数、アニメーションの方向、遅延時間;\n</code></pre>\n<p>いくつかの詳細:</p>\n<ul>\n<li>ルールを定義する場合、<code>0%</code>を<code>from</code>として記述できます</li>\n<li>ルールを定義する場合、<code>100%</code>を<code>to</code>と書くことができます。</li>\n<li>繰り返し回数が<code>無限</code>の場合、無限繰り返しを意味します</li>\n<li>アニメーションの方向が<code>交互</code>の場合、交互の逆方向を意味します。1 回目は順方向、2 回目は逆方向、3 回目は順方向、4 回目は逆方向、というようになります。</li>\n</ul>\n<p><strong>JS では、要素の <code>animationstart</code> および <code>animationnend</code> イベントをリッスンして、トランジションの開始時と終了時に別の処理を行うことができます</strong></p>\n<h1 id="%E3%81%9D%E3%81%AE%E4%BB%96-1" tabindex="-1">その他</h1>\n<h2 id="%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E8%A8%AD%E5%AE%9A-1" tabindex="-1">ボックスのサイズ設定</h2>\n<p>百聞は一見に如かず</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514150015.png" alt="image-20210514150015660"></p>\n<p>サイズを制御するには<code>border-box</code>を使用する方がより直感的であるため、多くの Web サイトでは次のコードを追加します。</p>\n<pre><code class="language-css">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2 id="%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3-1" tabindex="-1">フォントアイコン</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN font-face ディレクティブ</a></p>\n</blockquote>\n<p>css3 には <code>font-face</code> ディレクティブが追加されており、Web フォントをロードできるようになります。</p>\n<p>最も一般的なアプリケーションはフォント アイコンです。</p>\n<p><strong>フォント アイコンは基本的にテキストです。つまり、色は <code>color</code> によって設定され、サイズは <code>font-size</code> によって設定されます</strong></p>\n<p>中国で最も一般的に使用されているフォント アイコン プラットフォームは [Alibaba Vector Icon Library] (https://www.iconfont.cn/) です。</p>\n<p>プラットフォームにログインすると、すべてのフォントアイコンを無料で使用できます</p>\n<h2 id="%E7%94%BB%E5%83%8F%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E3%81%AE%E9%81%A9%E5%BF%9C-1" tabindex="-1">画像コンテンツの適応</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>css3 属性 <code>object-fit</code> は、マルチメディア コンテンツと要素が適応する方法を制御できます。これは通常、<code>img</code> 要素または <code>video</code> 要素で使用されます。</p>\n<p>百聞は一見に如かず</p>\n<p>下の図のすべての <code>img</code> 要素は幅と高さが固定されており、img からはみ出した部分は実際には表示されません。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514134908.png" alt="image-20210514134908778"></p>\n<h2 id="%E3%83%93%E3%83%A5%E3%83%BC%E3%83%9D%E3%83%BC%E3%83%88%E5%8D%98%E4%BD%8D-1" tabindex="-1">ビューポート単位</h2>\n<p>css3 は、それぞれ<code>ビューポートの幅</code>と<code>ビューポートの高さ</code>を表す単位として<code>vw</code>と<code>vh</code>の使用をサポートしています。</p>\n<p>たとえば、<code>1vh</code>はビューポートの高さの<code>1%</code>を表し、<code>100vw</code>はビューポートの幅の<code>100%</code>を表します。</p>\n<h2 id="%E6%93%AC%E4%BC%BC%E8%A6%81%E7%B4%A0%E3%82%BB%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC-1" tabindex="-1">擬似要素セレクター</h2>\n<p><code>::before</code> および <code>::after</code> セレクターを使用すると、CSS を通じて 1 つの要素に対して 2 つの子要素を生成できます。</p>\n<img src="http://mdrs.yuanjin.tech/img/20210514140049.png" alt="image-20210514140049244" style="zoom:50%;" />\n<p>疑似要素を使用して、HTML 内で空の要素が多すぎることを避ける</p>\n<p><strong>疑似要素には <code>content</code> 属性が必要です。コンテンツが必要ない場合は、<code>content:\'\'</code> を設定します。</strong></p>\n<h2 id="%E3%82%B9%E3%83%A0%E3%83%BC%E3%82%BA%E3%81%AA%E3%82%B9%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%AB-1" tabindex="-1">スムーズなスクロール</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>スクロールをよりスムーズにするには <code>scroll-behavior:smooth</code> を使用します</p>\n<p>MDN 効果を参照</p>\n',
        category: { id: 65, name: "CSS" },
      },
      {
        thumb: require("@/assets/Webpack.png"),

        id: 5,
        title: "webpack原理",
        description: "クラシックなエンジニアリング パッケージング ツールの原理を理解する",
        scanNumber: "0",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "webpack",
            name: "webpack",
            tag: "h1",
            children: [
              { anchor: "%E3%81%AA%E3%81%9C%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E5%8C%96", name: "なぜエンジニア化", tag: "h2", children: [] },
              { anchor: "%E5%8E%9F%E7%90%86", name: "原理", tag: "h2", children: [] },
              {
                anchor: "%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E5%8E%9F%E7%90%86",
                name: "コンパイル原理",
                tag: "h2",
                children: [
                  { anchor: "1.-%E5%88%9D%E6%9C%9F%E5%8C%96", name: "1. 初期化", tag: "h3", children: [] },
                  { anchor: "2.-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB", name: "2. コンパイル", tag: "h3", children: [] },
                  { anchor: "3.-emit", name: "3. emit", tag: "h3", children: [] },
                ],
              },
              { anchor: "loader", name: "loader", tag: "h2", children: [] },
              { anchor: "plugins", name: "plugins", tag: "h2", children: [] },
              { anchor: "webpack.config", name: "webpack.config", tag: "h2", children: [] },
            ],
          },
        ],
        htmlContent:
          '<h1 id="webpack" tabindex="-1">webpack</h1>\n<h2 id="%E3%81%AA%E3%81%9C%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E5%8C%96" tabindex="-1">なぜエンジニア化</h2>\n<p><strong>注: ノード環境はローカル ファイルを読み取るため、この問題は発生しません</strong>\n<code>devtime</code>:</p>\n<ol>\n<li>モジュールの粒度が細かい</li>\n<li>さまざまなモジュール標準 <strong>CommonJs、ESModule</strong> を直接実装する</li>\n<li>新しい構文 <strong>ESNext</strong> を使用する</li>\n</ol>\n<p><code>runtime</code>:</p>\n<ol>\n<li>ファイルが少ないほど良い: リクエストも少なくなる 2.小 ​​ さいサイズ: 圧縮</li>\n<li>乱雑であればあるほど良い: ロジックを改ざんしたくないし、コピーされたくない。</li>\n<li>高い執行効率</li>\n</ol>\n<h2 id="%E5%8E%9F%E7%90%86" tabindex="-1">原理</h2>\n<p>コンパイル結果</p>\n<pre><code class="language-ts">//関数環境を通じてグローバル変数を汚染しないようにする\n;(function (modules) {\n  const cachedModules = {}\n  //ノード環境と同様の require を定義し、js コードを実行して、エクスポートを返します。\n  function __webpack_require(path) {\n    if (cachedModules[path]) {\n      return cachedModules[path].exports\n    }\n    const module = (cachedModules[path] = {\n      id: path,\n      loaded: false,\n      exports: {},\n    })\n    const exports = module.exports\n    modules[path].call(exports, module, exports, __webpack_require)\n    module.loaded = true\n    return module.exports\n  }\n  __webpack_require.entry = &quot;&quot;\n  __webpack_require.cache = cachedModules\n  return __webpack_require((__webpack_require.entry = &quot;./src/index.js&quot;))\n})({\n  //ノード環境と同様の Commonjs インポート\n  // _temp(module,exports, require,__dirname,__filename)只能说除了__dirname,__filename,都一样\n  &quot;./src/a.js&quot;: function (module, exports, require) {\n    //  const a = 1\n    //  console.log(a);\n    //  module.exports = {\n    // \ta\n    //  }\n    //ただし、これを行うと、使用されるコンソール出力が現在の js になります。\n    //これは絶対によくないです。eval は新しい仮想環境を開くことと同じです。\n    eval(\n      `\n\t\t\tconst a = 1\n\t\t\tconsole.log(a);\n\t\t\tmodule.exports = {\n\t\t\t   a\n\t\t\t} \n\t\t\t` + &quot;//# sourceURL=webpack:///./src/a.js?&quot;\n    )\n  },\n  &quot;./src/b.js&quot;: function (module, exports, require) {\n    const b = 2\n    exports.b = 2\n  },\n  &quot;./src/index.js&quot;: function (module, exports, require) {\n    const a = require(&quot;./src/a.js&quot;)\n    const b = require(&quot;./src/b.js&quot;)\n    console.log(a)\n    console.log(b)\n  },\n})\n</code></pre>\n<h2 id="%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E5%8E%9F%E7%90%86" tabindex="-1">コンパイル原理</h2>\n<h3 id="1.-%E5%88%9D%E6%9C%9F%E5%8C%96" tabindex="-1">1. 初期化</h3>\n<p><strong>ビルド</strong></p>\n<p>CSS の<code>computed style</code>と同様に、cli パラメーター、webpack.config.js、およびデフォルト設定がマージされて、最終的な設定オブジェクトが生成されます。<code>yargs</code> ライブラリに依存する。</p>\n<h3 id="2.-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB" tabindex="-1">2. コンパイル</h3>\n<ol>\n<li><code>chunk</code>を作る\n<strong>what’s chunk?</strong>\nentry に従って、すべての依存関係を見つけます。各 entry は chunk に対応します</li>\n</ol>\n<pre><code class="language-ts">interface chunk {\n  name: &quot;main&quot; //メインのentry\n  id: string //開発環境はnameであり、本番環境は数字になります。\n  hash: string //chunk assetsを生成するとき,すべてのファイルの内容に基づいてchunk hashが生成されます。\n}\n</code></pre>\n<ol start="2">\n<li>依存関係を構築</li>\n</ol>\n<pre><code class="language-ts">interface IChunkModules {\n  //通常、これはパスです。完全な相対パスを均一に変換します，./src/**/* ./node_modules/**/*\n  [moduleId: string]: string //转换后的代码\n}\nconst moduleCache: IChunkModules = {}\nfunction createDepencies(entryPath) {\n  //1. モジュールがロードされているかどうかを確認する\n  if (moduleCache[entryPath]) {\n    return\n  }\n  //2. 解析\n  // 1) コンテンツを読む\n  const content = fs.readFileSync(entryPath)\n  // 2) AST分析 これはツリー構造です\n  const astResult = AST(content)\n  // 3) ツリーをloop，すべての依存関係を取得する(require,import),完全な相対パスとして記録される\n  const dependencies: string[] = loopTree(astResult)\n  // 4) 依存関数を置き換える require=&gt;__webpack_require\n  // 5）置き換えたコードを保存します\n  moduleCache[entryPath] = content.replaceAll(&quot;require&quot;, &quot;__webpack_require&quot;) //肯定不能这样写吧\n  // 6) 再帰dependencies,深さ優先\n  dependencies.forEach((path) =&gt; createDepencies(path))\n}\n</code></pre>\n<ol start="3">\n<li><code>chunk assets</code>を作成\n<code>chunk</code>のモジュールに基づいてリソース リストを生成します。各項目は特定のファイルに対応します。<code>bundle</code>とも呼ばれます</li>\n</ol>\n<pre><code class="language-ts">{\n\t[ファイル名: string]:文件内容\n\t\'./dist/bundle.js\':(function (modules){})({\n\t   \'./src/a.js\':function (module,exports,require){\n\t\t\teval(`\n\t\t\tconst a = 1\n\t\t\tconsole.log(a);\n\t\t\tmodule.exports = {\n\t\t\t   a\n\t\t\t}\n\t\t\t`+&quot;//# sourceURL=webpack:///./src/a.js?&quot;);\n\t\t},\n})\n</code></pre>\n<ol start="4">\n<li>chunk assets マージ\nchunk assets をマージして,総 hash を生成する</li>\n</ol>\n<h3 id="3.-emit" tabindex="-1">3. emit</h3>\n<p>fs を通じて chunk assets を emit</p>\n<h2 id="loader" tabindex="-1">loader</h2>\n<p>本质: ファイル内容=&gt;js 内容</p>\n<p>config</p>\n<pre><code class="language-ts">  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/, //pathマッチ\n        use: [\n          {\n            loader: [&quot;ts-loader&quot;],\n            options: {\n\t\t\t\t//Param\n\t\t\t},\n          },\n        ],\n        exclude: /node_modules/,\n      },\n    ],\n  },\n</code></pre>\n<p><strong>注:loaders は後ろから呼び出す。 decorator と同じ</strong></p>\n<pre><code class="language-ts">{\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        use: [&quot;./src/loaders/testloader/loader&quot;, &quot;./src/loaders/testloader/loader2&quot;],\n      },\n      {\n        test: /test\\.js/,\n        use: [&quot;./src/loaders/testloader/loader3&quot;, &quot;./src/loaders/testloader/loader2&quot;],\n      },\n    ]\n  }\n}\n\n// 结果\n2\n3\n2\n1\n\n// 原理\n\nlet fscontent = xxx\nconst rules = []\n///\\.js/マッチ成功\nrules.push(...[&quot;./src/loaders/testloader/loader&quot;, &quot;./src/loaders/testloader/loader2&quot;])\n///test\\.js/ マッチ成功\nrules.push(...[&quot;./src/loaders/testloader/loader3&quot;, &quot;./src/loaders/testloader/loader2&quot;])\n\nfor (let i = rules.length - 1; i + 1; i--) {\n  const loader = require(rules[i])\n  //fs の読み取り内容をローダーに渡します\n  fscontent = loader(fscontent)\n}\nreturn fscontent\n</code></pre>\n<p>例 css loader</p>\n<pre><code class="language-ts">//entry.js\nrequire(&quot;./style/index.css&quot;)\n//require 自体は CSS を読み取れない必要があります\n//Webpack はファイルの内容を確実に読み取ることができます。抽象 AST 解析でエラーが発生します。\n//つまり、ローダー経由でのみ、ファイルの内容 =&gt; 解析できません (js 内容)\n\n// webpack.config.js\n//\n {\n        test: /\\.css/,\n        use: [&quot;./src/loaders/cssLoader&quot;],\n }\n\n //loader\n module.exports = function (sourceCode) {\n  const res = `\n    const style = document.createElement(&quot;style&quot;)\n    style.innerHTML = \\`${sourceCode}\\`\n    document.head.appendChild(style)\n    module.exports = \\`${sourceCode}\\`\n  `\n  //   console.log(res)\n  return res\n}\n</code></pre>\n<h2 id="plugins" tabindex="-1">plugins</h2>\n<p>loaders とは異なり、plugins は、Webpack コンパイル プロセスで hooks を処理するために使用されます。</p>\n<pre><code class="language-ts">import { Compilation, Compiler } from &quot;webpack&quot;\n\nclass Compiler {\n  //初期化フェーズで作成される\n  //コンパイルと出力操作は内部で作成された Compilation によって完了します\n  // 監視時に再コンパイルするとコンパイルが再作成されるだけです\n}\n//バンドルサイズをカウントするプラグイン\nclass MyPlugin {\n  //コンパイラを作成した後、apply が実行されます。\n  apply(compiler: Compiler) {\n    compiler.hooks.emit.tap(&quot;MyFilePlugin&quot;, (compilation) =&gt; {\n      const assets = Object.keys(compilation.assets)\n      const res = assets\n        .map((x) =&gt; {\n          const size = compilation.assets[x].size()\n\n          return `[${x}]:\n    \t  size:${size / 1000}kb\n    \t`\n        })\n        .join(&quot;\\n\\n&quot;)\n      compilation.assets[this.filmeName] = {\n        source() {\n          return res\n        },\n        size() {\n          return Buffer.from(res).byteLength\n        },\n      }\n    })\n  }\n}\n</code></pre>\n<h2 id="webpack.config" tabindex="-1">webpack.config</h2>\n<p>関数も使える</p>\n<pre><code class="language-ts">module.export = (env) =&gt; {\n  return {\n    entry: {\n      main: &quot;./src/index.js&quot;,\n    },\n  }\n}\n</code></pre>\n',
        category: { id: 67, name: "Webpack" },
      },
      {
        thumb: require("@/assets/HTTP.png"),

        id: 1,
        title: "HTTP および HTTPS プロトコル",
        description: "HTTP および HTTPS プロトコルを理解し、ネットワーク リクエストの原則を学ぶ",
        scanNumber: "0",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "http",
            name: "http",
            tag: "h1",
            children: [
              { anchor: "c%2Fs-b%2Fs", name: "c/s b/s", tag: "h2", children: [] },
              { anchor: "url-uniform-resource-location", name: "url uniform resource location", tag: "h2", children: [] },
              {
                anchor: "http-protocol-tcp%2Fip-%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99",
                name: "http protocol TCP/IP に基づいています",
                tag: "h2",
                children: [
                  { anchor: "request", name: "Request", tag: "h3", children: [] },
                  { anchor: "response", name: "Response", tag: "h3", children: [] },
                  { anchor: "ajax-webapi", name: "ajax webApi", tag: "h3", children: [] },
                ],
              },
              {
                anchor: "https-protocol-tcp%2Fip%E3%80%81ssl-%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99",
                name: "https protocol TCP/IP、SSL に基づいています",
                tag: "h2",
                children: [{ anchor: "%E6%9A%97%E5%8F%B7%E5%8C%96%E6%96%B9%E5%BC%8F", name: "暗号化方式", tag: "h3", children: [] }],
              },
            ],
          },
        ],
        htmlContent:
          '<h1 id="http" tabindex="-1">http</h1>\n<h2 id="c%2Fs-b%2Fs" tabindex="-1">c/s b/s</h2>\n<p><code>client(クライアント)</code> <code>browser(ブラウザ)</code> <code>browserサーバー</code>\nサーバーは特定のポートをリッスンするアプリケーションです\nクライアントは単なるアプリケーションです\nリクエストを発行するのはクライアントです\nサーバーは Response に応答します</p>\n<h2 id="url-uniform-resource-location" tabindex="-1">url <code>uniform resource location</code></h2>\n<p>構成</p>\n<p>http://www.baidu.com/s?wd=test#home\n<code>schema/protocol</code>:http\n<code>host</code>: www.baidu.com (または ip)\n<code>port</code>: 80\n<code>path</code>:/s\n<code>params</code>:?wd=test\n<code>hash</code>:#home</p>\n<h2 id="http-protocol-tcp%2Fip-%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99" tabindex="-1">http protocol <code>TCP/IP に基づいています</code></h2>\n<ol>\n<li>各リクエストとレスポンスは独立しています。。</li>\n<li>渡されるメッセージはすべて<code>string</code>で、形式は次のとおりです。</li>\n</ol>\n<h3 id="request" tabindex="-1">Request</h3>\n<pre><code class="language-ts">   request line   post  /api/user  HTTP/1.1\n   request header Content-Type: application/json\n                  User-Agent: Molila5.0 ………………\n\t\t\t\t  HOST:\n\t\t\t\t  origin:\n\t\t\t\t  Connection:\n\n   request Body   {\n\t                 id:xxxx\n                  }\n\n</code></pre>\n<p>従来のルール,<code>get</code>と<code>delete</code>は body 持ってません。params しかつかえません。\n<code>post</code>と <code>put</code>は body 持ってます。</p>\n<p><strong>Content-Type</strong></p>\n<ol>\n<li>\n<p>x-www-form-urlencoded</p>\n<pre><code class="language-ts">id = xxx\n</code></pre>\n</li>\n<li>\n<p>json</p>\n<pre><code class="language-ts">{\n  id: xxx\n}\n</code></pre>\n</li>\n<li>\n<p>form-data</p>\n</li>\n</ol>\n<p>​ ファイルアップロードにもちいてます。</p>\n<h3 id="response" tabindex="-1">Response</h3>\n<pre><code class="language-ts">   response line    HTTP/1.1 200 Ok\n   response header  Content-Type: text/html;charset=utf-8\n                    Server: BWS/1.1\n\n   response body    &lt;html&gt;&lt;/html&gt;\n\n</code></pre>\n<p><strong>応答コード</strong>\n<code>1**</code> message サーバーはリクエストを受信し、クライアントが送信を続ける必要があります。\n<code>2**</code> success\n<code>3**</code> redirect\n<code>4**</code> client error\n<code>5**</code> server error</p>\n<h3 id="ajax-webapi" tabindex="-1">ajax <code>webApi</code></h3>\n<pre><code class="language-ts">//ネイティブajax\nconst xhr = new XMLHttpRequest()\n\nxhr.onreadystatechange = function () {\n  switch (xhr.readyState) {\n    case 1:\n      console.log(&quot;open execute&quot;)\n      break\n    case 2:\n      console.log(&quot;send method execute&quot;)\n      break\n    case 3:\n      console.log(&quot;receiving response body&quot;)\n      break\n    case 4:\n      console.log(&quot;received all response&quot;)\n      const res = JSON.parse(xhr.responseText)\n      break\n  }\n}\n\nxhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/json&quot;)\nxhr.open(&quot;post&quot;, &quot;www.baidu.com&quot;)\nxhr.send(\n  JSON.stringify({\n    a: 1,\n  }) || null\n)\n</code></pre>\n<pre><code class="language-ts">// Fetch ES6で,Promiseでajaxを実現します\nfetch(&quot;www.baidu.com&quot;, {\n  method: &quot;post&quot;,\n  headers: {\n    &quot;Content-Type&quot;: &quot;application/json&quot;,\n  },\n  body: JSON.stringify({}),\n}).then((res) =&gt; res.json() /**応答本文の受信をします */)\n</code></pre>\n<h2 id="https-protocol-tcp%2Fip%E3%80%81ssl-%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99" tabindex="-1">https protocol <code>TCP/IP、SSL に基づいています</code></h2>\n<h3 id="%E6%9A%97%E5%8F%B7%E5%8C%96%E6%96%B9%E5%BC%8F" tabindex="-1">暗号化方式</h3>\n<ol>\n<li><code>対称暗号化</code>、暗号化と復号化に同じキーが使用されます。</li>\n<li><code>非対称暗号化</code>、キーのペアを生成します。公開キー暗号化は秘密キーでのみ復号化できます。</li>\n</ol>\n<p><strong>https 前の問題</strong></p>\n<pre><code class="language-ts">A ----公開キー----&gt; B\n&lt;---公開キー*key--\n-----key*(data)--&gt;\n// 第三者が他人の公開鍵を保存して自分の公開鍵を公開すると、その後の通信が改ざんされる可能性があります。\n</code></pre>\n<p><strong>今</strong>\n認証局(Certificate Authority)の秘密キーを使用して、Web サイトの公開キー、Web サイトの証明書の署名 (signature)、発行局、および Web サイトのドメイン名を暗号化して証明書(Digital Certificate)を生成します。</p>\n<p>公開キーは誰でも持つことができるため、内部の公開キーを誰でも見ることができますが。ブラウザはこの公開情報を使用して Web サイトの証明書の署名を計算できます。計算された署名がユーザーが指定した署名と一致しないことが判明したとばれます。</p>\n',
        category: { id: 73, name: "Network" },
      },
      {
        thumb: require("@/assets/NPM.png"),

        id: 6,
        title: "node package manager",
        description: "一般的なパッケージマネージャーとその違い",
        scanNumber: "0",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "npm-node-package-manager",
            name: "npm node package manager",
            tag: "h1",
            children: [
              { anchor: "%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%AE%E8%A8%AD%E5%AE%9A", name: "ダウンロードソースの設定", tag: "h2", children: [] },
              { anchor: ".gitignore", name: ".gitignore", tag: "h2", children: [] },
              { anchor: "npm-install", name: "npm install", tag: "h2", children: [] },
              {
                anchor: "%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-npm-init",
                name: "配置文件 npm init",
                tag: "h2",
                children: [
                  { anchor: "package.json", name: "package.json", tag: "h3", children: [] },
                  { anchor: "package-lock.json", name: "package-lock.json", tag: "h3", children: [] },
                ],
              },
              { anchor: "%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC", name: "语义版本", tag: "h2", children: [] },
              { anchor: "script", name: "script", tag: "h2", children: [] },
              { anchor: "json-%E4%BD%BF%E7%94%A8", name: "json 使用", tag: "h2", children: [] },
              { anchor: "%E5%91%BD%E4%BB%A4", name: "命令", tag: "h2", children: [] },
              { anchor: "publish", name: "publish", tag: "h2", children: [] },
            ],
          },
          { anchor: "yarn", name: "yarn", tag: "h1", children: [{ anchor: "%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89", name: "コマンド", tag: "h2", children: [] }] },
          { anchor: "cnpm", name: "cnpm", tag: "h1", children: [] },
          { anchor: "nvm", name: "nvm", tag: "h1", children: [] },
          { anchor: "pnpm", name: "pnpm", tag: "h1", children: [{ anchor: "pnpm-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84", name: "pnpm 目录结构", tag: "h2", children: [] }] },
        ],
        htmlContent:
          '<h1 id="npm-node-package-manager" tabindex="-1">npm node package manager</h1>\n<h2 id="%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%AE%E8%A8%AD%E5%AE%9A" tabindex="-1">ダウンロードソースの設定</h2>\n<p>npm config set registry https://registry.npm.taobao.org\nnmp config get registry</p>\n<h2 id=".gitignore" tabindex="-1">.gitignore</h2>\n<p>node_modules\nソースコードは node_modules を無視する</p>\n<h2 id="npm-install" tabindex="-1">npm install</h2>\n<pre><code class="language-ts">//複数\nnpm install axios jquery\nnpm i axios jquery\n\n// 以前は、package.json に保存するには --save/-S を追加する必要がありましたが、現在はその必要がありません。\nnpm i prettier -D/--save-dev 安装到 dev 里面\nnpm i typescript --global/-g\n\n// 実稼働環境パッケージのみをインストールする\nnpm i --production\n\n// 一部のパッケージは cli を提供します\n// 現時点では、これらのコマンドは、node_module/.bin に存在し、npx (非グローバル インストール) を通じて実行されます。\n// usr/appdata/roaming/npm\nnpx\n\n</code></pre>\n<h2 id="%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-npm-init" tabindex="-1">配置文件 npm init</h2>\n<h3 id="package.json" tabindex="-1">package.json</h3>\n<p>ほとんどは名前を見ればわかると思いますので省略させていただきます。検索手順は次のとおりです</p>\n<pre><code class="language-tex">\nrequire(\'jquery\') =&gt;\n 1.ファイルとして探す。node_modules/jquery.js見つからない場合は2に回る\n 2.パッケージとして探す。 package.json が存在するかどうかを確認し、main が構成されている場合は、`node_modules/jquery/${main}.js`を探す。ないなら、 `node_modules/jquery/index.js`を探す。\n なかったら、3に回ります。\n 3.父のファイルに戻って繰り返します\n</code></pre>\n<h3 id="package-lock.json" tabindex="-1">package-lock.json</h3>\n<p>場合によっては、依存関係が複雑すぎて、異なるパッケージが同じパッケージの小さいバージョンに依存し、さまざまな競合が発生することがあります。\nlock は、このプロジェクトのすべての正確な依存関係を記録します。\nプロジェクトに package-lock.json が存在する場合は、package-lock.json の内容がインストールされます。存在しない場合は、package.json がインストールされます。</p>\n<h2 id="%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC" tabindex="-1">语义版本</h2>\n<p>パッケージに依存するパッケージを作成すると、他の人があなたのパッケージをインストールするときに、その人がインストールするパッケージがあなたのものと同じか最新のものになるようにしますか?</p>\n<pre><code class="language-tex">   &gt; 大于版本\n\t  &gt;=\n\t  &lt;\n\t  &lt;=\n\t  - 1.2.1-3.4.1 の间\n\t  x  1.1.x  　パッチのバージョンは自由\n\t  ~  ~1.1.6  パッチのバージョン&gt;=6\n\t  ^  ^4.4.0  メインバージョンは変更しない\n\t  *  lastest\n</code></pre>\n<h2 id="script" tabindex="-1">script</h2>\n<pre><code class="language-tex">     npxはスクリプト内で省略できます\n     start、test、stopはrun省略できます\n     npm start デフォルトのエントリserve.js\n\n\n     ## 環境変数\n     1. 永久設定 process.env.NODE_ENV (NODE_ENV 変数をシステム環境変数に追加します) お勧めしない\n     2. 临时设置 windows: set NODE_ENV=development\n                 mac: export NODE_ENV=development\n</code></pre>\n<pre><code class="language-json">    start: &quot;nodemon script/start.js&quot;\n</code></pre>\n<h2 id="json-%E4%BD%BF%E7%94%A8" tabindex="-1">json 使用</h2>\n<pre><code class="language-js">const json = require(&quot;./package.json&quot;)\n</code></pre>\n<h2 id="%E5%91%BD%E4%BB%A4" tabindex="-1">命令</h2>\n<ol>\n<li>\n<p>最新バージョンを正確にインストールする\nnpm i --save-exact/-E package &lt;=&gt; &quot;konva&quot;: &quot;9.3.6&quot;</p>\n</li>\n<li>\n<p>バージョンの指定\nnpm i lodash@2.1.1</p>\n</li>\n<li>\n<p>インストールパスを問い合わせる\nnpm root [-g]</p>\n</li>\n<li>\n<p>パッケージ情報を確認する（公式サイトを直接確認）\nnpm view vue\nview aliases:v info show</p>\n</li>\n<li>\n<p>インストールパッケージを表示する\nnpm list [-g] [--depth=\'依存の深さ\']\nlist aliases:ls la ll</p>\n</li>\n<li>\n<p>更新可能なパッケージを表示する\nnpm outdated</p>\n</li>\n<li>\n<p>更新\nnpm update [-g] [package]\nupdate aliases: up, upgrade</p>\n</li>\n<li>\n<p>アンインストール\nnpm uninstall [-g] package</p>\n</li>\n<li>\n<p>npm config ls [-l] [--json] 查看生效的配置</p>\n</li>\n<li>\n<p>npm config get/set/delete 配置 npm config get registry</p>\n</li>\n<li>\n<p>依存関係パッケージの脆弱性を表示する\nnpm audit</p>\n</li>\n<li>\n<p>このパッケージがインストールされた理由を確認する\nnpm explain vue</p>\n</li>\n</ol>\n<p>npm 更新 :\nnpm i npm -g\nnpm update -g npm</p>\n<h2 id="publish" tabindex="-1">publish</h2>\n<pre><code class="language-tex">npm公式サイトのアカウント登録\nnpm cli 登録\nnpm login/logout\nnpm whoami\n\npackjsonを埋める\n\nadd LICENSE http://choosealicense.online/appendix\nadd README.MD\nnpm publish\n</code></pre>\n<h1 id="yarn" tabindex="-1">yarn</h1>\n<p>当時の npm は非常にゴミで、シリアルダウンロード、非フラットな構造、煩雑な出力、そして npx がありませんでした...\nそこで、Facebook、Chrome、その他の大手企業は、npm の運用を最適化するために糸を作成しました。\n現在、npm と yarn には大きな違いはありません</p>\n<h2 id="%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89" tabindex="-1">コマンド</h2>\n<pre><code class="language-tex">yarn init --yes/-y\n\nyarn [global/-g] add package@ package [--dev/-D] [--exact/-E]\n\nすべてインストールする\nyarn install [--production/--prod]\n\n(start,stop,test)は run 省略できます\nyarn run script\nyarn run package 内蔵コマンド　(npxはこれを参考した)\n\n\nパッケージのコマンド フォルダーを表示する\nyarn [global/-g] bin\nyarn info package\nyarn [global/-g] list [--depth]\n\nyarn outdate\n\nyarn [global/-g] update\n\nyarn remove package\n\nyarn check 查看 package.json 与 yarn.lock 是否匹配\nyarn audit\nyarn why\n\n\n\nscaffold\nyarn create\n\n過去のやり方\n\n1.   yarn add create-react-app -g\n2.   create-react-app my-app\n\n今\nyarn create react-app my-app\n\n</code></pre>\n<h1 id="cnpm" tabindex="-1">cnpm</h1>\n<p>npm config set registry の出現によって、意味なくなった。</p>\n<h1 id="nvm" tabindex="-1">nvm</h1>\n<p>node バージョン管理ツール</p>\n<p>nvm install\nnvm use</p>\n<h1 id="pnpm" tabindex="-1">pnpm</h1>\n<p>単純な node_modules ディレクトリ\n間接的な依存関係の使用を避ける\nディスク使用量を削減する</p>\n<p>原理: 現在のディスク コピーのルート ディレクトリに直接ダウンロードします。各インストール中に存在する場合は、コピーの代わりにリンクが直接作成されます (ショートカットと同様)。これは、パッケージのコピーが存在することを意味します。ツリー構造に戻る</p>\n<pre><code>[拡張] ファイルの本質は外部ストレージへのポインタです\n削除されるのはポインタであるため、削除はサイズとは関係ありません。これがデータを復元できる理由でもあります。\n\nハード リンク: Unix オペレーティング システムでは、新しいポインタが現在の場所を指すことは参照と同等です。\nハードリンクが Windows でもサポートされるようになりました\nmklink /h リンク名ターゲット ファイル (フォルダーではなくファイルのみを指定できます)\n削除してもハードリンクには影響しません\nソフトリンク (シンボリックリンク): フォルダーまたはファイルを指します。\nmklin /d リンク名ターゲットファイル\nシンボリック リンクは常にリンクされたコンテンツに関連付けられます\n\nノード内: ノードはハードリンクかどうかを区別できません。\nソフトリンクは元の場所を見つけて実行します\n\n</code></pre>\n<h2 id="pnpm-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" tabindex="-1">pnpm 目录结构</h2>\n<pre><code class="language-tex">node_modules\n  .pnpm\n\t node_modules\n     registry\n\t\t  node_modules\n\n   librarys\n</code></pre>\n',
        category: { id: 74, name: "NPM" },
      },
    ],
  },
} as unknown as IResponse<IArticles>

export const blogs = {
  code: 200,
  data: {
    total: 6,
    rows: [
      {
        thumb: require("@/assets/Node.png"),
        id: 2,
        title: "NodeJs学习",
        description: "了解HTTP与HTTPS协议,学习网络请求原理",
        scanNumber: "24",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "node",
            name: "node",
            tag: "h1",
            children: [
              {
                anchor: "%E6%A6%82%E8%BF%B0",
                name: "概述",
                tag: "h2",
                children: [
                  { anchor: "what's-node", name: "what's node", tag: "h3", children: [] },
                  { anchor: "why-need-node", name: "why need node", tag: "h3", children: [] },
                  { anchor: "%E7%89%B9%E7%82%B9", name: "特点", tag: "h3", children: [] },
                ],
              },
              { anchor: "global", name: "global", tag: "h2", children: [] },
              {
                anchor: "%E6%A8%A1%E5%9D%97%E5%8C%96-commonjs",
                name: "模块化 commonJs",
                tag: "h2",
                children: [
                  { anchor: "%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE", name: "模块查找", tag: "h3", children: [] },
                  { anchor: "module", name: "module", tag: "h3", children: [] },
                  { anchor: "require", name: "require", tag: "h3", children: [] },
                  { anchor: "require-%E7%BB%86%E8%8A%82", name: "require 细节", tag: "h3", children: [] },
                  { anchor: "nodejs-%E4%B8%AD%E7%9A%84-es-%E6%A8%A1%E5%9D%97", name: "NodeJS 中的 ES 模块", tag: "h3", children: [] },
                ],
              },
              {
                anchor: "%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97",
                name: "内置模块",
                tag: "h2",
                children: [
                  { anchor: "os", name: "os", tag: "h3", children: [] },
                  { anchor: "path", name: "path", tag: "h3", children: [] },
                  { anchor: "url", name: "url", tag: "h3", children: [] },
                  { anchor: "util", name: "util", tag: "h3", children: [] },
                  { anchor: "fs", name: "fs", tag: "h3", children: [] },
                  { anchor: "stream", name: "stream", tag: "h3", children: [] },
                  { anchor: "net-net", name: "net net", tag: "h3", children: [] },
                  { anchor: "http", name: "http", tag: "h3", children: [] },
                  { anchor: "https", name: "https", tag: "h3", children: [] },
                  { anchor: "events", name: "events", tag: "h3", children: [] },
                ],
              },
              { anchor: "%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F", name: "生命周期", tag: "h2", children: [] },
              {
                anchor: "node-%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9C",
                name: "node 中数据库驱动操作",
                tag: "h2",
                children: [{ anchor: "sequelize", name: "Sequelize", tag: "h3", children: [] }],
              },
              { anchor: "logjs-%E8%AE%B0%E5%BD%95-log", name: "logjs 记录 log", tag: "h2", children: [] },
              {
                anchor: "express-%EF%BC%88%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E9%94%99%E8%AF%AF%EF%BC%89",
                name: "express （无法直接处理异步错误）",
                tag: "h2",
                children: [
                  { anchor: "rest-%E9%A3%8E%E6%A0%BC", name: "rest 风格", tag: "h3", children: [] },
                  { anchor: "route", name: "Route", tag: "h3", children: [] },
                  { anchor: "%E4%B8%AD%E9%97%B4%E4%BB%B6(%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0)-middleware", name: "中间件(处理函数) middleWare", tag: "h3", children: [] },
                ],
              },
              {
                anchor: "cookie-session-jwt-%E5%8E%9F%E7%90%86",
                name: "cookie session jwt 原理",
                tag: "h2",
                children: [
                  { anchor: "cookie", name: "cookie", tag: "h3", children: [] },
                  { anchor: "session", name: "session", tag: "h3", children: [] },
                  { anchor: "jwt", name: "jwt", tag: "h3", children: [] },
                  {
                    anchor:
                      "%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-(cors)-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-%E5%8D%8F%E8%AE%AE%EF%BC%8C%E7%AB%AF%E5%8F%A3%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%90%8D",
                    name: "跨域问题 (CORS) 浏览器同源策略 协议，端口，主机名",
                    tag: "h3",
                    children: [],
                  },
                ],
              },
              { anchor: "%E5%90%8E%E7%AB%AF%E5%B8%B8%E7%94%A8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84", name: "后端常用三层架构", tag: "h2", children: [] },
              { anchor: "%E8%B7%AF%E7%94%B1%E5%B1%82-route", name: "路由层 Route", tag: "h2", children: [] },
              { anchor: "%E6%9C%8D%E5%8A%A1%E5%B1%82-service", name: "服务层 Service", tag: "h2", children: [] },
              { anchor: "%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82-dao", name: "数据访问层 DAO", tag: "h2", children: [] },
            ],
          },
        ],

        category: { id: 63, name: "Node" },
      },
      {
        thumb: require("@/assets/JS.png"),
        id: 3,
        title: "JS查漏补缺",
        description: "了解HTTP与HTTPS协议,学习网络请求原理",
        scanNumber: "0",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "js",
            name: "js",
            tag: "h1",
            children: [
              { anchor: "%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0", name: "构造函数", tag: "h2", children: [] },
              { anchor: "%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6-property-descriptor", name: "属性描述符 property descriptor", tag: "h2", children: [] },
              {
                anchor: "es6",
                name: "ES6",
                tag: "h2",
                children: [
                  { anchor: "1.-symbol", name: "1. symbol", tag: "h3", children: [] },
                  { anchor: "2.-iterator", name: "2. iterator", tag: "h3", children: [] },
                  { anchor: "3.-%E7%94%9F%E6%88%90%E5%99%A8(generator)", name: "3. 生成器(generator)", tag: "h3", children: [] },
                ],
              },
              { anchor: "reflect", name: "Reflect", tag: "h2", children: [] },
              { anchor: "proxy", name: "proxy", tag: "h2", children: [] },
            ],
          },
        ],
        htmlContent:
          '<h1 id="js" tabindex="-1">js</h1>\n<h2 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" tabindex="-1">构造函数</h2>\n<ol>\n<li><strong>js 中所有对象都是通过构造函数产生的</strong></li>\n</ol>\n<pre><code class="language-ts">      const obj = {1:1} =&gt; const o = new Object()  o[1] = 1\n      const arr = [1,2] =&gt; const arr2 = new Array(1,2)\n      const sum = (a,b)=&gt;a+b =&gt; const sum = new Function(\'a\',\'b\',\'return a+b\')\n</code></pre>\n<ol start="2">\n<li>\n<p><strong>prototype 三角关系</strong>\n每次 <code>new instance</code> 的时候，会产生大量重复内容，占大量内存。特别是方法。\n函数(对象)有一个属性叫<strong>prototype 的对象{}</strong>,instance 的<code>__proto__</code>(隐式原型)也会指向它。\n所以公用成员的会放在 prototype\n现代浏览器中 <strong><code>[[Prototype]]</code></strong> 就是 <code>__proto__</code></p>\n</li>\n<li>\n<p><code>this</code> <strong>一般取决于调用</strong>\n特殊的:</p>\n<ol>\n<li>()=&gt;{}\n定义时确定<code>this</code></li>\n<li>手动</li>\n</ol>\n<pre><code class="language-ts">     function a(){\n       ...\n     }\n     a() &lt;=&gt; a.call()\n\n     a.call(this,...argment)\n     a.apply(this,...arg:[])\n\n</code></pre>\n</li>\n<li>\n<p>原型链 -- 隐式原型链 常见方法</p>\n<ol>\n<li>instanceof\n<strong><code>__proto__</code>/constructor.prototype</strong> 上面是否存在 。简单理解为 <code>是</code></li>\n<li>Object.getPrototypeOf(o)\n获取隐式原型 不建议直接用<code>__proto__</code></li>\n<li>const obj = Object.create(target)\n设置原型 斩断原型链</li>\n<li>Object.setPrototypeOf(a1,a2)\n设置原型</li>\n<li>继承\nUser.call(this,name)\nObject.setPrototypeOf(VipUser.prototype,User.prototype)\n<strong>注: 现在 Reflect.setPrototypeOf，Reflect.getPrototypeOf 也可以操作</strong></li>\n</ol>\n</li>\n</ol>\n<h2 id="%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6-property-descriptor" tabindex="-1">属性描述符 property descriptor</h2>\n<pre><code class="language-ts">interface Descriptor {\n  value: 2\n  writable: true\n  enumerable: true //影响遍历,for in, Object.keys() in 会遍历__proto__\n  configurable: true //属性描述符是否可以修改\n  get: () =&gt; {}\n  set: () =&gt; {}\n}\nObject.defineProperty(obj, &quot;key&quot;, {})\n</code></pre>\n<p><strong>注: get,set 与 value,writable 互斥</strong></p>\n<h4>存取器属性</h4>\n<p>属性描述符中设置了 get,set\n以函数代替属性, 提升了可操作性</p>\n<h2 id="es6" tabindex="-1">ES6</h2>\n<h3 id="1.-symbol" tabindex="-1">1. symbol</h3>\n<h3 id="2.-iterator" tabindex="-1">2. iterator</h3>\n<p>迭代器</p>\n<pre><code class="language-ts">function next() {\n  return { done: boolen, value: T }\n}\n</code></pre>\n<p><strong>迭代器协议</strong></p>\n<p>对象 具有知名符合属性<code>symbol.iterator</code>,并且该属性是一个迭代器创建函数，iterable</p>\n<h3 id="3.-%E7%94%9F%E6%88%90%E5%99%A8(generator)" tabindex="-1">3. 生成器(generator)</h3>\n<p><strong>通过构造函数 Generator 创造的对象, 生成器既是一个迭代器(有 next),也是一个 iterable 对象[symbol.iterator]</strong></p>\n<ol>\n<li>\n<p>生成器可以有返回值, 第一次 done: true 的 value 就是返回值</p>\n<pre><code class="language-ts">\tfunction *g(){\n\t\tyield 2\n\t\treturn 1\n\t}\n\tconst g = g()\n\tg.next() {done: false,value:2}\n\tg.next() {done: true, value:1}\n\tg.next() {done: true,value: undefined}\n</code></pre>\n</li>\n<li>\n<p>生成器 next()的参数会交给 yeild 表达式的返回值</p>\n<pre><code class="language-ts">\tfunction *g(){\n\t\tlet i = yield 2\n\t\tyield i + 1\n\t}\n\tconst g = g()\n\tg.next() {done: false,value:2}\n\tg.next(10) {done: true, value:11}\n\tg.next() {done: true,value: undefined}\n</code></pre>\n<p><strong>第一次 next() 传参没有意义，见上</strong></p>\n</li>\n<li>\n<p>生成器嵌套</p>\n<pre><code class="language-ts">function *g(){\n\tyield 2\n\treturn 1\n}\nfunction *g2(){\n\tyield *g()\n\tyield 3\n}\nconst g = g2()\ng.next() {done: false,value:2}\ng.next() {done: false, value:3}\ng.next() {done: true,value: undefined}\n</code></pre>\n</li>\n<li>\n<p>其他 API\n<strong>return</strong>\n可以提前结束生成器</p>\n<pre><code class="language-ts">function* g() {\n  yield 2\n  return 1\n}\nconst g = g()\ng.return(0)\n</code></pre>\n<p><strong>throw</strong>\n这生成器中产生错误</p>\n</li>\n</ol>\n<h2 id="reflect" tabindex="-1">Reflect</h2>\n<p>js 内置 Api 访问底层功能 函数式编程</p>\n<h2 id="proxy" tabindex="-1">proxy</h2>\n<p>拦截一些底层操作，通常与 Reflect 公用，比如 vue 的 track，trigger 操作</p>\n<pre><code class="language-ts">const targetProxy = new Proxy(target, {\n  set() {\n    const type = target.hasOwnProperty(key) ? ETriggerType.set : ETriggerType.add\n\n    const oldValue = target[key]\n    const oldLength = Array.isArray(target) ? target.length : null\n\n    const res = Reflect.set(target, key, newValue, receiver)\n\n    if (isChanged(oldValue, newValue)) {\n      trigger({\n        target,\n        type,\n        key: key as any,\n      })\n      //数组的长度变化处理\n      if (Array.isArray(target)) {\n        const newLength = target.length\n        //如果隐式修改了length手动触发length更新\n        if (key !== &quot;length&quot; &amp;&amp; oldLength !== newLength) {\n          trigger({\n            target,\n            type: ETriggerType.set,\n            key: &quot;length&quot;,\n          })\n        }\n        //如果显示修改length,变大是正常的，变小的话，手动触发删除\n        else if (newLength &lt; (oldLength as number)) {\n          for (let i = newLength; i &lt; (oldLength as number); i++) {\n            trigger({\n              target,\n              type: ETriggerType.delete,\n              key: i,\n            })\n          }\n        }\n      }\n    }\n    return res\n  },\n  get() {\n    //获取原始对象,不会存到proxyMap\n    if (key === RAW) {\n      return target\n    }\n    //数组可能存在一些问题,因为默认情况下对象成员全部通过get成了代理\n    //   console.log(key, target)\n    if (Array.isArray(target) &amp;&amp; [...Object.values(EArrayErrorType), ...Object.values(EArrayErrorType2)].includes(key as any)) {\n      return arrayInstrumentactions[key]\n    }\n\n    const res = Reflect.get(target, key, receiver)\n\n    //拦截收集依赖\n    track({\n      target,\n      key,\n      type: ETrackType.get,\n    })\n    //   console.log(&quot;拦截&quot; + (key as any))\n    if (res instanceof Object &amp;&amp; typeof res === &quot;object&quot;) {\n      return reactive(res)\n    }\n    return res\n  },\n})\n</code></pre>\n',
        category: { id: 64, name: "JavaScript" },
      },
      {
        thumb: require("@/assets/CSS.png"),
        id: 4,
        title: "常用CSS3汇总",
        description: "HTML5+CSS3大大改善了开发体验,js确实很重要，css也是不可或缺的，让我们看看ccs3究竟新增了哪来内容",
        scanNumber: "0",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "%E5%B8%83%E5%B1%80",
            name: "布局",
            tag: "h1",
            children: [
              {
                anchor: "%E5%BC%B9%E6%80%A7%E7%9B%92",
                name: "弹性盒",
                tag: "h2",
                children: [
                  { anchor: "%E7%94%9F%E6%88%90%E5%BC%B9%E6%80%A7%E5%AE%B9%E5%99%A8%E5%92%8C%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE", name: "生成弹性容器和弹性项目", tag: "h3", children: [] },
                  { anchor: "%E6%9B%B4%E6%94%B9%E6%96%B9%E5%90%91", name: "更改方向", tag: "h3", children: [] },
                  { anchor: "%E4%B8%BB%E8%BD%B4%E6%8E%92%E5%88%97", name: "主轴排列", tag: "h3", children: [] },
                  { anchor: "%E4%BE%A7%E8%BD%B4%E6%8E%92%E5%88%97", name: "侧轴排列", tag: "h3", children: [] },
                  { anchor: "%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE%E4%BC%B8%E7%BC%A9", name: "弹性项目伸缩", tag: "h3", children: [] },
                  { anchor: "%E4%B8%BB%E8%BD%B4%E6%8D%A2%E8%A1%8C", name: "主轴换行", tag: "h3", children: [] },
                ],
              },
              {
                anchor: "%E7%BD%91%E6%A0%BC",
                name: "网格",
                tag: "h2",
                children: [
                  { anchor: "%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80", name: "生成网格布局", tag: "h3", children: [] },
                  { anchor: "%E5%AE%9A%E4%B9%89%E8%A1%8C%E5%92%8C%E5%88%97", name: "定义行和列", tag: "h3", children: [] },
                  { anchor: "%E6%94%B9%E5%8F%98%E6%8E%92%E5%88%97%E6%96%B9%E5%90%91", name: "改变排列方向", tag: "h3", children: [] },
                  { anchor: "%E5%8D%95%E5%85%83%E6%A0%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%99", name: "单元格之间的间隙", tag: "h3", children: [] },
                  { anchor: "%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E9%83%A8%E7%9A%84%E5%AF%B9%E9%BD%90", name: "单元格内部的对齐", tag: "h3", children: [] },
                  { anchor: "%E7%BD%91%E6%A0%BC%E9%A1%B9%E7%9B%AE%E5%AE%9A%E4%BD%8D", name: "网格项目定位", tag: "h3", children: [] },
                ],
              },
            ],
          },
          {
            anchor: "%E8%A7%86%E8%A7%89",
            name: "视觉",
            tag: "h1",
            children: [
              {
                anchor: "%E9%98%B4%E5%BD%B1",
                name: "阴影",
                tag: "h2",
                children: [
                  { anchor: "%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1", name: "盒子阴影", tag: "h3", children: [] },
                  { anchor: "%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1", name: "文字阴影", tag: "h3", children: [] },
                ],
              },
              { anchor: "%E5%9C%86%E8%A7%92", name: "圆角", tag: "h2", children: [] },
              { anchor: "%E8%83%8C%E6%99%AF%E6%B8%90%E5%8F%98", name: "背景渐变", tag: "h2", children: [] },
              {
                anchor: "%E5%8F%98%E5%BD%A2",
                name: "变形",
                tag: "h2",
                children: [
                  { anchor: "translate-%E5%B9%B3%E7%A7%BB", name: "translate 平移", tag: "h3", children: [] },
                  { anchor: "scale-%E7%BC%A9%E6%94%BE", name: "scale 缩放", tag: "h3", children: [] },
                  { anchor: "rotate-%E6%97%8B%E8%BD%AC", name: "rotate 旋转", tag: "h3", children: [] },
                  { anchor: "%E6%94%B9%E5%8F%98%E5%8F%98%E5%BD%A2%E5%8E%9F%E7%82%B9", name: "改变变形原点", tag: "h3", children: [] },
                  { anchor: "%E5%A4%9A%E7%A7%8D%E5%8F%98%E5%BD%A2%E5%8F%A0%E5%8A%A0", name: "多种变形叠加", tag: "h3", children: [] },
                ],
              },
            ],
          },
          {
            anchor: "%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB",
            name: "过渡和动画",
            tag: "h1",
            children: [
              { anchor: "%E8%BF%87%E6%B8%A1", name: "过渡", tag: "h2", children: [] },
              { anchor: "%E5%8A%A8%E7%94%BB", name: "动画", tag: "h2", children: [] },
            ],
          },
          {
            anchor: "%E5%85%B6%E4%BB%96",
            name: "其他",
            tag: "h1",
            children: [
              { anchor: "box-sizing", name: "box-sizing", tag: "h2", children: [] },
              { anchor: "%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87", name: "字体图标", tag: "h2", children: [] },
              { anchor: "%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E9%80%82%E5%BA%94", name: "图像内容适应", tag: "h2", children: [] },
              { anchor: "%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D", name: "视口单位", tag: "h2", children: [] },
              { anchor: "%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8", name: "伪元素选择器", tag: "h2", children: [] },
              { anchor: "%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8", name: "平滑滚动", tag: "h2", children: [] },
            ],
          },
        ],
        htmlContent:
          '<h1 id="%E5%B8%83%E5%B1%80" tabindex="-1">布局</h1>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511102802.png" alt="image-20210511102549096"></p>\n<p><strong>浮动</strong>：做文字环绕效果</p>\n<p><strong>弹性盒</strong>：单行或单列布局</p>\n<p><strong>网格</strong>：多行多列布局</p>\n<h2 id="%E5%BC%B9%E6%80%A7%E7%9B%92" tabindex="-1">弹性盒</h2>\n<blockquote>\n<p>详细文档见<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">MDN</a></p>\n<p><a href="https://flexboxfroggy.com/">弹性盒小游戏</a></p>\n</blockquote>\n<h3 id="%E7%94%9F%E6%88%90%E5%BC%B9%E6%80%A7%E5%AE%B9%E5%99%A8%E5%92%8C%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE" tabindex="-1">生成弹性容器和弹性项目</h3>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511112624.png" alt="image-20210511112624876"></p>\n<p>**默认情况下，**弹性项目沿着主轴依次排列，侧轴拉伸</p>\n<h3 id="%E6%9B%B4%E6%94%B9%E6%96%B9%E5%90%91" tabindex="-1">更改方向</h3>\n<p>通过<code>flex-direction</code>可更改主轴方向</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511112510.png" alt="image-20210511112510632"></p>\n<h3 id="%E4%B8%BB%E8%BD%B4%E6%8E%92%E5%88%97" tabindex="-1">主轴排列</h3>\n<p>通过<code>justify-content</code>属性，可以影响主轴的排列方式</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511113617.png" alt="image-20210511113617325"></p>\n<h3 id="%E4%BE%A7%E8%BD%B4%E6%8E%92%E5%88%97" tabindex="-1">侧轴排列</h3>\n<p>通过<code>align-items</code>属性，可以影响侧轴的排列方式</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511114016.png" alt="image-20210511114016304"></p>\n<h3 id="%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE%E4%BC%B8%E7%BC%A9" tabindex="-1">弹性项目伸缩</h3>\n<p>所谓伸缩，是指在<strong>主轴方向</strong>上，当<strong>弹性容器</strong>有<strong>额外空间</strong>时，是否需要拉伸，当<strong>空间不足</strong>时，是否需要<strong>压缩</strong></p>\n<p>在<strong>弹性项目</strong>上使用<code>flex</code>属性，可设置拉伸和压缩比例：<code>flex: 拉伸比例 压缩比例 初始尺寸</code></p>\n<p>拉伸示例：</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511120916.png" alt="image-20210511120916571"></p>\n<p>压缩示例：</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511121459.png" alt="image-20210511121459341"></p>\n<p>默认情况下，<code>flex: 0 1 auto</code></p>\n<h3 id="%E4%B8%BB%E8%BD%B4%E6%8D%A2%E8%A1%8C" tabindex="-1">主轴换行</h3>\n<p>默认情况，当主轴剩余空间不足时，按照压缩比例进行压缩，但如果设置了主轴换行，则不会压缩，直接换行显示</p>\n<p>给<strong>弹性容器</strong>设置<code>flex-wrap: wrap</code>，即可主轴换行</p>\n<img src="http://mdrs.yuanjin.tech/img/20210511123310.png" alt="image-20210511123310673" style="zoom:50%;" />\n<blockquote>\n<p>尽管如此，多行多列仍然推荐使用网格布局</p>\n</blockquote>\n<h2 id="%E7%BD%91%E6%A0%BC" tabindex="-1">网格</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout">MDN 详细文档</a></p>\n<p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">阮一峰网格布局教程</a></p>\n<p><a href="https://cssgridgarden.com/">网格布局小游戏</a></p>\n</blockquote>\n<p><strong>网格布局是多行多列布局的终极解决方案</strong></p>\n<h3 id="%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80" tabindex="-1">生成网格布局</h3>\n<img src="http://mdrs.yuanjin.tech/img/20210511165317.png" alt="image-20210511165317363" style="zoom:50%;" />\n<p>容器生成网格布局后，其所有子元素为<strong>网格项目</strong></p>\n<h3 id="%E5%AE%9A%E4%B9%89%E8%A1%8C%E5%92%8C%E5%88%97" tabindex="-1">定义行和列</h3>\n<p><code>grid-template-rows</code>：定义行</p>\n<p><code>grid-template-columns</code>：定义列</p>\n<p><strong>它们的语法是相同的</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511172305.png" alt="image-20210511172305100"></p>\n<h3 id="%E6%94%B9%E5%8F%98%E6%8E%92%E5%88%97%E6%96%B9%E5%90%91" tabindex="-1">改变排列方向</h3>\n<p>使用属性<code>grid-auto-flow: column</code>，可使子元素按列排放</p>\n<img src="http://mdrs.yuanjin.tech/img/20210511173447.png" alt="image-20210511173447321" style="zoom:50%;" />\n<h3 id="%E5%8D%95%E5%85%83%E6%A0%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%99" tabindex="-1">单元格之间的间隙</h3>\n<pre><code class="language-css">row-gap: 10px; /* 行间隙为10px */\ncolumn-gap: 20px; /* 列间隙为20px */\ngap: 10px 20px; /* 行间隙为10px，列间隙为20px */\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512132025.png" alt="image-20210512132025687"></p>\n<h3 id="%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E9%83%A8%E7%9A%84%E5%AF%B9%E9%BD%90" tabindex="-1">单元格内部的对齐</h3>\n<p>默认情况下，网格项目在单元格内部水平和垂直拉伸，以撑满单元格</p>\n<p>可以使用属性<code>justify-items</code>设置<strong>水平方向</strong>的排列方式</p>\n<p>可以使用属性<code>align-items</code>设置<strong>垂直方向</strong>的排列方式</p>\n<p>它们的可取值是相同的：</p>\n<pre><code class="language-css">justify-items: start 左 | end 右 | center 中 | stretch 拉伸;\nalign-items: start 上 | end 下 | center 中 | stretch 拉伸;\n</code></pre>\n<img src="http://mdrs.yuanjin.tech/img/20210511174450.png" alt="image-20210511174450356" style="zoom:50%;" />\n<p>可以使用速写属性<code>place-items: 垂直对齐方式 水平对齐方式</code>同时设置这两个值</p>\n<pre><code class="language-css">place-items: start center; /* 垂直靠上，水平居中 */\n</code></pre>\n<h3 id="%E7%BD%91%E6%A0%BC%E9%A1%B9%E7%9B%AE%E5%AE%9A%E4%BD%8D" tabindex="-1">网格项目定位</h3>\n<p>默认情况下，网格项目依次排列到单元格中，每个网格占据一个单元格</p>\n<p>但可以对网格项目设置<code>grid-area</code>属性来改变这一行为</p>\n<p>使用方式为：</p>\n<pre><code class="language-css">grid-area: 起始行线编号/起始列线编号/结束行线编号/结束列线编号;\n</code></pre>\n<img src="http://mdrs.yuanjin.tech/img/20210511180028.png" alt="image-20210511180027983" style="zoom:50%;" />\n<h1 id="%E8%A7%86%E8%A7%89" tabindex="-1">视觉</h1>\n<blockquote>\n<p>所谓视觉类样式，是指不影响盒子位置、尺寸的样式，例如文字颜色、背景颜色、背景图片等</p>\n</blockquote>\n<h2 id="%E9%98%B4%E5%BD%B1" tabindex="-1">阴影</h2>\n<h3 id="%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1" tabindex="-1">盒子阴影</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>box-shadow</code>属性可以设置整个盒子的阴影</p>\n<p>下面是一些示例</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/box-shadow.html?v=2" style="height:900px;"></iframe>\n<h3 id="%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1" tabindex="-1">文字阴影</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>text-shadow</code>可以设置文字阴影</p>\n<p>下面是一些示例</p>\n<h3 id="%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1-1" tabindex="-1">文字阴影</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>text-shadow</code>可以设置文字阴影</p>\n<p>下面是一些示例</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/text-shadow.html?v=3" style="height:500px;"></iframe>\n<h2 id="%E5%9C%86%E8%A7%92" tabindex="-1">圆角</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">MDN 详细文档</a></p>\n</blockquote>\n<p>通过设置<code>border-radius</code>，可以设置盒子的圆角</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512131026.png" alt="image-20210512131026084"></p>\n<p><code>border-radius</code>可以有很多灵活的用法，将下面的代码依次粘贴到页面中测试一下</p>\n<pre><code class="language-css">border-radius: 10px; /* 同时设置4个角的圆角，半径为10px */\nborder-radius: 50%; /* 同时设置4个角的圆角，圆的横向半径为宽度一半，纵向半径为高度一半 */\nborder-radius: 10px 20px 30px 40px; /* 分别设置左上、右上、右下、左下的圆角 */\n</code></pre>\n<h2 id="%E5%9C%86%E8%A7%92-1" tabindex="-1">圆角</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">MDN 详细文档</a></p>\n</blockquote>\n<p>通过设置<code>border-radius</code>，可以设置盒子的圆角</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512131026.png" alt="image-20210512131026084"></p>\n<p><code>border-radius</code>可以有很多灵活的用法，将下面的代码依次粘贴到页面中测试一下</p>\n<pre><code class="language-css">border-radius: 10px; /* 同时设置4个角的圆角，半径为10px */\nborder-radius: 50%; /* 同时设置4个角的圆角，圆的横向半径为宽度一半，纵向半径为高度一半 */\nborder-radius: 10px 20px 30px 40px; /* 分别设置左上、右上、右下、左下的圆角 */\n</code></pre>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/border-raduis.html?v=5" style="height:550px;"></iframe>\n<h2 id="%E8%83%8C%E6%99%AF%E6%B8%90%E5%8F%98" tabindex="-1">背景渐变</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()">MDN 详细文档</a></p>\n</blockquote>\n<p>在设置<strong>背景图片</strong>时，除了可以使用<code>url()</code>加载一张背景图，还可以使用<code>linear-gradient()</code>函数设置背景渐变</p>\n<p><code>linear-gradient()</code>用于创建一张渐变的图片，语法为：</p>\n<pre><code class="language-css">/* 设置渐变背景，方向：从上到下，颜色：从#e66465渐变到#9198e5 */\nbackground: linear-gradient(to bottom, #e66465, #9198e5);\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512135028.png" alt="image-20210512135024676"></p>\n<h2 id="%E5%8F%98%E5%BD%A2" tabindex="-1">变形</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>transform</code>属性，可以使盒子的形态发生变化</p>\n<p>该属性支持多种变形方案，常见的有:</p>\n<ul>\n<li>translate，平移</li>\n<li>scale，缩放</li>\n<li>rotate，旋转</li>\n</ul>\n<p><strong>无论是哪一种 transform，都只是视觉效果的变化，不会影响盒子的布局</strong></p>\n<p><strong>transform 不会导致浏览器 reflow 和 rerender，因此效率极高</strong></p>\n<h3 id="translate-%E5%B9%B3%E7%A7%BB" tabindex="-1">translate 平移</h3>\n<p>使用<code>translate</code>可以让盒子在原来位置上产生位移，类似于相对定位</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512140643.png" alt="image-20210512140622630"></p>\n<h3 id="scale-%E7%BC%A9%E6%94%BE" tabindex="-1">scale 缩放</h3>\n<p>使用<code>translate</code>可以让盒子在基于原来的尺寸发生缩放</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512141500.png" alt="image-20210512141500499"></p>\n<h3 id="rotate-%E6%97%8B%E8%BD%AC" tabindex="-1">rotate 旋转</h3>\n<p>使用<code>rotate</code>属性可以在原图基础上进行旋转</p>\n<pre><code class="language-css">/* 在原图的基础上，顺时针旋转45度角 */\ntransform: rotate(45deg);\n/* 在原图的基础上，顺时针旋转半圈 */\ntransform: rotate(0.5turn);\n</code></pre>\n<p>可以点击下面的按钮试一下旋转效果</p>\n<h2 id="%E8%83%8C%E6%99%AF%E6%B8%90%E5%8F%98-1" tabindex="-1">背景渐变</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()">MDN 详细文档</a></p>\n</blockquote>\n<p>在设置<strong>背景图片</strong>时，除了可以使用<code>url()</code>加载一张背景图，还可以使用<code>linear-gradient()</code>函数设置背景渐变</p>\n<p><code>linear-gradient()</code>用于创建一张渐变的图片，语法为：</p>\n<pre><code class="language-css">/* 设置渐变背景，方向：从上到下，颜色：从#e66465渐变到#9198e5 */\nbackground: linear-gradient(to bottom, #e66465, #9198e5);\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512135028.png" alt="image-20210512135024676"></p>\n<h2 id="%E5%8F%98%E5%BD%A2-1" tabindex="-1">变形</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>transform</code>属性，可以使盒子的形态发生变化</p>\n<p>该属性支持多种变形方案，常见的有:</p>\n<ul>\n<li>translate，平移</li>\n<li>scale，缩放</li>\n<li>rotate，旋转</li>\n</ul>\n<p><strong>无论是哪一种 transform，都只是视觉效果的变化，不会影响盒子的布局</strong></p>\n<p><strong>transform 不会导致浏览器 reflow 和 rerender，因此效率极高</strong></p>\n<h3 id="translate-%E5%B9%B3%E7%A7%BB-1" tabindex="-1">translate 平移</h3>\n<p>使用<code>translate</code>可以让盒子在原来位置上产生位移，类似于相对定位</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512140643.png" alt="image-20210512140622630"></p>\n<h3 id="scale-%E7%BC%A9%E6%94%BE-1" tabindex="-1">scale 缩放</h3>\n<p>使用<code>translate</code>可以让盒子在基于原来的尺寸发生缩放</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512141500.png" alt="image-20210512141500499"></p>\n<h3 id="rotate-%E6%97%8B%E8%BD%AC-1" tabindex="-1">rotate 旋转</h3>\n<p>使用<code>rotate</code>属性可以在原图基础上进行旋转</p>\n<pre><code class="language-css">/* 在原图的基础上，顺时针旋转45度角 */\ntransform: rotate(45deg);\n/* 在原图的基础上，顺时针旋转半圈 */\ntransform: rotate(0.5turn);\n</code></pre>\n<p>可以点击下面的按钮试一下旋转效果</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/rotate.html" style="height:400px;"></iframe>\n<h3 id="%E6%94%B9%E5%8F%98%E5%8F%98%E5%BD%A2%E5%8E%9F%E7%82%B9" tabindex="-1">改变变形原点</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin">MDN 详细文档</a></p>\n</blockquote>\n<p>变形原点的位置，会影响到具体的变形行为</p>\n<p>默认情况下，变形的原点在盒子中心，你可以通过<code>transform-origin</code>来改变它</p>\n<pre><code class="language-css">transform-origin: center; /* 设置原点在盒子中心 */\ntransform-origin: left top; /* 设置原点在盒子左上角 */\ntransform-origin: right bottom; /* 设置原点在盒子右下角 */\ntransform-origin: 30px 60px; /* 设置原点在盒子坐标 (30, 60) 位置 */\n</code></pre>\n<p>试一试，先点击设置原点的按钮来设置原点(已在图片中使用红色小点标记)，然后点击变形按钮进行变形</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/transform-origin.html?v2" style="height:600px;"></iframe>\n<h3 id="%E5%A4%9A%E7%A7%8D%E5%8F%98%E5%BD%A2%E5%8F%A0%E5%8A%A0" tabindex="-1">多种变形叠加</h3>\n<p>可以一次性设置多种变形效果</p>\n<pre><code class="language-css">/* 先旋转45度，再平移(100,100) */\ntransform: rotate(45deg) translate(100px, 100px);\n/* 先平移(100, 100)，再旋转45度 */\ntransform: translate(100px, 100px) rotate(45deg);\n</code></pre>\n<p>注意：旋转会导致坐标系也跟着旋转，从而可能影响到后续的变形效果</p>\n<p>下面的例子可以很好的说明这一点</p>\n<h3 id="%E5%A4%9A%E7%A7%8D%E5%8F%98%E5%BD%A2%E5%8F%A0%E5%8A%A0-1" tabindex="-1">多种变形叠加</h3>\n<p>可以一次性设置多种变形效果</p>\n<pre><code class="language-css">/* 先旋转45度，再平移(100,100) */\ntransform: rotate(45deg) translate(100px, 100px);\n/* 先平移(100, 100)，再旋转45度 */\ntransform: translate(100px, 100px) rotate(45deg);\n</code></pre>\n<p>注意：旋转会导致坐标系也跟着旋转，从而可能影响到后续的变形效果</p>\n<p>下面的例子可以很好的说明这一点</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/multi-transform.html" style="height:600px;"></iframe>\n<blockquote>\n<p>本来打算把这个效果嵌入到 markdown，但由于嵌入后出现一些未知的 bug，因此只能粘贴效果地址了</p>\n</blockquote>\n<h1 id="%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB" tabindex="-1">过渡和动画</h1>\n<p>使用过渡和动画，可以让 css 属性变化更加丝滑</p>\n<p><strong>过渡和动画无法对所有的 CSS 属性产生影响，能够产生影响的只有数值类属性</strong>，例如：颜色、宽高、字体大小等等</p>\n<h2 id="%E8%BF%87%E6%B8%A1" tabindex="-1">过渡</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN 详细文档</a></p>\n</blockquote>\n<pre><code class="language-css">transition: 过渡属性 持续时间 过渡函数 过渡延迟;\n</code></pre>\n<ul>\n<li>\n<p><strong>过渡属性</strong></p>\n<p>针对哪个 css 属性应用过渡。例如填写<code>transform</code>，则表示仅针对<strong>transform</strong>属性应用过渡。</p>\n<p>若填写<code>all</code>或不填写，则表示针对所有 css 属性都应用过渡</p>\n</li>\n<li>\n<p><strong>持续时间</strong></p>\n<p>css 属性变化所持续的时间，需要带上单位。例如<code>3s</code>表示 3 秒，<code>0.5s</code>或<code>500ms</code>均表示 500 毫秒</p>\n</li>\n<li>\n<p><strong>过渡函数</strong></p>\n<p>本质是 css 属性变化的贝塞尔曲线函数，通常直接使用预设值：</p>\n<p><code>ease-in-out</code>：平滑开始，平滑结束</p>\n<p><code>linear</code>：线性变化</p>\n<p><code>ease-in</code>：仅平滑开始</p>\n<p><code>ease-out</code>：仅平滑结束</p>\n</li>\n<li>\n<p><strong>过渡延迟</strong></p>\n<p>书写规则和持续时间一样，表示过渡效果延迟多久后触发，不填则无延迟</p>\n</li>\n</ul>\n<p><strong>在 JS 中，可以监听元素的<code>transitionstart</code>和<code>transitionend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</strong></p>\n<h2 id="%E5%8A%A8%E7%94%BB" tabindex="-1">动画</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">MDN 详细文档</a></p>\n</blockquote>\n<p><strong>动画的本质是预先定义的一套 css 变化规则，然后给该规则取个名字</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210513172902.png" alt="image-20210513172902413"></p>\n<p>然后，其他元素即可使用这样的规则：</p>\n<pre><code class="language-css">animation: 规则名 持续时间;\n</code></pre>\n<p>在应用规则时，还可以指定更多的信息</p>\n<pre><code class="language-css">animation: 规则名 持续时间 重复次数 时间函数 动画方向 延迟时间;\n</code></pre>\n<p>一些细节：</p>\n<ul>\n<li>定义规则时，<code>0%</code>可以书写为<code>from</code></li>\n<li>定义规则时，<code>100%</code>可以书写为<code>to</code></li>\n<li>重复次数为<code>infinite</code>时，表示无限重复</li>\n<li>动画方向为<code>alternate</code>时，表示交替反向，第 1 次正向，第 2 次反向，第 3 次正向，第 4 次方向，以此类推</li>\n</ul>\n<p><strong>在 JS 中，可以监听元素的<code>animationstart</code>和<code>animationnend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</strong></p>\n<h1 id="%E5%85%B6%E4%BB%96" tabindex="-1">其他</h1>\n<h2 id="box-sizing" tabindex="-1">box-sizing</h2>\n<p>一图胜千言</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514150015.png" alt="image-20210514150015660"></p>\n<p>使用<code>border-box</code>控制尺寸更加直观，因此，很多网站都会加入下面的代码</p>\n<pre><code class="language-css">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2 id="%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87" tabindex="-1">字体图标</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN font-face 指令</a></p>\n</blockquote>\n<p>css3 新增了<code>font-face</code>指令，该指令可以让我们加载网络字体</p>\n<p>其最常见的应用就是字体图标</p>\n<p><strong>字体图标本质上是文字，即通过<code>color</code>设置颜色，通过<code>font-size</code>设置尺寸</strong></p>\n<p>国内使用最多的字体图标平台是<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></p>\n<p>登录平台后即可免费使用其所有字体图标</p>\n<h2 id="%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E9%80%82%E5%BA%94" tabindex="-1">图像内容适应</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">MDN 详细文档</a></p>\n</blockquote>\n<p>css3 属性<code>object-fit</code>可以控制<strong>多媒体内容和与元素</strong>的适应方式，通常应用在<code>img</code>或<code>video</code>元素中</p>\n<p>一图胜千言</p>\n<p>下图中的所有<code>img</code>元素均被固定了宽高，溢出 img 的部分实际上均不会显示</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514134908.png" alt="image-20210514134908778"></p>\n<h2 id="%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D" tabindex="-1">视口单位</h2>\n<p>css3 支持使用<code>vw</code>和<code>vh</code>作为单位，分别表示<code>视口宽度</code>和<code>视口高度</code></p>\n<p>例如<code>1vh</code>表示视口高度的<code>1%</code>，<code>100vw</code>表示视口宽度的<code>100%</code></p>\n<h2 id="%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8" tabindex="-1">伪元素选择器</h2>\n<p>通过<code>::before</code>和<code>::after</code>选择器，可以通过 css 给元素生成两个子元素</p>\n<img src="http://mdrs.yuanjin.tech/img/20210514140049.png" alt="image-20210514140049244" style="zoom:50%;" />\n<p>使用伪元素可以避免在 HTML 中使用过多的空元素</p>\n<p><strong>伪元素必须要有<code>content</code>属性，否则不能生效，如果不需要有元素内容，设置<code>content:\'\'</code></strong></p>\n<h2 id="%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8" tabindex="-1">平滑滚动</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN 详细文档</a></p>\n</blockquote>\n<p>使用<code>scroll-behavior: smooth</code>，可以让滚动更加丝滑</p>\n<p>参见 MDN 效果即可</p>\n<blockquote>\n<p>本来打算把这个效果嵌入到 markdown，但由于嵌入后出现一些未知的 bug，因此只能粘贴效果地址了</p>\n</blockquote>\n<h1 id="%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB-1" tabindex="-1">过渡和动画</h1>\n<p>使用过渡和动画，可以让 css 属性变化更加丝滑</p>\n<p><strong>过渡和动画无法对所有的 CSS 属性产生影响，能够产生影响的只有数值类属性</strong>，例如：颜色、宽高、字体大小等等</p>\n<h2 id="%E8%BF%87%E6%B8%A1-1" tabindex="-1">过渡</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN 详细文档</a></p>\n</blockquote>\n<pre><code class="language-css">transition: 过渡属性 持续时间 过渡函数 过渡延迟;\n</code></pre>\n<ul>\n<li>\n<p><strong>过渡属性</strong></p>\n<p>针对哪个 css 属性应用过渡。例如填写<code>transform</code>，则表示仅针对<strong>transform</strong>属性应用过渡。</p>\n<p>若填写<code>all</code>或不填写，则表示针对所有 css 属性都应用过渡</p>\n</li>\n<li>\n<p><strong>持续时间</strong></p>\n<p>css 属性变化所持续的时间，需要带上单位。例如<code>3s</code>表示 3 秒，<code>0.5s</code>或<code>500ms</code>均表示 500 毫秒</p>\n</li>\n<li>\n<p><strong>过渡函数</strong></p>\n<p>本质是 css 属性变化的贝塞尔曲线函数，通常直接使用预设值：</p>\n<p><code>ease-in-out</code>：平滑开始，平滑结束</p>\n<p><code>linear</code>：线性变化</p>\n<p><code>ease-in</code>：仅平滑开始</p>\n<p><code>ease-out</code>：仅平滑结束</p>\n</li>\n<li>\n<p><strong>过渡延迟</strong></p>\n<p>书写规则和持续时间一样，表示过渡效果延迟多久后触发，不填则无延迟</p>\n</li>\n</ul>\n<p><strong>在 JS 中，可以监听元素的<code>transitionstart</code>和<code>transitionend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</strong></p>\n<h2 id="%E5%8A%A8%E7%94%BB-1" tabindex="-1">动画</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">MDN 详细文档</a></p>\n</blockquote>\n<p><strong>动画的本质是预先定义的一套 css 变化规则，然后给该规则取个名字</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210513172902.png" alt="image-20210513172902413"></p>\n<p>然后，其他元素即可使用这样的规则：</p>\n<pre><code class="language-css">animation: 规则名 持续时间;\n</code></pre>\n<p>在应用规则时，还可以指定更多的信息</p>\n<pre><code class="language-css">animation: 规则名 持续时间 重复次数 时间函数 动画方向 延迟时间;\n</code></pre>\n<p>一些细节：</p>\n<ul>\n<li>定义规则时，<code>0%</code>可以书写为<code>from</code></li>\n<li>定义规则时，<code>100%</code>可以书写为<code>to</code></li>\n<li>重复次数为<code>infinite</code>时，表示无限重复</li>\n<li>动画方向为<code>alternate</code>时，表示交替反向，第 1 次正向，第 2 次反向，第 3 次正向，第 4 次方向，以此类推</li>\n</ul>\n<p><strong>在 JS 中，可以监听元素的<code>animationstart</code>和<code>animationnend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</strong></p>\n<h1 id="%E5%85%B6%E4%BB%96-1" tabindex="-1">其他</h1>\n<h2 id="box-sizing-1" tabindex="-1">box-sizing</h2>\n<p>一图胜千言</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514150015.png" alt="image-20210514150015660"></p>\n<p>使用<code>border-box</code>控制尺寸更加直观，因此，很多网站都会加入下面的代码</p>\n<pre><code class="language-css">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2 id="%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87-1" tabindex="-1">字体图标</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN font-face 指令</a></p>\n</blockquote>\n<p>css3 新增了<code>font-face</code>指令，该指令可以让我们加载网络字体</p>\n<p>其最常见的应用就是字体图标</p>\n<p><strong>字体图标本质上是文字，即通过<code>color</code>设置颜色，通过<code>font-size</code>设置尺寸</strong></p>\n<p>国内使用最多的字体图标平台是<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></p>\n<p>登录平台后即可免费使用其所有字体图标</p>\n<h2 id="%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E9%80%82%E5%BA%94-1" tabindex="-1">图像内容适应</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">MDN 详细文档</a></p>\n</blockquote>\n<p>css3 属性<code>object-fit</code>可以控制<strong>多媒体内容和与元素</strong>的适应方式，通常应用在<code>img</code>或<code>video</code>元素中</p>\n<p>一图胜千言</p>\n<p>下图中的所有<code>img</code>元素均被固定了宽高，溢出 img 的部分实际上均不会显示</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514134908.png" alt="image-20210514134908778"></p>\n<h2 id="%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D-1" tabindex="-1">视口单位</h2>\n<p>css3 支持使用<code>vw</code>和<code>vh</code>作为单位，分别表示<code>视口宽度</code>和<code>视口高度</code></p>\n<p>例如<code>1vh</code>表示视口高度的<code>1%</code>，<code>100vw</code>表示视口宽度的<code>100%</code></p>\n<h2 id="%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8-1" tabindex="-1">伪元素选择器</h2>\n<p>通过<code>::before</code>和<code>::after</code>选择器，可以通过 css 给元素生成两个子元素</p>\n<img src="http://mdrs.yuanjin.tech/img/20210514140049.png" alt="image-20210514140049244" style="zoom:50%;" />\n<p>使用伪元素可以避免在 HTML 中使用过多的空元素</p>\n<p><strong>伪元素必须要有<code>content</code>属性，否则不能生效，如果不需要有元素内容，设置<code>content:\'\'</code></strong></p>\n<h2 id="%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8-1" tabindex="-1">平滑滚动</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN 详细文档</a></p>\n</blockquote>\n<p>使用<code>scroll-behavior: smooth</code>，可以让滚动更加丝滑</p>\n<p>参见 MDN 效果即可</p>\n',
        category: { id: 65, name: "CSS" },
      },
      {
        thumb: require("@/assets/Webpack.png"),
        id: 5,
        title: "webpack原理",
        description: "了解经典工程化打包工具原理",
        scanNumber: "1",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "webpack",
            name: "webpack",
            tag: "h1",
            children: [
              { anchor: "%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9F", name: "为什么要工程化？", tag: "h2", children: [] },
              { anchor: "%E5%8E%9F%E7%90%86", name: "原理", tag: "h2", children: [] },
              {
                anchor: "%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86",
                name: "编译原理",
                tag: "h2",
                children: [
                  { anchor: "1.-%E5%88%9D%E5%A7%8B%E5%8C%96", name: "1. 初始化", tag: "h3", children: [] },
                  { anchor: "2.-%E7%BC%96%E8%AF%91", name: "2. 编译", tag: "h3", children: [] },
                  { anchor: "3.-%E8%BE%93%E5%87%BA-emit", name: "3. 输出 emit", tag: "h3", children: [] },
                ],
              },
              { anchor: "loader", name: "loader", tag: "h2", children: [] },
              { anchor: "plugins", name: "plugins", tag: "h2", children: [] },
              { anchor: "webpack.config", name: "webpack.config", tag: "h2", children: [] },
            ],
          },
        ],
        htmlContent:
          '<h1 id="webpack" tabindex="-1">webpack</h1>\n<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9F" tabindex="-1">为什么要工程化？</h2>\n<p><strong>注:node 环境是读取本地文件,不存在此问题</strong>\n<code>devtime</code>:</p>\n<ol>\n<li>模块细粒度</li>\n<li>直接不同模块标准 <strong>CommonJs,ESModule</strong></li>\n<li>使用新语法 <strong>ESNext</strong></li>\n</ol>\n<p><code>runtime</code>:</p>\n<ol>\n<li>文件越少越好:请求少</li>\n<li>体积小：压缩</li>\n<li>越乱越好：不想被篡改逻辑，不想被抄</li>\n<li>执行效率高</li>\n</ol>\n<h2 id="%E5%8E%9F%E7%90%86" tabindex="-1">原理</h2>\n<p>コンパイル結果</p>\n<pre><code class="language-ts">//通过函数环境来避免污染全局变量\n;(function (modules) {\n  const cachedModules = {}\n  //定义一个类似于node环境的require,运行js代码,返回exports\n  function __webpack_require(path) {\n    if (cachedModules[path]) {\n      return cachedModules[path].exports\n    }\n    const module = (cachedModules[path] = {\n      id: path,\n      loaded: false,\n      exports: {},\n    })\n    const exports = module.exports\n    modules[path].call(exports, module, exports, __webpack_require)\n    module.loaded = true\n    return module.exports\n  }\n  __webpack_require.entry = &quot;&quot;\n  __webpack_require.cache = cachedModules\n  return __webpack_require((__webpack_require.entry = &quot;./src/index.js&quot;))\n})({\n  //类似于node环境的commonjs导入\n  // _temp(module,exports, require,__dirname,__filename)只能说除了__dirname,__filename,都一样\n  &quot;./src/a.js&quot;: function (module, exports, require) {\n    //  const a = 1\n    //  console.log(a);\n    //  module.exports = {\n    // \ta\n    //  }\n    //但是这样做会让使用的控制台输出都在当前的js里面,\n    //这肯定是不行的,我们是想去模块里面,eval相当于新开了一个虚拟环境\n    eval(\n      `\n\t\t\tconst a = 1\n\t\t\tconsole.log(a);\n\t\t\tmodule.exports = {\n\t\t\t   a\n\t\t\t} \n\t\t\t` + &quot;//# sourceURL=webpack:///./src/a.js?&quot;\n    )\n  },\n  &quot;./src/b.js&quot;: function (module, exports, require) {\n    const b = 2\n    exports.b = 2\n  },\n  &quot;./src/index.js&quot;: function (module, exports, require) {\n    const a = require(&quot;./src/a.js&quot;)\n    const b = require(&quot;./src/b.js&quot;)\n    console.log(a)\n    console.log(b)\n  },\n})\n</code></pre>\n<h2 id="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86" tabindex="-1">编译原理</h2>\n<h3 id="1.-%E5%88%9D%E5%A7%8B%E5%8C%96" tabindex="-1">1. 初始化</h3>\n<p><strong>加载配置</strong></p>\n<p>类似于 css 计算 <code>computed style</code>,会将 cli 参数,webpack.config.js,默认配置进行融合,生成最终配置对象\n依托于 <code>yargs</code> 库</p>\n<h3 id="2.-%E7%BC%96%E8%AF%91" tabindex="-1">2. 编译</h3>\n<ol>\n<li>\n<p>创建 chunk\nwhat’s chunk?\n根据入口,找所有依赖。每个入口对应一个 chunk</p>\n<pre><code class="language-ts">interface chunk {\n  name: &quot;main&quot; //只有一个入口就是main\n  id: string //开发环境就是name,生产环境会变成数字\n  hash: string //产生chunk assets时,根据所有文件内容生成chunk hash\n}\n</code></pre>\n</li>\n<li>\n<p>构建依赖</p>\n</li>\n</ol>\n<pre><code class="language-ts">interface IChunkModules {\n  //一般是路径,统一转换完整相对路径./src/**/* ./node_modules/**/*\n  [moduleId: string]: string //转换后的代码\n}\nconst moduleCache: IChunkModules = {}\nfunction createDepencies(entryPath) {\n  //1. 判断是否已经加载过该模块\n  if (moduleCache[entryPath]) {\n    return\n  }\n  //2. 没用加载就开始解析\n  // 1) 读取内容\n  const content = fs.readFileSync(entryPath)\n  // 2) AST 抽象语法数分析 这是一棵树\n  const astResult = AST(content)\n  // 3) 遍历树 获取所有依赖 require,import,记录为完整相对路径\n  const dependencies: string[] = loopTree(astResult)\n  // 4) 替换依赖函数 require=&gt;__webpack_require\n  // 5）保存替换后的代码\n  moduleCache[entryPath] = content.replaceAll(&quot;require&quot;, &quot;__webpack_require&quot;) //肯定不能这样写吧\n  // 6) 递归dependencies,深度优先\n  dependencies.forEach((path) =&gt; createDepencies(path))\n}\n</code></pre>\n<ol start="3">\n<li>产生 chunk assets(资源列表) <code>bundle</code>\n根据 chunk 的 modules 生成资源列表。每个项就是对应一个具体文件。也叫 bundle</li>\n</ol>\n<pre><code class="language-ts">{\n\t[文件名: string]:文件内容\n\t\'./dist/bundle.js\':(function (modules){})({\n\t   \'./src/a.js\':function (module,exports,require){\n\t\t\t//  const a = 1\n         //  console.log(a);\n\t\t\t//  module.exports = {\n\t\t\t// \ta\n\t\t\t//  }\n\t\t\t //但是这样做会让使用的控制台输出都在当前的js里面,\n\t\t\t //这肯定是不行的,我们是想去模块里面,eval相当于新开了一个虚拟环境\n\t\t\teval(`\n\t\t\tconst a = 1\n\t\t\tconsole.log(a);\n\t\t\tmodule.exports = {\n\t\t\t   a\n\t\t\t}\n\t\t\t`+&quot;//# sourceURL=webpack:///./src/a.js?&quot;);\n\t\t},\n})\n</code></pre>\n<ol start="4">\n<li>合并 chunk assets(可能有多个 chunk)\n合并 chunk assets,生成总 hash</li>\n</ol>\n<h3 id="3.-%E8%BE%93%E5%87%BA-emit" tabindex="-1">3. 输出 emit</h3>\n<p>将合并后 chunk assets 通过 fs 模块输出</p>\n<h2 id="loader" tabindex="-1">loader</h2>\n<p>本质: 文件内容=&gt;可以别分析(js 内容)</p>\n<pre><code class="language-ts">  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/, //路径匹配\n        // use: [&quot;ts-loader&quot;],//loader路径配置,其实用的就是node的require\n        use: [\n          {\n            loader: [&quot;ts-loader&quot;],\n            options: {\n\t\t\t\t//配置通过loader-utils取this上读取\n\t\t\t},\n          },\n        ],\n        exclude: /node_modules/,\n      },\n    ],\n  },\n</code></pre>\n<p><strong>注:loaders 是倒着执行的,类似于 decorator</strong></p>\n<pre><code class="language-ts">{\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        use: [&quot;./src/loaders/testloader/loader&quot;, &quot;./src/loaders/testloader/loader2&quot;],\n      },\n      {\n        test: /test\\.js/,\n        use: [&quot;./src/loaders/testloader/loader3&quot;, &quot;./src/loaders/testloader/loader2&quot;],\n      },\n    ]\n  }\n}\n\n// 输出结果\n2\n3\n2\n1\n\n// 原理\n\nlet fscontent = xxx\nconst rules = []\n///\\.js/匹配成功\nrules.push(...[&quot;./src/loaders/testloader/loader&quot;, &quot;./src/loaders/testloader/loader2&quot;])\n///test\\.js/ 匹配成功\nrules.push(...[&quot;./src/loaders/testloader/loader3&quot;, &quot;./src/loaders/testloader/loader2&quot;])\n\nfor (let i = rules.length - 1; i + 1; i--) {\n  const loader = require(rules[i])\n  //将fs读取内容交给loader\n  fscontent = loader(fscontent)\n}\nreturn fscontent\n</code></pre>\n<p>例 css loader</p>\n<pre><code class="language-ts">//entry.js\nrequire(&quot;./style/index.css&quot;)\n//require本身肯定是不能读取css\n//webpack是肯定能读取出来文件内容的,错误发生在抽象AST分析那块\n//也就是说只有通过loader,将文件内容=&gt;可以别分析(js内容)就行\n\n// webpack.config.js\n//\n {\n        test: /\\.css/,\n        use: [&quot;./src/loaders/cssLoader&quot;],\n }\n\n //loader\n module.exports = function (sourceCode) {\n  const res = `\n    const style = document.createElement(&quot;style&quot;)\n    style.innerHTML = \\`${sourceCode}\\`\n    document.head.appendChild(style)\n    module.exports = \\`${sourceCode}\\`\n  `\n  //   console.log(res)\n  return res\n}\n</code></pre>\n<h2 id="plugins" tabindex="-1">plugins</h2>\n<p>与 loaders 不同,plugins 是用于处理 webpack 编译过程中的 hooks</p>\n<pre><code class="language-ts">import { Compilation, Compiler } from &quot;webpack&quot;\n\nclass Compiler {\n  //创建于初始化阶段\n  //编译与输出这些操作是内部创建的Compilation完成\n  // watch时,重新编译只是重新创建Compilation\n}\n//统计bundle大小的plugins\nclass MyPlugin {\n  //创建Compiler之后就会运行apply\n  apply(compiler: Compiler) {\n    compiler.hooks.emit.tap(&quot;MyFilePlugin&quot;, (compilation) =&gt; {\n      const assets = Object.keys(compilation.assets)\n      const res = assets\n        .map((x) =&gt; {\n          const size = compilation.assets[x].size()\n\n          return `[${x}]:\n    \t  size:${size / 1000}kb\n    \t`\n        })\n        .join(&quot;\\n\\n&quot;)\n      compilation.assets[this.filmeName] = {\n        source() {\n          return res\n        },\n        size() {\n          return Buffer.from(res).byteLength\n        },\n      }\n    })\n  }\n}\n</code></pre>\n<h2 id="webpack.config" tabindex="-1">webpack.config</h2>\n<p>导出可以使用函数,增加可操作性</p>\n<pre><code class="language-ts">module.export = (env) =&gt; {\n  return {\n    entry: {\n      main: &quot;./src/index.js&quot;,\n    },\n  }\n}\n</code></pre>\n',
        category: { id: 67, name: "Webpack" },
      },
      {
        thumb: require("@/assets/HTTP.png"),
        id: 1,
        title: "HTTP与HTTPS协议",
        description: "了解HTTP与HTTPS协议,学习网络请求原理",
        scanNumber: "0",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "http",
            name: "http",
            tag: "h1",
            children: [
              { anchor: "c%2Fs-b%2Fs", name: "c/s b/s", tag: "h2", children: [] },
              { anchor: "url-uniform-resource-location", name: "url uniform resource location", tag: "h2", children: [] },
              {
                anchor: "http-protocol-%E5%BB%BA%E7%AB%8B%E5%9C%A8-tcp%2Fip-%E5%9F%BA%E7%A1%80%E4%B8%8A",
                name: "http protocol 建立在 TCP/IP 基础上",
                tag: "h2",
                children: [
                  { anchor: "request", name: "Request", tag: "h3", children: [] },
                  { anchor: "response", name: "Response", tag: "h3", children: [] },
                ],
              },
              { anchor: "ajax-webapi", name: "ajax webApi", tag: "h2", children: [] },
              {
                anchor: "https-protocol-%E5%BB%BA%E7%AB%8B%E5%9C%A8-tcp%2Fip-ssl(%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE)%E4%B9%8B%E4%B8%8A",
                name: "https protocol 建立在 TCP/IP SSL(加密协议)之上",
                tag: "h2",
                children: [{ anchor: "%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F", name: "加密方式", tag: "h3", children: [] }],
              },
            ],
          },
        ],
        htmlContent:
          '<h1 id="http" tabindex="-1">http</h1>\n<h2 id="c%2Fs-b%2Fs" tabindex="-1">c/s b/s</h2>\n<p><code>client</code> <code>browser</code> <code>server</code>\n服务器就是一个应用程序,监听某一个 port\n客户端也就一个应用程序\n发出 Request 的是客户端\n响应 Response 的是服务器</p>\n<h2 id="url-uniform-resource-location" tabindex="-1">url uniform resource location</h2>\n<p>http://www.baidu.com/s?wd=test#home\nschema/protocol http\nhost: www.baidu.com /ip\nport: 80\npath:/s\nparams:?wd=test\nhash:#home</p>\n<h2 id="http-protocol-%E5%BB%BA%E7%AB%8B%E5%9C%A8-tcp%2Fip-%E5%9F%BA%E7%A1%80%E4%B8%8A" tabindex="-1">http protocol 建立在 TCP/IP 基础上</h2>\n<ol>\n<li>每次请求-响应是独立的。断开式连接。</li>\n<li>传递消息都是 string, 格式为</li>\n</ol>\n<h3 id="request" tabindex="-1">Request</h3>\n<pre><code class="language-ts">   请求行          post  /api/user  HTTP/1.1\n   请求头 Header   Content-Type: application/json\n                  User-Agent: Molila5.0 ………………\n\t\t\t\t  HOST:\n\t\t\t\t  origin:\n\t\t\t\t  Connection:\n\n   请求体 Body    {\n\t                 id:xxxx\n                  }\n\n\n</code></pre>\n<p>约定俗成的</p>\n<p>get delete 没有 body,传参只能 params\npost put 有</p>\n<p><strong>Content-Type</strong></p>\n<ol>\n<li>\n<p>x-www-form-urlencoded</p>\n<pre><code class="language-ts">id = xxx\n</code></pre>\n</li>\n<li>\n<p>json</p>\n<pre><code class="language-ts">{\n  id: xxx\n}\n</code></pre>\n</li>\n<li>\n<p>form-data</p>\n</li>\n</ol>\n<p>​ 文件上传</p>\n<h3 id="response" tabindex="-1">Response</h3>\n<pre><code class="language-ts">   响应行  HTTP/1.1 200 Ok\n   响应头  Content-Type: text/html;charset=utf-8\n          Server: BWS/1.1\n\n   响应体  &lt;html&gt;&lt;/html&gt;\n\n</code></pre>\n<p>响应码\n1** 信息 服务器接到请求 需要客户端继续发送\n2** 成功\n3** 重定向\n4** 客户端错误\n5** 服务器错误</p>\n<h2 id="ajax-webapi" tabindex="-1">ajax webApi</h2>\n<pre><code class="language-ts">// //原生ajax\nconst xhr = new XMLHttpRequest()\n\nxhr.onreadystatechange = function () {\n  switch (xhr.readyState) {\n    case 1:\n      console.log(&quot;open 方法被调用&quot;)\n      break\n    case 2:\n      console.log(&quot;send method execute&quot;)\n      break\n    case 3:\n      console.log(&quot;receiving response body&quot;)\n      break\n    case 4:\n      console.log(&quot;received all response&quot;)\n      const res = JSON.parse(xhr.responseText)\n      break\n  }\n}\n\nxhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/json&quot;)\nxhr.open(&quot;post&quot;, &quot;www.baidu.com&quot;)\nxhr.send(\n  JSON.stringify({\n    a: 1,\n  }) || null\n)\n\n// Fetch 使用ES6 Promise方法实现ajax\nfetch(&quot;www.baidu.com&quot;, {\n  method: &quot;post&quot;,\n  headers: {\n    &quot;Content-Type&quot;: &quot;application/json&quot;,\n  },\n  body: JSON.stringify({}),\n}).then((res) =&gt; res.json() /**继续接收响应体 */)\n</code></pre>\n<h2 id="https-protocol-%E5%BB%BA%E7%AB%8B%E5%9C%A8-tcp%2Fip-ssl(%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE)%E4%B9%8B%E4%B8%8A" tabindex="-1">https protocol 建立在 TCP/IP SSL(加密协议)之上</h2>\n<h3 id="%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F" tabindex="-1">加密方式</h3>\n<ol>\n<li>对称加密 加密解密都有同一个 key</li>\n<li>非对称加密 生成一对密钥, 公钥加密只能用私钥解密</li>\n</ol>\n<p>现在的传输方式大概</p>\n<p>A ----公钥----&gt; B\n&lt;---公钥<em>key--\n-----key</em>(data)--&gt;\n但是第三方可以篡改，他保存别人的公钥，放送出自己的公钥，之后的通信就会被篡改</p>\n<p><strong>https 原理</strong>\n使用 Certificate Authority 的私钥 加密 网站的公钥，网站的证书签名(signature)，加上颁发机构，网站域名生成证书 Digital Certificate</p>\n<p>公钥谁都能有,所以里面的公钥谁都能看到，但是你想篡改，浏览器可以通过这些公开信息计算出网站的证书签名,如果发现计算出来的签名和你给的签名不一致，\n就是被发现</p>\n<pre><code>\t\t\t\t ---域名,网站公钥---&gt;CA ---&gt;域名,网站的公钥,CA公钥通过算法生成签名---&gt;生成DA\n\t\t\t\tA&lt;-------DA--------\n    B&lt;---DA(有A的公钥)-----\n    B-A的公钥*key--&gt;\n\t &lt;---key*data-&gt;\n</code></pre>\n<p>​</p>\n',
        category: { id: 73, name: "Network" },
      },
      {
        thumb: require("@/assets/NPM.png"),
        id: 6,
        title: "node包管理器",
        description: "常见包管理器及其区别",
        scanNumber: "0",
        commentNumber: "4",
        createDate: "2024-09-16",
        toc: [
          {
            anchor: "npm-node-package-manager",
            name: "npm node package manager",
            tag: "h1",
            children: [
              { anchor: "%E5%8E%86%E5%8F%B2", name: "历史", tag: "h2", children: [] },
              { anchor: "%E8%AE%BE%E7%BD%AE%E4%B8%8B%E8%BD%BD%E6%BA%90", name: "设置下载源", tag: "h2", children: [] },
              { anchor: ".gitignore", name: ".gitignore", tag: "h2", children: [] },
              { anchor: "%E5%AE%89%E8%A3%85-npm-install", name: "安装 npm install", tag: "h2", children: [] },
              {
                anchor: "%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-npm-init",
                name: "配置文件 npm init",
                tag: "h2",
                children: [
                  { anchor: "package.json", name: "package.json", tag: "h3", children: [] },
                  { anchor: "package-lock.json", name: "package-lock.json", tag: "h3", children: [] },
                ],
              },
              { anchor: "%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC", name: "语义版本", tag: "h2", children: [] },
              { anchor: "script", name: "script", tag: "h2", children: [] },
              { anchor: "json-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8", name: "json 文件的使用", tag: "h2", children: [] },
              { anchor: "%E5%91%BD%E4%BB%A4", name: "命令", tag: "h2", children: [] },
              { anchor: "%E5%8F%91%E5%B8%83", name: "发布", tag: "h2", children: [] },
            ],
          },
          { anchor: "yarn", name: "yarn", tag: "h1", children: [] },
          { anchor: "cnpm-%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89", name: "cnpm 没有意义", tag: "h1", children: [] },
          {
            anchor:
              "nvm-node-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5-nvm%2C%E5%A4%A7%E6%A6%82%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%87%BA%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4%2C%E5%B9%B2%E5%95%A5%E7%9A%84",
            name: "nvm node 版本管理工具 安装之后直接 nvm,大概就能看出来哪些命令,干啥的",
            tag: "h1",
            children: [],
          },
          { anchor: "pnpm", name: "pnpm", tag: "h1", children: [{ anchor: "pnpm-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84", name: "pnpm 目录结构", tag: "h3", children: [] }] },
        ],
        htmlContent:
          '<h1 id="npm-node-package-manager" tabindex="-1">npm node package manager</h1>\n<h2 id="%E5%8E%86%E5%8F%B2" tabindex="-1">历史</h2>\n<p>node 模块化 ==&gt; 第三方 lib 发展==&gt;包管理复杂化==&gt;npm 应运而生==&gt;node 发展 npmjs.com，cli=&gt;command-line interface</p>\n<h2 id="%E8%AE%BE%E7%BD%AE%E4%B8%8B%E8%BD%BD%E6%BA%90" tabindex="-1">设置下载源</h2>\n<p>registry(注册) 数据库服务器\nnpm config set registry https://registry.npm.taobao.org\nnmp config get registry</p>\n<h2 id=".gitignore" tabindex="-1">.gitignore</h2>\n<p>node_modules\n源码要忽略 node_modules</p>\n<h2 id="%E5%AE%89%E8%A3%85-npm-install" tabindex="-1">安装 npm install</h2>\n<p>npm install axios jquery 可以一下安装多个\nnpm i axios jquery\n(以前要加 --save/-S 保存到 package.json 里面,现在不需要)\nnpm i prettier -D/--save-dev 安装到 dev 里面\nnpm i typescript --global/-g</p>\n<p>npm i --production 只安装生产环境包</p>\n<p>有些 package 会提供 cli\n这时这些命令会存在 node_module/.bin 通过 npx 运行 (非全局安装)\nusr/appdata/roaming/npm</p>\n<h2 id="%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-npm-init" tabindex="-1">配置文件 npm init</h2>\n<h3 id="package.json" tabindex="-1">package.json</h3>\n<p>大部分看名字就知道了，就略了\nmain:\'index.js\' entry point 0. 是不是 node 内部模块 require(\'fs\')\nrequire(\'jquery\') =&gt; 1.当文件找 node_modules/jquery.js 如果找不到就 2 2.当包来找 有没有 package.json 且配置了 main, 有就 node_modules/jquery/${main}.js\n没有就 node_modules/jquery/index.js 3.返回上一级重复</p>\n<h3 id="package-lock.json" tabindex="-1">package-lock.json</h3>\n<p>有时，依赖过于复杂，可能不同 package 依赖同一个 package 的不太大版本，各种冲突\nlock 记录了此项目的所有确切依赖关系\n项目中存在 package-lock.json 时，会安装 package-lock.json 内容，不存在才会安装 package.json</p>\n<h2 id="%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC" tabindex="-1">语义版本</h2>\n<p>你编写一个包依赖一个 package，别人安装你的包的时候，你想要他安装的 package 是和你的一样还是可以最新？</p>\n<pre><code class="language-js">   &gt; 大于版本\n\t  &gt;=\n\t  &lt;\n\t  &lt;=\n\t  - 1.2.1-3.4.1 之间\n\t  x  1.1.x  补丁版本号随意\n\t  ~  ~1.1.6  补丁版本&gt;=6\n\t  ^  ^4.4.0  主版本不变\n\t  *  lastest 最新\n</code></pre>\n<h2 id="script" tabindex="-1">script</h2>\n<pre><code> 脚本里面可以省略npx\n start、test、stop可以省略run\n npm start 默认serve.js\n\n ```js\n   start: &quot;nodemon script/start.js&quot;\n ```\n ## 环境变量\n 1. 永久设置 process.env.NODE_ENV (系统环境变量里面加一个NODE_ENV变量) 但不推荐\n 2. 临时设置 windows: set NODE_ENV=development\n             mac: export NODE_ENV=development\n\t\t\t 可以用插件在script中兼容\n</code></pre>\n<h2 id="json-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8" tabindex="-1">json 文件的使用</h2>\n<p>直接 require</p>\n<pre><code class="language-js">const json = require(&quot;./package.json&quot;)\n</code></pre>\n<h2 id="%E5%91%BD%E4%BB%A4" tabindex="-1">命令</h2>\n<ol>\n<li>\n<p>精确安装最新版\nnpm i --save-exact/-E package &lt;=&gt; &quot;konva&quot;: &quot;9.3.6&quot;(此时的最新版)</p>\n</li>\n<li>\n<p>指定版本\nnpm i lodash@2.1.1</p>\n</li>\n<li>\n<p>查询安装路径\nnpm root [-g]</p>\n</li>\n<li>\n<p>查看包的信息(直接看官网的)\nnpm view vue\nview aliases:v info show</p>\n</li>\n<li>\n<p>查看安装包\nnpm list [-g] [--depth=\'依赖深度\']\nlist aliases:ls la ll</p>\n</li>\n<li>\n<p>查看可以更新包\nnpm outdated</p>\n</li>\n<li>\n<p>更新\nnpm update [-g] [package]\nupdate aliases: up, upgrade</p>\n</li>\n<li>\n<p>卸载\nnpm uninstall [-g] package</p>\n</li>\n<li>\n<p>npm config ls [-l] [--json] 查看生效的配置</p>\n</li>\n<li>\n<p>npm config get/set/delete 配置 npm config get registry</p>\n</li>\n<li>\n<p>查看依赖包 漏洞\nnpm audit</p>\n</li>\n<li>\n<p>查看为啥安装这个包\nnpm explain vue</p>\n</li>\n</ol>\n<p>更新 npm:\nnpm i npm -g 全局安装 npm 最新版,此时的 npm 将使用全局的 npm 命令\nnpm update -g npm 更新全局安装的 npm</p>\n<h2 id="%E5%8F%91%E5%B8%83" tabindex="-1">发布</h2>\n<p>注册 npm 官网账号\nnpm cli 登录\nnpm login/logout\nnpm whoami\n填写 packjson</p>\n<p>添加 LICENSE http://choosealicense.online/appendix\n添加 README.MD\nnpm publish</p>\n<h1 id="yarn" tabindex="-1">yarn</h1>\n<p>当时的 npm 很垃圾,串行下载啊,非扁平结构,输出繁琐,没有 npx……\n于是 Facebook,chrome 等大公司就制作了 yarn,优化 npm 操作\n现在的 npm 与 yarn 的差别不大</p>\n<h2 id="%E5%91%BD%E4%BB%A4-1" tabindex="-1">命令</h2>\n<p>yarn init --yes/-y</p>\n<p>yarn [global/-g] add package@ package [--dev/-D] [--exact/-E]</p>\n<p>yarn install [--production/--prod] 安装所有</p>\n<p>yarn run script (start,stop,test)可以省略 run\nyarn run package 内置命令 (npx 学的它)</p>\n<p>yarn [global/-g] bin 查看包的命令文件夹\nyarn info package 字段名\nyarn [global/-g] list [--depth]</p>\n<p>yarn outdate</p>\n<p>yarn [global/-g] update</p>\n<p>yarn remove package</p>\n<p>yarn check 查看 package.json 与 yarn.lock 是否匹配\nyarn audit\nyarn why</p>\n<p>yarn create 用于安装脚手架\n过去的做法</p>\n<ol>\n<li>全局安装 yarn add create-react-app -g</li>\n<li>运行脚手架命令 create-react-app my-app\n使用 yarn create\nyarn create react-app my-app</li>\n</ol>\n<h1 id="cnpm-%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89" tabindex="-1">cnpm 没有意义</h1>\n<p>现在可以使用 npm config set registry 修改,</p>\n<h1 id="nvm-node-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5-nvm%2C%E5%A4%A7%E6%A6%82%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%87%BA%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4%2C%E5%B9%B2%E5%95%A5%E7%9A%84" tabindex="-1">nvm node 版本管理工具 安装之后直接 nvm,大概就能看出来哪些命令,干啥的</h1>\n<p>nvm install\nnvm use</p>\n<h1 id="pnpm" tabindex="-1">pnpm</h1>\n<p>简洁的 node_modules 目录\n避免使用间接依赖\n降低磁盘占用<br>\n原理: 直接下载到到当前盘副的根目录,每次安装如果存在会直接建立链接非拷贝(类似快捷方式),也就是说包存在一份\n回到了树形结构</p>\n<p>[扩展] 文件本质是一个指向外部存储的指针\n删除的是指针,所以删除和大小无关。也是为啥数据可以恢复的原因。</p>\n<pre><code>\t 硬链接：unix操作系统中,将一个新指针指向当前位置,相当于引用\n\t         现在windows中也支持硬链接\n\t\t\t mklink /h 链接名称 目标文件(只能是文件不能是文件夹)\n\t\t\t 删除不影响硬链接\n\t 软链接(符号链接): 指向文件夹或文件\n\t         mklin /d 链接名称 目标文件\n\t\t\t 符号链接始终和链接内容关联\n\n\tnode中: node无法区分是不是硬链接\n\t        软链接会找到原始位置执行\n\tpnpm 的结构是\n</code></pre>\n<h3 id="pnpm-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" tabindex="-1">pnpm 目录结构</h3>\n<pre><code class="language-ts">node_modules\n  .pnpm\n\t node_modules  // 所有间接依赖\n     registry      // 所有直接依赖资源  每个依赖都包含着版本\n\t\t  node_modules\n\t\t  自己的源码 硬链接\n\t\t  直接依赖  registry下面依赖的软链接\n\n   librarys //.pnpm 下面 registry 下面直接依赖的软链接\n</code></pre>\n',
        category: { id: 74, name: "NPM" },
      },
    ],
  },
} as unknown as IResponse<IArticles>

export const blogDetail4JP = {
  2: {
    code: 200,
    data: {
      id: 2,
      title: "NodeJs勉強",
      description: "一直很在意的工程化问题,只有通过node的学习了解全貌,对传统后端经验及前端经验的人并不困难",
      scanNumber: "4",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "node",
          name: "node",
          tag: "h1",
          children: [
            {
              anchor: "%E6%A6%82%E8%A6%81",
              name: "概要",
              tag: "h2",
              children: [
                { anchor: "what's-node", name: "what's node", tag: "h3", children: [] },
                { anchor: "%E3%81%AA%E3%81%9C%E3%83%8E%E3%83%BC%E3%83%89%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E3%81%AE%E3%81%8B", name: "なぜノードが必要なのか", tag: "h3", children: [] },
                { anchor: "%E7%89%B9%E5%BE%B4", name: "特徴", tag: "h3", children: [] },
              ],
            },
            { anchor: "global", name: "global", tag: "h2", children: [] },
            {
              anchor: "%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E5%8C%96-commonjs",
              name: "モジュール化 commonJs",
              tag: "h2",
              children: [
                { anchor: "%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E6%A4%9C%E7%B4%A2", name: "モジュール検索", tag: "h3", children: [] },
                { anchor: "module", name: "module", tag: "h3", children: [] },
                { anchor: "require", name: "require", tag: "h3", children: [] },
                { anchor: "nodejs-%E3%81%A7-es-module-%E4%BD%BF%E3%81%88%E3%82%8B%E3%81%8B", name: "NodeJS で ES Module 使えるか", tag: "h3", children: [] },
              ],
            },
            {
              anchor: "%E5%86%85%E9%83%A8%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB",
              name: "内部モジュール",
              tag: "h2",
              children: [
                { anchor: "os", name: "os", tag: "h3", children: [] },
                { anchor: "path", name: "path", tag: "h3", children: [] },
                { anchor: "url", name: "url", tag: "h3", children: [] },
                { anchor: "util", name: "util", tag: "h3", children: [] },
                { anchor: "fs", name: "fs", tag: "h3", children: [] },
                { anchor: "stream", name: "stream", tag: "h3", children: [] },
                { anchor: "net-net", name: "net net", tag: "h3", children: [] },
                { anchor: "events", name: "events", tag: "h3", children: [] },
              ],
            },
            { anchor: "%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB", name: "ライフサイクル", tag: "h2", children: [] },
            { anchor: "node-orm", name: "node ORM", tag: "h2", children: [{ anchor: "sequelize", name: "Sequelize", tag: "h3", children: [] }] },
            { anchor: "logjs", name: "logjs", tag: "h2", children: [] },
            {
              anchor: "express-(%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E7%9B%B4%E6%8E%A5%E5%87%A6%E7%90%86%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93)",
              name: "Express (非同期エラーを直接処理できません)",
              tag: "h2",
              children: [
                { anchor: "rest-style", name: "rest style", tag: "h3", children: [] },
                { anchor: "route", name: "Route", tag: "h3", children: [] },
                { anchor: "middleware", name: "middleWare", tag: "h3", children: [] },
                { anchor: "cookie%2Csession%2Cjwt", name: "cookie,session,jwt", tag: "h3", children: [] },
                { anchor: "session", name: "session", tag: "h3", children: [] },
                { anchor: "jwt", name: "jwt", tag: "h3", children: [] },
                { anchor: "cors", name: "CORS", tag: "h3", children: [] },
              ],
            },
            {
              anchor: "%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89-%E4%B8%89%E5%B1%A4%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3",
              name: "バックエンド 三層アーキテクチャ",
              tag: "h2",
              children: [],
            },
            { anchor: "service", name: "Service", tag: "h2", children: [] },
            { anchor: "dao", name: "DAO", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="node" tabindex="-1">node</h1>\n<h2 id="%E6%A6%82%E8%A6%81" tabindex="-1">概要</h2>\n<h3 id="what\'s-node" tabindex="-1">what\'s node</h3>\n<p>js 実行環境\n通常:\nブラウザ側 =&gt; <code>JavaScript</code>\nノード =&gt; <code>nodeJs</code></p>\n<h3 id="%E3%81%AA%E3%81%9C%E3%83%8E%E3%83%BC%E3%83%89%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%AA%E3%81%AE%E3%81%8B" tabindex="-1">なぜノードが必要なのか</h3>\n<p>ブラウザでは js インタプリタ+webapi(Dom Bom ajax)のみ提供\n制限された機能</p>\n<ol>\n<li>ファイルの読み取りと書き込みの制限</li>\n<li>クロスドメインの問題\nnode js + NodeApi でコンピュータ(システム)を完全制御可能\nアプリケーションやサーバーアプリケーションを開発できる</li>\n</ol>\n<h3 id="%E7%89%B9%E5%BE%B4" tabindex="-1">特徴</h3>\n<p>シングルスレッド IO\n計算にては従来のバックエンドほど良くありません</p>\n<h2 id="global" tabindex="-1">global</h2>\n<p><code>Window</code>と一緒</p>\n<pre><code class="language-ts">       const global = {\n    \t  setTimeout():Object{\n\n    \t  },\n    \t  setImmediate(){\n\n    \t  },\n    \t  setInterval(){\n\n    \t  },\n    \t  console,\n\n    \t  process:{\n    \t\t  //命令行目录\n    \t\t   cwd(){},\n    \t\t   //强制退出node进程\n    \t\t   exit(){},\n    \t\t   //命令行中参数\n    \t\t   argv,\n    \t\t   //操作系统\n    \t\t   platform,\n    \t\t   //杀进程\n    \t\t   kill(pid){},\n    \t\t   //环境变量\n    \t\t   env\n    \t  },\n\n\n   /**\n\t* コンピュータのメモリアドレスの最新単位はバイトで、1バイト＝8ビット（1ビットは2進数）となります。 *4bit は 2^4=16 *0-15 の範囲の数値を表現できます。つまり、16 進数を使用するだけです\n    * はバイトバイトを表します。このバッファでは 16 進数が使用されます\n    */\n    \t  Buffer,\n\n\n       }\n\t   //`Window`と一緒\n       global.global = global\n\n       //グローバルだがglobalにはない\n       __dirname,\n       __filename,\n\n</code></pre>\n<h2 id="%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E5%8C%96-commonjs" tabindex="-1">モジュール化 commonJs</h2>\n<h3 id="%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E6%A4%9C%E7%B4%A2" tabindex="-1">モジュール検索</h3>\n<pre><code class="language-ts">\t   // 1.絶対パス\n\t   require(\'D:\\\\XXXX\')\n\t   //2. 相対パス\n\t\t//1)\n\t\trequire(\'./src\')\n\t\t//2)\n\t\trequire(\'axios\')\n\t    //  見つかったら絶対パスに変換してインポートします。\n\n\t//    サフィックス\n\t//   オートコンプリート\n\tjs json node mjs\n\n\t// ファイル名の検索順序\n\t     require(\'./src\')\n\t\t //  1.ファイルとして\n\t\t src.js/json/node/mjs\n\t\t// 2.packageとして\n\t\t ./src/main/index.js\n\n</code></pre>\n<h3 id="module" tabindex="-1">module</h3>\n<p>現在のモジュールに関する記録された情報</p>\n<pre><code class="language-js">\t{\n\t\t//绝对路径当id\n\t\tid: \'E:\\\\Tlight\\\\node\\\\dist\\\\module.js\',\n\t\tpath: \'E:\\\\Tlight\\\\node\\\\dist\',\n\t\texports: {},\n\t\tfilename: \'E:\\\\Tlight\\\\node\\\\dist\\\\module.js\',\n\t\tloaded: false,\n\t\tchildren: [],\n\t\tpaths: [    //这就是一层一层往上找包的原因\n\t\t\t\'E:\\\\Tlight\\\\node\\\\dist\\\\node_modules\',\n\t\t\t\'E:\\\\Tlight\\\\node\\\\node_modules\',\n\t\t\t\'E:\\\\Tlight\\\\node_modules\',\n\t\t\t\'E:\\\\node_modules\'\n\t\t]\n\t}\n</code></pre>\n<h3 id="require" tabindex="-1">require</h3>\n<pre><code class="language-js">{\n\t//返回绝对路径\n  resolve: [Function: resolve] { paths: [Function: paths] }, //静态方法\n  //入口模块\n  main: {\n    id: \'.\',\n    path: \'E:\\\\Tlight\\\\node\\\\dist\',\n    exports: {},\n    filename: \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\',\n    loaded: false,\n    children: [],\n    paths: [\n      \'E:\\\\Tlight\\\\node\\\\dist\\\\node_modules\',\n      \'E:\\\\Tlight\\\\node\\\\node_modules\',\n      \'E:\\\\Tlight\\\\node_modules\',\n      \'E:\\\\node_modules\'\n    ]\n  },\n  extensions: [Object: null prototype] { //自动解析的文件类型\n    \'.js\': [Function (anonymous)],\n    \'.json\': [Function (anonymous)],\n    \'.node\': [Function (anonymous)]\n  },\n  //缓存的模块对象\n  cache: [Object: null prototype] {\n    \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\': {\n      id: \'.\',\n      path: \'E:\\\\Tlight\\\\node\\\\dist\',\n      exports: {},\n      filename: \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\',\n      loaded: false,\n      children: [],\n      paths: [Array]\n    }\n  }\n}\n</code></pre>\n<p>例えば、一つの Module があって、理解できますか。</p>\n<pre><code class="language-js">console.log(__dirname, __filename)\nmodule.exports = {\n  a: 1,\n}\nexports.b = 2\nthis.c = 3\n</code></pre>\n<p><strong>require 原理</strong></p>\n<pre><code class="language-js">   function require(modulePath){\n\t  //step1 絶対パスに変換する\n\t  const absolutePath = xxx(modulePath)\n\t  //step2 キャッシュされているかどうかを確認する\n\t  if(require.cache[absolutePath]){\n\t\t //されたら、キャッシュされた結果を直接返します。\n\t\t return require.cache[absolutePath].result\n\t  }\n\t  //step3 ファイルの内容を読み取る\n      const fileContent = xxx()\n\t  //step4 関数にラップされる\n\t  function _temp(module,exports, require,__dirname,__filename){\n\t\t...fileContent\n\t\t// console.log(__dirname, __filename);\n\t\t// module.exports = {\n\t\t// a: 1,\n\t\t// };\n\t\t// exports.b = 2;\n\t\t// this.c = 3;\n\t  }\n\n\t  //5.モジュールオブジェクトの作成\n\t  module.exports = {}\n\t  const exports = module.exports\n\n\t  _temp.call(module.exports,module,exports,require,module.path,module.filename)\n\n\t  require.cache[module.id] = module.exports\n      return module.exports\n   }\n\n</code></pre>\n<p><code>exports === this</code></p>\n<h3 id="nodejs-%E3%81%A7-es-module-%E4%BD%BF%E3%81%88%E3%82%8B%E3%81%8B" tabindex="-1">NodeJS で ES Module 使えるか</h3>\n<pre><code class="language-mjs">// 子模块\nexport const a = 1\nexport default 1\n</code></pre>\n<pre><code class="language-mjs">// 父模块\nimport * as obj from &quot;./es.mjs&quot;\nconsole.log(obj)\n</code></pre>\n<p>使えますが、相互運用性の問題があります。自分使う時は統一されたべき。もちろん webpack とか を使えば解決できます。\n私の現在の ts は Object.defineProperty(exports, &quot;＿esModule&quot;, { value: true }); をコンパイルしました。</p>\n<p>es モジュールの静的読み込みを、require と同様の関数環境に変換します。</p>\n<h2 id="%E5%86%85%E9%83%A8%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB" tabindex="-1">内部モジュール</h2>\n<blockquote>\n<p><a href="https://nodejs.org/docs/">詳細ドキュメント</a></p>\n</blockquote>\n<h3 id="os" tabindex="-1">os</h3>\n<pre><code class="language-ts">//システム改行文字\nconsole.log(os.EOL)\n//アーキテクチャ x64\nconsole.log(os.arch())\n//cpus\nconsole.log(os.cpus())\n//freeメモリ\nconsole.log(os.freemem())\n// ユーザーディレクトリ\nconsole.log(os.homedir())\n//ホスト名\nconsole.log(os.hostname())\n//ディレクトリ\nconsole.log(os.tmpdir())\n</code></pre>\n<h3 id="path" tabindex="-1">path</h3>\n<p>filename d:\\xxx.txt 絶対パス\nbasename xxx.txt</p>\n<pre><code class="language-ts">const basename = path.basename(&quot;xxx/xxxx/a.txt&quot;, &quot;html&quot;)\nconsole.log(basename)\nconst dir = path.dirname(&quot;xxx/xxxx/a.txt&quot;)\nconsole.log(dir)\n\nconst ext = path.extname(&quot;xxx/xxx/a.txt&quot;)\nconsole.log(ext)\n\nconst fullpath = path.join(&quot;d:/t&quot;, &quot;a&quot;, &quot;index&quot;, &quot;./test&quot;)\nconsole.log(fullpath)\n\n//分隔符\\\nconst separate = path.sep\nconsole.log(separate)\n\n//;\nconst d = path.delimiter\nconsole.log(process.env.PATH?.split(d))\n\nconst validpath = path.normalize(&quot;D:/a/b/index.ts&quot;)\nconsole.log(validpath)\n\nconst relativePath = path.relative(&quot;a/b/c&quot;, &quot;a/index&quot;)\nconsole.log(relativePath)\n\n//是相当于命令行\nconst absolutePath = path.resolve(&quot;./a.js&quot;)\nconst absolutePathBymodule = path.resolve(__dirname, &quot;./a.js&quot;)\nconsole.log(absolutePath, absolutePathBymodule, __dirname)\n</code></pre>\n<h3 id="url" tabindex="-1">url</h3>\n<pre><code class="language-ts">const u = new url.URL(&quot;http://qcscimdb.benq.corp.com:81/MAI1InspectionResolve/#/home?user=Tlight.HY.Xia&quot;)\nconsole.log(u, u.searchParams.has(&quot;user&quot;))\n\nfor (let key of u.searchParams) {\n  console.log(key)\n}\nconst config = {\n  href: &quot;http://qcscimdb.benq.corp.com:81/MAI1InspectionResolve&quot;,\n  origin: &quot;http://qcscimdb.benq.corp.com:81&quot;,\n  protocol: &quot;http:&quot;,\n  username: &quot;&quot;,\n  password: &quot;&quot;,\n  host: &quot;qcscimdb.benq.corp.com:81&quot;,\n  hostname: &quot;qcscimdb.benq.corp.com&quot;,\n  port: &quot;81&quot;,\n  pathname: &quot;/MAI1InspectionResolve/&quot;,\n  search: &quot;&quot;,\n  hash: &quot;#/home?user=Tlight&quot;,\n}\n\nconsole.log(url.format(config))\n</code></pre>\n<h3 id="util" tabindex="-1">util</h3>\n<pre><code class="language-ts">util.isDeepStrictEqual({ 1: 1 }, { 1: 2 })\nutil.promisify(delay2)\nutil.callbackify(delay)\n</code></pre>\n<h3 id="fs" tabindex="-1">fs</h3>\n<p>ファイル io にて, CPU はメモリのみを処理し、動作するにはファイルをメモリに読み込む必要がありますが、io 操作は CPU ,メモリよりもはるかに遅くなります。</p>\n<pre><code class="language-ts">Stats {\n  dev: 24198785,\n  mode: 33206,\n  nlink: 1,\n  uid: 0,\n  gid: 0,\n  rdev: 0,\n  blksize: 4096,\n  ino: 281474979039900,\n  size: 0,\n  blocks: 0,\n  atimeMs: 1718958726062.4705,\n  mtimeMs: 1718958640012.3835,\n  ctimeMs: 1718958640012.3835,\n  birthtimeMs: 1718957669240.9294,\n  //访问\n  atime: 2024-06-21T08:32:06.062Z,\n  //修改\n  mtime: 2024-06-21T08:30:40.012Z,\n  //访问状态修改\n  ctime: 2024-06-21T08:30:40.012Z,\n  birthtime: 2024-06-21T08:14:29.241Z\n}\n\n\nconst getAbsolutePath = (relativePath: string) =&gt; {\n  const res = path.resolve(__dirname, relativePath);\n  //   console.log(res, __dirname);\n\n  return res;\n};\nfs.readFile(getAbsolutePath(&quot;./fs.txt&quot;), (err, res) =&gt; {\n  //   console.log(res);\n\n  fs.writeFile(\n    getAbsolutePath(&quot;./fs.txt&quot;),\n    os.EOL + &quot;abc&quot;,\n    {\n      flag: &quot;a&quot;, //追加内容\n    },\n    () =&gt; {}\n  );\n  fs.writeFile(\n    getAbsolutePath(&quot;./fs2.txt&quot;),\n    Buffer.from(&quot;text from buffer&quot;),\n    () =&gt; {}\n  );\n  //    fs.promises.stat(getAbsolutePath(&quot;./fs2.txt&quot;));\n  fs.promises.stat(getAbsolutePath(&quot;./&quot;)).then((v) =&gt; {\n    console.log(v.isDirectory);\n  });\n  fs.promises.readdir(getAbsolutePath(&quot;./&quot;)).then((v) =&gt; {\n    console.log(v);\n  });\n\n  fs.promises\n    .access(getAbsolutePath(&quot;test&quot;), constants.F_OK)\n    .catch((v) =&gt; {\n      console.log(v);\n      return fs.promises.mkdir(getAbsolutePath(&quot;test&quot;));\n    })\n    .then((v) =&gt; {\n      fs.promises.readFile(getAbsolutePath(&quot;./fs.txt&quot;)).then((res) =&gt; {\n        fs.promises.writeFile(getAbsolutePath(&quot;test/test.txt&quot;), res);\n      });\n    });\n});\n</code></pre>\n<h3 id="stream" tabindex="-1">stream</h3>\n<p>先ほどの方法を使用すると、大量のメモリが消費されます。stream を推奨する。</p>\n<ol>\n<li>readable</li>\n<li>writable</li>\n<li>duplex\n解决背压：rs.pipe(ws)</li>\n</ol>\n<h3 id="net-net" tabindex="-1">net net</h3>\n<p>接続が確立された後、ソケットは duplex になります。</p>\n<p>TCP/IP プロトコルを使用した http リクエストの実現</p>\n<pre><code class="language-ts">import { parseHtml } from &quot;.&quot;\nimport net from &quot;net&quot;\n\nconst server = net.createServer()\nserver.listen(&quot;8585&quot;)\n\nserver.on(&quot;connection&quot;, (socket) =&gt; {\n  socket.on(&quot;data&quot;, (chunk) =&gt; {\n    console.log(parseHtml(chunk.toString(&quot;utf-8&quot;)))\n  })\n  const res = `\nHTTP/1.1 200 Ok\nContent-Type: image/jpeg\n\n\n `\n  socket.write(res.trimStart())\n  socket.end()\n  //   server.close()\n})\n</code></pre>\n<h3 id="events" tabindex="-1">events</h3>\n<p>自分も書いてみた</p>\n<pre><code class="language-ts">import events, { EventEmitter } from &quot;events&quot;\n\nconst em = new EventEmitter()\n\nem.on(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test1&quot;)\n})\n\nem.on(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test2&quot;)\n})\nem.once(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test3&quot;)\n})\nconsole.log(em.listeners(&quot;test&quot;))\n\nem.emit(&quot;test&quot;)\nconsole.log(em.listeners(&quot;test&quot;))\n</code></pre>\n<h2 id="%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B5%E3%82%A4%E3%82%AF%E3%83%AB" tabindex="-1">ライフサイクル</h2>\n<p>event loop ----timers timers 队列(要运算) 存放计时器回调 注：队列内容来着于计时器线程，需要计算;setTimeout 底层最小值为 1\n|\nnexttrick |\npromise |\n(每次循环先要 |\n清空的微队列; |\nnexttrick |\n优先级最高) pull 轮询队列 除了 timers，checks 。包括文件读取，用户请求;如果所有队列都空了,且有要等待的会卡在这;其他队列有东西了,就会从这里开始走一个新的循环\n|\n|\n|\n-----checks checks 队列 setImmediate 回调队列</p>\n<h2 id="node-orm" tabindex="-1">node ORM</h2>\n<p>object relation mapping</p>\n<h3 id="sequelize" tabindex="-1">Sequelize</h3>\n<p>自分でいくつかの一般的な方法を試し、記憶を促進するためのクラスを作成しました。</p>\n<pre><code class="language-ts">interface ISequelizeHelperInit {\n  user: string\n  password: string\n  database: string\n  host: string\n  dialect: Dialect\n}\nclass SequelizeHelper {\n  private _sequelize: Sequelize\n  private _connectedModels: Set&lt;typeof Model&gt; = new Set()\n  private constructor({ user, password, database, host, dialect }: ISequelizeHelperInit) {\n    this._sequelize = new Sequelize(database, user, password, {\n      host,\n      dialect,\n      logging: (err) =&gt; logHelper.sqlLogger.debug(err),\n    })\n  }\n  get instance() {\n    return this._sequelize\n  }\n  /**\n   * 默认alter: true,会改表\n   * @param association\n   * @param arg\n   * @returns\n   */\n  async initModels(\n    association?: (() =&gt; any) | null,\n    ...arg: Array&lt;{\n      model: ModelStatic&lt;Model&lt;any, any&gt;&gt;\n      attributes: ModelAttributes&lt;\n        Model,\n        // \'foreign keys\' are optional in Model.init as they are added by association declaration methods\n        Optional&lt;Attributes&lt;Model&gt;, BrandedKeysOf&lt;Attributes&lt;Model&gt;, symbol&gt;&gt;\n      &gt;\n      options: Partial&lt;InitOptions&lt;Model&lt;any, any&gt; | any&gt;&gt;\n    }&gt;\n  ) {\n    // return await Promise.all(\n\n    arg.map(async (m) =&gt; {\n      //@ts-ignore\n      m.model.init(m.attributes, {\n        sequelize: this._sequelize,\n        ...m.options,\n      })\n\n      //   return m.model.sync({\n      //     alter: true\n      //   })\n    })\n    association &amp;&amp; association()\n\n    // )\n    const res = await this._sequelize.sync({ alter: true }).catch(() =&gt; false)\n    // association()\n    if (!!res) {\n      arg.forEach((m) =&gt; {\n        this._connectedModels.add(m.model)\n      })\n    }\n    return !!res\n  }\n  async testConnection() {\n    try {\n      await this._sequelize.authenticate()\n      return true\n    } catch (error) {\n      console.error(&quot;Unable to connect to the database:&quot;, error)\n      return false\n    }\n  }\n  bulkCreate&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, instances: Partial&lt;InstanceType&lt;T&gt;&gt;[]) {\n    console.log(instances)\n\n    //@ts-ignore\n    this.hasModel(model) &amp;&amp; model.bulkCreate(instances)\n  }\n  hasModel(v: typeof Model) {\n    if (!this._connectedModels.has(v)) {\n      console.error(&quot;please init first&quot;)\n      throw &quot;&quot;\n    }\n    return true\n  }\n\n  /**\n   *\n   * @param model\n   * @param instance\n   * @returns\n   * 只做记录Sequelize的数据库操作\n   * 不强制使用 Service层一个ts文件只操作一个类,不混杂\n   */\n  insert2Model&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, instance: Partial&lt;InstanceType&lt;T&gt;&gt;) {\n    //@ts-ignore\n    return this.hasModel(model) &amp;&amp; model.create(instance).then((res) =&gt; res.toJSON())\n  }\n  updateModel&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: { [key in keyof Attributes&lt;InstanceType&lt;T&gt;&gt;]?: Attributes&lt;InstanceType&lt;T&gt;&gt;[key] }, conditions: Partial&lt;InstanceType&lt;T&gt;&gt;) {\n    //@ts-ignore\n\n    return this.hasModel(model) &amp;&amp; model.update(modelInstance, { where: { ...conditions } })\n  }\n  deleteFromModel&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n      model.destroy({\n        where: {\n          ...modelInstance,\n        },\n      })\n    )\n  }\n\n  select&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model.findAll({\n        where: {\n          ...modelInstance,\n        },\n      })\n    )\n  }\n  selectSetWhere&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, func: () =&gt; WhereOptions&lt;InferAttributes&lt;InstanceType&lt;T&gt;&gt;&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model\n        .findAll({\n          where: func(),\n        })\n        .then((res) =&gt; res.map((m) =&gt; m.toJSON()))\n    )\n  }\n  selectPageData&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;, page = 1, limit = 10) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n      model\n        .findAndCountAll({\n          where: {\n            ...modelInstance,\n          },\n          offset: (page - 1) * +limit,\n          limit: +limit,\n        })\n        .then(({ rows, count }) =&gt; {\n          return {\n            count,\n            rows: rows.map((m) =&gt; m.toJSON()),\n          }\n        })\n    )\n  }\n  selectAssolationData&lt;T extends typeof Model&lt;any, any&gt;&gt;(\n    model: T,\n    {\n      func = function () {\n        return {}\n      },\n      includes = null,\n    }: {\n      func: () =&gt; WhereOptions&lt;InferAttributes&lt;InstanceType&lt;T&gt;&gt;&gt;\n      includes: Model&lt;any, any&gt;[]\n    }\n  ) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model\n        .findAll({\n          where: func(),\n          ...(includes\n            ? {\n                include: includes,\n              }\n            : {}),\n        })\n        .then((res) =&gt; res.map((m) =&gt; m.toJSON()))\n    )\n  }\n\n  static _instance: SequelizeHelper\n  static getInstance(data: ISequelizeHelperInit): SequelizeHelper {\n    if (this._instance) {\n      return this._instance\n    }\n    this._instance = new SequelizeHelper(data)\n    return this.getInstance(data)\n  }\n}\n\n/**\n * 设置模型统一配置，在SequelizeHelper里面统一注册\n * @param param0\n * @returns\n */\nfunction setModel&lt;T extends Model, M extends InstanceType&lt;ModelStatic&lt;T&gt;&gt;&gt;({\n  model,\n  attributes,\n  options = {},\n}: {\n  model: ModelStatic&lt;T&gt;\n  attributes: ModelAttributes&lt;M, Optional&lt;Attributes&lt;M&gt;, BrandedKeysOf&lt;Attributes&lt;M&gt;, never&gt;&gt;&gt;\n  options?: Partial&lt;InitOptions&lt;T&gt;&gt;\n}) {\n  return {\n    model,\n    attributes,\n    options,\n  }\n}\n</code></pre>\n<p><strong>使用</strong>\n初期化</p>\n<pre><code class="language-ts">const sequelizeHelperInstance = SequelizeHelper.getInstance({\n  ...(require(&quot;./config.json&quot;) as Record&lt;&quot;user&quot; | &quot;password&quot;, string&gt;),\n  database: process.env.DB_NAME,\n  dialect: process.env.DB_Type,\n  host: process.env.DB_HOST,\n})\n\nsequelizeHelperInstance.testConnection().then(() =&gt; {\n  console.log(&quot;db connect success&quot;)\n})\n</code></pre>\n<p>モデルの定義</p>\n<pre><code class="language-ts">export class Blog extends Model&lt;InferAttributes&lt;Blog, { omit: &quot;id&quot; | &quot;blogType&quot; }&gt;, InferCreationAttributes&lt;Blog, { omit: &quot;id&quot; | &quot;blogType&quot; }&gt;&gt; implements IBlog {\n  declare id: string\n  declare title: string\n  declare description: string\n  declare toc: string\n  declare htmlContent: string\n  declare thumb: string\n  declare scanNumber: string\n  declare commentNumber: string\n  declare createDate: string\n  declare isValid: &quot;Y&quot; | &quot;N&quot;\n  declare blogType: string\n}\n\nexport const blogSetting = setModel({\n  model: Blog,\n  attributes: {\n    title: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    description: {\n      allowNull: true,\n      type: DataTypes.STRING,\n      defaultValue: 0,\n    },\n    toc: {\n      type: DataTypes.TEXT,\n      allowNull: false,\n    },\n    htmlContent: {\n      type: DataTypes.TEXT,\n      allowNull: false,\n    },\n    isValid: {\n      type: DataTypes.STRING(1),\n      allowNull: false,\n      defaultValue: &quot;Y&quot;,\n    },\n    thumb: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    scanNumber: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    commentNumber: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    createDate: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n  },\n  options: {\n    tableName: &quot;blog&quot;,\n  },\n})\n</code></pre>\n<p>一致化</p>\n<pre><code class="language-ts">sequelizeHelperInstance.initModels(association, AdminSetting, homeSetting, blogTypeSetting, blogSetting, messageSetting)\n</code></pre>\n<h4>MD5</h4>\n<p>暗号化のみ可能ですが、復号化はできません。暗号化結果は固定されており、パスワードの暗号化に使用されます。</p>\n<h2 id="logjs" tabindex="-1">logjs</h2>\n<pre><code class="language-ts">import log, { getLogger } from &quot;log4js&quot;\nlog.configure({\n  appenders: {\n    sql: {\n      type: &quot;dateFile&quot;,\n      filename: path.resolve(__dirname, &quot;../../../logs&quot;, &quot;sql&quot;, &quot;logs.log&quot;),\n      layout: {\n        type: &quot;pattern&quot;,\n        pattern: &quot;%c [%d{yyyy-MM-dd hh:mm:ss}] [%p] %m %n&quot;,\n      },\n      keepFileExt: true,\n    },\n    default: {\n      type: &quot;stdout&quot;,\n      //   filename: path.resolve(__dirname, &quot;logs&quot;, &quot;default&quot;, &quot;logs.log&quot;),\n      //   keepFileExt: true\n    },\n  },\n  categories: {\n    sql: {\n      appenders: [&quot;sql&quot;],\n      level: &quot;all&quot;,\n    },\n    default: {\n      appenders: [&quot;default&quot;],\n      level: &quot;all&quot;,\n    },\n  },\n})\n\nprocess.on(&quot;exit&quot;, () =&gt; {\n  log.shutdown()\n})\n\nexport default {\n  sqlLogger: getLogger(&quot;sql&quot;),\n  logger: getLogger(&quot;default&quot;),\n}\n</code></pre>\n<h2 id="express-(%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E7%9B%B4%E6%8E%A5%E5%87%A6%E7%90%86%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93)" tabindex="-1">Express (非同期エラーを直接処理できません)</h2>\n<p>http モジュールを直接使用することに問題はありません。URL パスを介してさまざまなメソッドを呼び出すには、多くの判断が必要です。データはストリーム メソッドを介して送信されるため、parseHtml を手動で受け入れる必要があります。</p>\n<h3 id="rest-style" tabindex="-1">rest style</h3>\n<pre><code class="language-ts">/api/user get 取得\n/api/ユーザー post 保存\n/api/user put 変更を加えます\n/api/user delete 削除\n</code></pre>\n<h3 id="route" tabindex="-1">Route</h3>\n<p>またモジュール化可能\n<strong>自分で書いてみたルーティング設定</strong></p>\n<pre><code class="language-ts">type Method = &quot;all&quot; | &quot;get&quot; | &quot;post&quot; | &quot;put&quot; | &quot;delete&quot; | &quot;patch&quot; | &quot;options&quot; | &quot;head&quot;\n\n/**\n * base route config\n */\ninterface IRouterItem {\n  method: Method\n  url: string\n  handler: (request: Request, response: Response) =&gt; Promise&lt;any&gt;\n  needAuth?: boolean\n  canCORS?: boolean\n}\n</code></pre>\n<p>Router 管理統一</p>\n<pre><code class="language-ts">export class RouterHelper {\n  /**\n   * all routes\n   */\n  private _routerCache: Record&lt;string, IRouterItem[]&gt; = {}\n  private constructor(private _app: Express) {}\n  registerRouter(baseUrl: string, router: Router, routerItems: IRouterItem[]) {\n    if (this._routerCache[baseUrl]) {\n      throw new Error(&quot;this baseUrl has been used&quot;)\n    }\n    this.addRouters(router, routerItems)\n    this._app.use(baseUrl, router)\n    this._routerCache[baseUrl] = routerItems\n  }\n  private addRouters(router: Router, routerItems: IRouterItem[]) {\n    routerItems.forEach((item) =&gt; {\n      router[item.method](item.url, response2Client(item.handler))\n    })\n  }\n  /**\n   *\n   * @param param0\n   * @returns\n   * get current route config\n   * 查询对应路由配置\n   */\n  getRouterItem&lt;T extends { baseUrl: string; url: string; method: Method }&gt;({ baseUrl, url, method }: T) {\n    // console.log(this._routerCache)\n\n    for (let baseurl in this._routerCache) {\n      for (let item of this._routerCache[baseurl]) {\n        if (method.toUpperCase() === item.method.toUpperCase() &amp;&amp; pathToRegexp(handlePathEnd(baseurl + item.url)).test((baseUrl + url).split(&quot;?&quot;)[0])) return item\n      }\n    }\n  }\n\n  private static _instance: RouterHelper\n  static Instance(app: Express): RouterHelper {\n    if (this._instance) {\n      return this._instance\n    } else {\n      this._instance = new RouterHelper(app)\n      return this.Instance(app)\n    }\n  }\n}\n\n/**\n * 处理路径类似 /login/ 与 /login 冲突问题\n * @param path\n * @returns\n */\nfunction handlePathEnd(path: string) {\n  if (path.slice(-1) === &quot;/&quot;) {\n    return handlePathEnd(path.slice(0, path.length - 1))\n  }\n  return path\n}\n/**\n * response method,it can response data that func return\n * 套了一层，配置路由时不用关心如何返回数据\n * @param func\n * @returns\n */\nconst response2Client = (func: IRouterItem[&quot;handler&quot;]): RequestHandler =&gt; {\n  return async function (request, response, next) {\n    try {\n      const res = await func(request, response)\n      // console.log(res, getResponseData(res), response.headersSent)\n      response.send(getResponseData(res))\n    } catch (err) {\n      //   console.log(err)\n      next(err)\n    }\n  }\n}\n</code></pre>\n<p>定義を容易にするために hook 作成しました。</p>\n<pre><code class="language-ts">export function useRoutes({ router = express.Router(), routerItems, baseUrl }: { router?: Router; routerItems: IRouterItem[]; baseUrl: string }) {\n  function registerRouter(RouterHelperInstance: RouterHelper) {\n    RouterHelperInstance.registerRouter(baseUrl, router, routerItems)\n  }\n\n  return {\n    registerRouter,\n  }\n}\n</code></pre>\n<p><strong>使用</strong></p>\n<pre><code class="language-ts">const { registerRouter } = useRoutes({\n  routerItems: [\n    {\n      method: &quot;get&quot;,\n      url: &quot;/&quot;,\n      async handler(request) {\n        return blogServiceInstance.getBlogsPagenation(request.query as any)\n      },\n      canCORS: true,\n      //   needAuth: true\n    },\n    //...\n  ],\n  baseUrl: &quot;/api/blog&quot;,\n})\n\nexport { registerRouter }\n</code></pre>\n<h3 id="middleware" tabindex="-1">middleWare</h3>\n<pre><code class="language-ts">app.get(\n  &quot;/abc/:id&quot;,\n  () =&gt; {\n    // middleWare1\n    next()\n  },\n  () =&gt; {\n    // middleWare2\n  }\n)\n</code></pre>\n<p>どの middleWare でも応答できますが、応答できるのは 1 回だけです\n後続の middleWare を実行したい場合は、手動で next を呼び出す必要があります。\n応答はありませんが、最後の middleWare が next を呼び出しましたと,404 になります。\nnext(new Error())/throw new error を呼び出すと、後続の例外処理 middleWare が検索されます。</p>\n<pre><code class="language-ts">//useの使用範囲が広く、一致しているbaseURlを取得できます。\napp.use(&quot;/abc&quot;, (err, req, res, next) =&gt; {\n  console.log(err)\n  if (err) {\n    res.send({\n      err: &quot;err&quot;,\n    })\n  }\n})\n</code></pre>\n<p>自分で書いた middleWare\nauthorization</p>\n<pre><code class="language-ts">export function authorizationMiddleWare(): RequestHandler {\n  return function (request, response, next) {\n    let { baseUrl, url, method } = request\n    //統一されたRouterからsearch\n    const routerItem = RouterHelperInstance?.getRouterItem({ baseUrl, url, method: method as any })\n    if (!routerItem) {\n      throw new NotFoundError(&quot;path not found:&quot; + baseUrl + url + &quot;,method&quot; + method)\n    } else {\n      if (routerItem.needAuth) {\n        const res = JWTHelperIns.validateJwtToken(request)\n        if (res &amp;&amp; res.loginId) {\n          request.user = res\n          next()\n        } else {\n          throw new ForbiddenError(&quot;authorization fail,please login again&quot;)\n        }\n      } else {\n        next()\n      }\n    }\n  }\n}\n</code></pre>\n<p>cors</p>\n<pre><code class="language-ts">export default function (): RequestHandler {\n  return function (request, response, next) {\n    //クロスドメイン\n    if (&quot;origin&quot; in request.headers) {\n      let { method, path, baseUrl } = request\n      if (method.toUpperCase() === &quot;OPTIONS&quot;) {\n        method = request.headers[&quot;access-control-request-method&quot;]\n      }\n      const currentRouter = RouterHelperInstance.getRouterItem({\n        baseUrl,\n        method: method as any,\n        url: path,\n      })\n\n      //クロスドメインを許可する\n      if (currentRouter?.canCORS &amp;&amp; whiteList.includes(request.headers.origin)) {\n        //1.簡単なリクエスト　 access-control-allow-origin許可\n        if (typeof request.headers.origin !== &quot;undefined&quot;) {\n          response.header(&quot;access-control-allow-origin&quot;, request.headers.origin)\n        }\n        //2. OPTIONS　リクエスト\n        if (request.method.toUpperCase() === &quot;OPTIONS&quot;) {\n          response.header(&quot;access-control-allow-headers&quot;, request.headers[&quot;access-control-request-headers&quot;])\n          response.header(&quot;access-control-allow-methods&quot;, request.headers[&quot;access-control-request-method&quot;])\n          //未来多少秒内不要发预检了\n          response.header(&quot;access-control-max-age&quot;, &quot;3600&quot;)\n        }\n        //3.credentialsリクエスト\n        response.header(&quot;access-control-allow-credentials&quot;, &quot;true&quot;)\n      }\n      //OPTIONS　リクエスト　return\n      if (request.method.toUpperCase() === &quot;OPTIONS&quot;) {\n        return response.status(200).end()\n      }\n    }\n    next()\n  }\n}\n</code></pre>\n<p>error</p>\n<pre><code class="language-ts">export function errorHandler(): ErrorRequestHandler {\n  return function (err, request, response, next) {\n    const { message, code } = getResponseErrorData(err)\n    response.status(code).send({ message, code })\n  }\n}\n\nenum EServiceErrorCode {\n  UploadError = &quot;413&quot;,\n  ForbiddenError = &quot;401&quot;,\n  ValidateError = &quot;406&quot;,\n  NotFoundError = &quot;406&quot;,\n  UnknownError = &quot;500&quot;,\n}\n\n/**\n * base class\n */\nabstract class SeviceError extends Error {\n  code: EServiceErrorCode\n  constructor(message: string, code: EServiceErrorCode) {\n    super(message)\n    this.code = code\n  }\n}\n\nclass UploadError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.UploadError)\n  }\n}\n\nclass ForbiddenError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.ForbiddenError)\n  }\n}\n\nclass ValidateError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.ValidateError)\n  }\n}\n\nclass NotFoundError extends SeviceError {\n  constructor(res = &quot;file/api not found&quot;) {\n    super(res, EServiceErrorCode.NotFoundError)\n  }\n}\n\nclass UnknownError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.UnknownError)\n  }\n}\n</code></pre>\n<h3 id="cookie%2Csession%2Cjwt" tabindex="-1">cookie,session,jwt</h3>\n<p>どうやってコントロールするのか、あるいは誰なのかをどうやって確認するのか、それは捏造された情報ではありません。 http はステートレスだからです。</p>\n<p>クライアントが存在します。<code>key=value;path=/;domain=?;expire=?;max-age=?secure;httponly</code></p>\n<p>ブラウザは Cookie ルールを自動的に保存します。</p>\n<ol>\n<li>有効期限が切れていない</li>\n<li>ドメイン (ベースドメイン) を比較し、ポートとは関係がありません。</li>\n<li>path を比較</li>\n<li>secure = true のみ https\n条件が満たされると、ブラウザはリクエスト ヘッダーに Cookie を自動的に追加します。</li>\n</ol>\n<p><strong>key,path,domain</strong> のみがすべて同じであり、これは同じ Cookie です。</p>\n<pre><code class="language-ts">interface Cookie{\n   [key: string]: sting\n\n   /**\n\t* デフォルトの現在のリクエストパスを設定しないでください\n    */\n   path?: string\n\n   domain?: string\n   /**\n\t* GMT时间，UTC时间\n\t* new Date().toGMTString()\n\t* \'Mon, 01 Jul 2024 10:43:49 GMT\'\n    */\n   expire?: string\n   /**\n\t* 何秒後に期限切れになるか\n    */\n   max-age?: string  //既没有max-age也没有expire的话，就是回话解说词\n\n   /**\n\t* 設定は https のみに使える\n    */\n   secure?:boolean\n\n   /**\n　　　*サーバー側のみ設定可能\n　　　*送信時のみ使用する設定の場合、jsは使用できません。\n　　　*jsを使用するとxxr（クロスサイトスクリプティング攻撃）が発生する可能性があります\n　　　* たとえば、iframe が Web サイトに埋め込まれている場合、その js はソース Web サイトの Cookie にアクセスできます。\n    */\n   httponly\n}\n</code></pre>\n<h3 id="session" tabindex="-1">session</h3>\n<p>サーバー側にあります。sessionid はサーバーのリソースを占有し、Cookie を通じてクライアントに渡されます。セッション ID で確認します。</p>\n<h3 id="jwt" tabindex="-1">jwt</h3>\n<p>しかし、ブラウザがなければ、 cookie はまったく存在しません。JSON WEB TOKEN の誕生\njwt は response のどこいてもいい，cookie，headers，body</p>\n<p>ちなみに、<code>OAuth2</code> だったら、 そういう形</p>\n<pre><code class="language-ts">GET PATH HTTP/1.1\n...\nauthorization： bearer jwt\n...\n\n</code></pre>\n<pre><code class="language-ts">   interface JWT{\n\t   header: {\n\t\t  //    タイプ\n\t\t  typ:&quot;JWT&quot;,\n\t\t  //    signature署名アルゴリズム\n\t\t  alg: string|&quot;H256&quot;|...\n\t   }\n\t   //主体信息\n\t   payload: {\n          //    any\n\t   }\n\t   //改ざんされないことを保証\n\t   signature: string\n   }\n    instance:  base64(header).base64(payload).signature\n    // 服务器端判断\n\tH256(header,payload,secret) === signature\n</code></pre>\n<p>自分で書いた Helper</p>\n<pre><code class="language-ts">enum Oath2Token {\n  key = &quot;bearer&quot;,\n}\n\nclass JWTHelper {\n  /**\n   * add token to cookie and authorization\n   * @param res\n   * @param payload\n   * @param maxAge ms\n   */\n  publish(res: Response, payload = {}, maxAge = 3600 * 24 * 1000) {\n    const token = jwt.sign(payload, this._secret, {\n      expiresIn: maxAge,\n    })\n\n    res.header(&quot;authorization&quot;, token)\n    res.header(&quot;access-control-expose-headers&quot;, &quot;Authorization&quot;)\n  }\n  validateJwtToken(request: Request) {\n    let token: string = request.cookies ? request.cookies[this._cookieKey] : &quot;&quot;\n    if (!token) {\n      token = request.headers.authorization\n    } else {\n      //if token from cookie, add bearer\n      token = &quot;bearer &quot; + token\n    }\n\n    if (!token) {\n      throw new ForbiddenError(&quot;don\'t have token&quot;)\n    }\n    //oatu2 の bearer処理\n    const tokenArr = token.split(&quot; &quot;)\n    if (tokenArr.length === 2) {\n      if (tokenArr[0].toLowerCase() !== Oath2Token.key) {\n        throw new Error(&quot;token format error&quot;)\n      }\n      token = tokenArr[1]\n    }\n\n    try {\n      const res = jwt.verify(token, this._secret) as ILoginReturn\n      return res\n    } catch (e) {\n      throw e\n    }\n  }\n  constructor(private _secret: string, private _cookieKey: string) {}\n}\n\nconst defaultSetting = {\n  secret: Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-8),\n  cookieKey: &quot;token&quot;,\n}\n\nconst JWTHelperIns = new JWTHelper(defaultSetting.secret, defaultSetting.cookieKey)\n\nexport default JWTHelperIns\n</code></pre>\n<h3 id="cors" tabindex="-1">CORS</h3>\n<ol>\n<li>jsonp\nお勧めしない。 script タグは get リクエストのみを送信できます (リソース ファイルはドメインを越えて送信できます)。</li>\n</ol>\n<pre><code class="language-ts">//back end\nconst res = {}\nresponse.header(&quot;content-type&quot;, &quot;application/javascript&quot;)\nresponse.send(`callback${JSON.stringify(res)}`)\n\n//front end\nfunction jsonp(url) {\n  const el = document.createElement(&quot;script&quot;)\n  el.src = url\n  document.body.appendChild(el)\n  el.onload = () =&gt; {\n    el.remove()\n  }\n}\n\nfunction callback(data) {}\n</code></pre>\n<ol start="2">\n<li>\n<p>CORS cross origin resource sharing</p>\n<ol>\n<li>簡単なリクエスト\nmethod: get post head(ダウンロード)\nheader 追加情報はありません\ncontent-type : text/pain;multipart/form-data;application/x-www-form-urlencoded</li>\n</ol>\n<p>ブラウザは自動的 origin を追加します\nバックエンドでは Access-Control-Allow-Origin:<code>*/特定のドメイン名(お勧め)</code></p>\n<ol start="2">\n<li>\n<p>OPTIONS リクエスト\n簡単なリクエストじゃないと、 OPTIONS リクエストになります\nブラウザでは\nOPTIONS /path HTTP/1.1\nAccess-Control-Request-Method:GET\nAccess-Control-Request-Headers:a\nOrigin:xxxx</p>\n<p>バックエンドでは\nAccess-Control-Request-Method:GET\nAccess-Control-Request-Headers:a\naccess-control-max-age:?:&quot;3600&quot; //次の数秒間はいらない</p>\n</li>\n</ol>\n<p>３ 身分証明を持ってる(cookie とか)\n&quot;access-control-allow-credentials&quot;：&quot;true&quot;\n<strong>PS： <code>Access-Control-Allow-Origin:*</code> はダメ</strong></p>\n</li>\n</ol>\n<h2 id="%E3%83%90%E3%83%83%E3%82%AF%E3%82%A8%E3%83%B3%E3%83%89-%E4%B8%89%E5%B1%A4%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3" tabindex="-1">バックエンド 三層アーキテクチャ</h2>\n<h2 id="route-1" tabindex="-1">Route</h2>\n<pre><code class="language-tex"> 外部APIを提供する expressとか使う    以上があります\n</code></pre>\n<h2 id="service" tabindex="-1">Service</h2>\n<p>业务逻辑</p>\n<p>ここでは、単純に合法かどうかを判断するために私が書いたデコレータを使用します。</p>\n<pre><code class="language-ts">class AdminService {\n  /**\n   *\n   * @param param0\n   * @returns\n   */\n  @FuncIntercepter({}, { groups: [&quot;checkUserValid&quot;] })\n  async isUserValidate(@ParamType(AdminValidate) { loginId, loginPwd }: Partial&lt;IAdmin&gt;) {\n    loginPwd = md5(loginPwd)\n    const res = await AdminDaoInstance.queryUser({ loginId, loginPwd })\n    if (res &amp;&amp; res.dataValues) {\n      return { res: true, row: res.dataValues }\n    }\n    return { res: false }\n  }\n  /**\n   * set Authorization header\n   * @param response\n   * @param param1\n   */\n  @FuncIntercepter()\n  async setAuthorization(response: Express.Response, @ParamType(AdminValidate) { loginId, name, remember, role }: Partial&lt;ILoginData&gt;) {\n    remember = remember ? +remember : 1\n    JWTHelperIns.publish(response as any, { loginId, name, role }, 60 * 60 * 24 * remember)\n  }\n  @FuncIntercepter()\n  async updateUserPwd&lt;T extends IUpdateUserPwd&gt;(@ParamType(AdminValidate) { loginId, loginPwd, oldPwd, name }: T) {\n    const { res, row } = await this.isUserValidate({ loginId, loginPwd: oldPwd })\n    if (res &amp;&amp; row) {\n      // console.log(row);\n      const { id } = row as IAdmin\n      return await AdminDaoInstance.updateUser(\n        {\n          loginPwd: md5(loginPwd),\n          name,\n        },\n        { id }\n      )\n    } else {\n      throw new ValidateError(&quot;old password error&quot;)\n    }\n  }\n}\n</code></pre>\n<h2 id="dao" tabindex="-1">DAO</h2>\n<p>通常は ORM を使用してデータベースと対話します。</p>\n<pre><code class="language-ts">class AdminDao {\n  async queryUser({ loginId, loginPwd }: Pick&lt;IAdmin, &quot;loginId&quot; | &quot;loginPwd&quot;&gt;) {\n    return await Admin.findOne({\n      where: {\n        loginId,\n        loginPwd,\n        isValid: &quot;Y&quot;,\n      },\n    })\n  }\n  async updateUser(newInfo: Partial&lt;IAdmin&gt;, where: Partial&lt;IAdmin&gt;) {\n    return await Admin.update(newInfo, {\n      where,\n    })\n  }\n}\n</code></pre>\n',
      category: { id: 63, name: "Node" },
    },
  },
  3: {
    code: 200,
    data: {
      id: 3,
      title: "JS補い",
      description: "高度な JS 学習。主に ES6 のギャップを確認して埋めることについてです。原理を理解することによってのみ、それらをより適切に適用できます。",
      scanNumber: "1",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "js",
          name: "js",
          tag: "h1",
          children: [
            { anchor: "%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF(construct)", name: "コンストラクタ(construct)", tag: "h2", children: [] },
            { anchor: "property-descriptor", name: "property descriptor", tag: "h2", children: [] },
            {
              anchor: "es6",
              name: "ES6",
              tag: "h2",
              children: [
                { anchor: "1.-symbol", name: "1. symbol", tag: "h3", children: [] },
                { anchor: "2.-iterator", name: "2. iterator", tag: "h3", children: [] },
                { anchor: "3.-generator", name: "3. generator", tag: "h3", children: [] },
                { anchor: "4.-reflect", name: "4. Reflect", tag: "h3", children: [] },
                { anchor: "5.-proxy", name: "5. proxy", tag: "h3", children: [] },
              ],
            },
          ],
        },
      ],
      htmlContent:
        '<h1 id="js" tabindex="-1">js</h1>\n<h2 id="%E3%82%B3%E3%83%B3%E3%82%B9%E3%83%88%E3%83%A9%E3%82%AF%E3%82%BF(construct)" tabindex="-1">コンストラクタ(construct)</h2>\n<ol>\n<li><strong>js 内のすべてのオブジェクトはコンストラクターを通じて生成されます</strong></li>\n</ol>\n<pre><code class="language-ts">      const obj = {1:1} =&gt; const o = new Object()  o[1] = 1\n      const arr = [1,2] =&gt; const arr2 = new Array(1,2)\n      const sum = (a,b)=&gt;a+b =&gt; const sum = new Function(\'a\',\'b\',\'return a+b\')\n</code></pre>\n<ol start="2">\n<li><strong>prototype 三角関係</strong></li>\n</ol>\n<p><code>new instance</code>たびに大量の重複コンテンツが生成され、大量のメモリを占有します。特に方法です。\n<code>function (object)</code> には<code>prototype(これも object)</code>というプロパティがあります。instance の<code>__proto__</code>がそれを指します。したがって、パブリックメンバーは <code>prototype</code> に配置されます</p>\n<ol start="3">\n<li>\n<p><code>this</code> <strong>呼び出す時に決まる</strong>\n特別のシーン：</p>\n<ol>\n<li><code>()=&gt;{}</code>\n<code>this</code>は定義の時に決定される</li>\n<li><code>手動で指定する</code></li>\n</ol>\n<pre><code class="language-ts">     function a(){\n       ...\n     }\n     a() &lt;=&gt; a.call()\n\n     a.call(this,...argment)\n     a.apply(this,...arg:[])\n\n</code></pre>\n</li>\n<li>\n<p><code>prototype chain</code> いわば<code>__proto__</code>にて</p>\n<ol>\n<li><code>instanceof</code>\n<strong><code>__proto__</code>/constructor.prototype</strong> にあるか。シンプルに<code>is</code>として理解されます</li>\n<li><code>Object.getPrototypeOf(o)</code>\nprototype を取得する。 直接<code>__proto__</code>を使うのはよくない。</li>\n<li><code>const obj = Object.create(target)</code>\n<code>Object.getPrototypeOf(obj)===target</code></li>\n<li><code>Object.setPrototypeOf(a1,a2)</code>\nprototype の設置</li>\n<li>継承\nUser.call(this,name)\nObject.setPrototypeOf(VipUser.prototype,User.prototype)\n<strong>PS: 今は Reflect.setPrototypeOf，Reflect.getPrototypeOf もできます</strong></li>\n</ol>\n</li>\n</ol>\n<h2 id="property-descriptor" tabindex="-1"><code>property descriptor</code></h2>\n<pre><code class="language-ts">interface Descriptor {\n  value: 2\n  writable: true\n  enumerable: true //for in, Object.keys() in は__proto__も見る\n  configurable: true //property descriptor変更できるかどうか\n  get: () =&gt; {}\n  set: () =&gt; {}\n}\nObject.defineProperty(obj, &quot;key&quot;, {})\n</code></pre>\n<p><strong>注: get,set と value,writable 相互排他</strong>\n<strong>get,set のおかけで、操作性の向上</strong></p>\n<h2 id="es6" tabindex="-1">ES6</h2>\n<h3 id="1.-symbol" tabindex="-1">1. symbol</h3>\n<p>略する</p>\n<h3 id="2.-iterator" tabindex="-1">2. iterator</h3>\n<pre><code class="language-ts">function next() {\n  return { done: boolen, value: T }\n}\n</code></pre>\n<p><strong>iterator protocol</strong></p>\n<p>对象 具有知名符合属性<code>symbol.iterator</code>,并且该属性是一个迭代器创建函数，iterable\nオブジェクトには<code>symbol.iterator</code>というプロパティがあり、この value は<code>next</code>。</p>\n<h3 id="3.-generator" tabindex="-1">3. generator</h3>\n<p><strong>コンストラクター Generator によって作成されたオブジェクト。enerator は iterator <code>next 付き</code> と<code>iterable object</code> (<code>[symbol.iterator]プロパティがあり</code>) の両方です`</strong></p>\n<ol>\n<li>\n<p>generator は return でき</p>\n<pre><code class="language-ts">\tfunction *g(){\n\t\tyield 2\n\t\treturn 1\n\t}\n\tconst g = g()\n\tg.next() {done: false,value:2}\n\tg.next() {done: true, value:1}\n\tg.next() {done: true,value: undefined}\n</code></pre>\n</li>\n<li>\n<p>next()は param 持ってます</p>\n<pre><code class="language-ts">\tfunction *g(){\n\t\tlet i = yield 2\n\t\tyield i + 1\n\t}\n\tconst g = g()\n\tg.next() {done: false,value:2}\n\tg.next(10) {done: true, value:11}\n\tg.next() {done: true,value: undefined}\n</code></pre>\n<p><strong>初めて の next() の param は意味ない</strong></p>\n</li>\n<li>\n<p>generator nesting</p>\n<pre><code class="language-ts">function *g(){\n\tyield 2\n\treturn 1\n}\nfunction *g2(){\n\tyield *g()\n\tyield 3\n}\nconst g = g2()\ng.next() {done: false,value:2}\ng.next() {done: false, value:3}\ng.next() {done: true,value: undefined}\n</code></pre>\n</li>\n<li>\n<p>その他\n<strong>return</strong></p>\n<pre><code class="language-ts">function* g() {\n  yield 2\n  return 1\n}\nconst g = g()\ng.return(0)\n</code></pre>\n<p><strong>throw</strong></p>\n<pre><code class="language-ts">function* g() {\n  yield 2\n  return 1\n}\nconst g = g()\ng.throw(new Error())\n</code></pre>\n</li>\n</ol>\n<h3 id="4.-reflect" tabindex="-1">4. Reflect</h3>\n<p>基礎となる関数にアクセスするため API。 関数型プログラミング</p>\n<h3 id="5.-proxy" tabindex="-1">5. proxy</h3>\n<p>vue のトラック操作やトリガー操作など、通常は Reflect と一緒に、いくつかの基礎となる操作をインターセプトします。</p>\n<pre><code class="language-ts">const targetProxy = new Proxy(target, {\n  set() {\n    const type = target.hasOwnProperty(key) ? ETriggerType.set : ETriggerType.add\n\n    const oldValue = target[key]\n    // const oldLength = Array.isArray(target) ? target.length : null\n\n    const res = Reflect.set(target, key, newValue, receiver)\n\n    if (isChanged(oldValue, newValue)) {\n      //アップデートを配布する\n      trigger({\n        target,\n        type,\n        key: key as any,\n      })\n    }\n    return res\n  },\n  get() {\n    const res = Reflect.get(target, key, receiver)\n\n    //依存関係をインターセプトして収集する\n    track({\n      target,\n      key,\n      type: ETrackType.get,\n    })\n    if (res instanceof Object &amp;&amp; typeof res === &quot;object&quot;) {\n      return reactive(res)\n    }\n    return res\n  },\n})\n</code></pre>\n<p>詳細については、「Vue」を参照してください。</p>\n',
      category: { id: 64, name: "JavaScript" },
    },
  },
  4: {
    code: 200,
    data: {
      id: 4,
      title: "よく使われるCSS3のまとめ",
      description: "HTML5+CSS3 は開発エクスペリエンスを大幅に向上させました。js は非常に重要ですが、css も不可欠です。ccs3 で追加された新しいコンテンツを見てみましょう",
      scanNumber: "1",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88",
          name: "レイアウト",
          tag: "h1",
          children: [
            {
              anchor: "%E3%83%95%E3%83%AC%E3%83%83%E3%82%AF%E3%82%B9%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9",
              name: "フレックスボックス",
              tag: "h2",
              children: [
                {
                  anchor:
                    "%E3%83%95%E3%83%AC%E3%82%AD%E3%82%B7%E3%83%96%E3%83%AB%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%81%A8%E3%83%95%E3%83%AC%E3%82%AD%E3%82%B7%E3%83%96%E3%83%AB%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B",
                  name: "フレキシブルコンテナとフレキシブルプロジェクトを生成する",
                  tag: "h3",
                  children: [],
                },
                { anchor: "%E6%96%B9%E5%90%91%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B", name: "方向を変える", tag: "h3", children: [] },
                { anchor: "%E4%B8%BB%E8%BB%B8%E9%85%8D%E7%BD%AE", name: "主軸配置", tag: "h3", children: [] },
                { anchor: "%E5%81%B4%E8%BB%B8%E9%85%8D%E7%BD%AE", name: "側軸配置", tag: "h3", children: [] },
                {
                  anchor: "%E6%9F%94%E8%BB%9F%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0",
                  name: "柔軟なプロジェクトのスケーリング",
                  tag: "h3",
                  children: [],
                },
                { anchor: "%E3%82%B9%E3%83%94%E3%83%B3%E3%83%89%E3%83%AB%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%A9%E3%83%83%E3%83%97", name: "スピンドルラインラップ", tag: "h3", children: [] },
              ],
            },
            {
              anchor: "%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89",
              name: "グリッド",
              tag: "h2",
              children: [
                {
                  anchor: "%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B",
                  name: "グリッドレイアウトを生成する",
                  tag: "h3",
                  children: [],
                },
                { anchor: "%E8%A1%8C%E3%81%A8%E5%88%97%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B", name: "行と列を定義する", tag: "h3", children: [] },
                { anchor: "%E4%B8%A6%E3%81%B9%E6%9B%BF%E3%81%88%E6%96%B9%E5%90%91%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B", name: "並べ替え方向を変更する", tag: "h3", children: [] },
                { anchor: "%E3%82%BB%E3%83%AB%E9%96%93%E3%81%AE%E3%82%AE%E3%83%A3%E3%83%83%E3%83%97", name: "セル間のギャップ", tag: "h3", children: [] },
                { anchor: "%E3%82%BB%E3%83%AB%E5%86%85%E3%81%AE%E6%95%B4%E5%88%97", name: "セル内の整列", tag: "h3", children: [] },
                { anchor: "%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E9%A0%85%E7%9B%AE%E3%81%AE%E9%85%8D%E7%BD%AE", name: "グリッド項目の配置", tag: "h3", children: [] },
              ],
            },
          ],
        },
        {
          anchor: "%E3%83%93%E3%82%B8%E3%83%A7%E3%83%B3",
          name: "ビジョン",
          tag: "h1",
          children: [
            {
              anchor: "%E5%BD%B1",
              name: "影",
              tag: "h2",
              children: [
                { anchor: "%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6", name: "ボックスシャドウ", tag: "h3", children: [] },
                { anchor: "%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6", name: "テキストシャドウ", tag: "h3", children: [] },
              ],
            },
            { anchor: "%E8%A7%92%E3%81%8C%E4%B8%B8%E3%81%84", name: "角が丸い", tag: "h2", children: [] },
            { anchor: "%E8%83%8C%E6%99%AF%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3", name: "背景のグラデーション", tag: "h2", children: [] },
            {
              anchor: "%E5%A4%89%E6%8F%9B",
              name: "変換",
              tag: "h2",
              children: [
                { anchor: "translate", name: "translate", tag: "h3", children: [] },
                { anchor: "scale", name: "scale", tag: "h3", children: [] },
                { anchor: "rotate", name: "rotate", tag: "h3", children: [] },
                { anchor: "%E5%A4%89%E5%BD%A2%E5%8E%9F%E7%82%B9%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B", name: "変形原点を変更する", tag: "h3", children: [] },
                { anchor: "%E8%A4%87%E6%95%B0%E3%81%AE%E5%A4%89%E5%BD%A2%E3%81%AE%E9%87%8D%E3%81%AD%E5%90%88%E3%82%8F%E3%81%9B", name: "複数の変形の重ね合わせ", tag: "h3", children: [] },
              ],
            },
          ],
        },
        {
          anchor: "%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B8%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3",
          name: "トランジションとアニメーション",
          tag: "h1",
          children: [
            { anchor: "transition", name: "transition", tag: "h2", children: [] },
            { anchor: "%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3", name: "アニメーション", tag: "h2", children: [] },
          ],
        },
        {
          anchor: "%E3%81%9D%E3%81%AE%E4%BB%96",
          name: "その他",
          tag: "h1",
          children: [
            { anchor: "%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E8%A8%AD%E5%AE%9A", name: "ボックスのサイズ設定", tag: "h2", children: [] },
            { anchor: "%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3", name: "フォントアイコン", tag: "h2", children: [] },
            { anchor: "%E7%94%BB%E5%83%8F%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E3%81%AE%E9%81%A9%E5%BF%9C", name: "画像コンテンツの適応", tag: "h2", children: [] },
            { anchor: "%E3%83%93%E3%83%A5%E3%83%BC%E3%83%9D%E3%83%BC%E3%83%88%E5%8D%98%E4%BD%8D", name: "ビューポート単位", tag: "h2", children: [] },
            { anchor: "%E6%93%AC%E4%BC%BC%E8%A6%81%E7%B4%A0%E3%82%BB%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC", name: "擬似要素セレクター", tag: "h2", children: [] },
            { anchor: "%E3%82%B9%E3%83%A0%E3%83%BC%E3%82%BA%E3%81%AA%E3%82%B9%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%AB", name: "スムーズなスクロール", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88" tabindex="-1">レイアウト</h1>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511102802.png" alt="image-20210511102549096"></p>\n<p><strong>フローティング</strong>: テキストの折り返し効果を作成します</p>\n<p><strong>フレックスボックス</strong>: 単一行または単一列のレイアウト</p>\n<p><strong>グリッド</strong>: 複数行および複数列のレイアウト</p>\n<h2 id="%E3%83%95%E3%83%AC%E3%83%83%E3%82%AF%E3%82%B9%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9" tabindex="-1">フレックスボックス</h2>\n<blockquote>\n<p>詳細なドキュメントについては、<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">MDN</a> を参照してください。</p>\n<p>【フレキシブルボックスゲーム】(https://flexboxfroggy.com/)</p>\n</blockquote>\n<h3 id="%E3%83%95%E3%83%AC%E3%82%AD%E3%82%B7%E3%83%96%E3%83%AB%E3%82%B3%E3%83%B3%E3%83%86%E3%83%8A%E3%81%A8%E3%83%95%E3%83%AC%E3%82%AD%E3%82%B7%E3%83%96%E3%83%AB%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B" tabindex="-1">フレキシブルコンテナとフレキシブルプロジェクトを生成する</h3>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511112624.png" alt="image-20210511112624876"></p>\n<p><strong>デフォルトでは</strong> 弾性アイテムは主軸に沿って順番に配置され、交差軸は引き伸ばされます。</p>\n<h3 id="%E6%96%B9%E5%90%91%E3%82%92%E5%A4%89%E3%81%88%E3%82%8B" tabindex="-1">方向を変える</h3>\n<p>スピンドルの方向は<code>flex-direction</code>で変更できます。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511112510.png" alt="image-20210511112510632"></p>\n<h3 id="%E4%B8%BB%E8%BB%B8%E9%85%8D%E7%BD%AE" tabindex="-1">主軸配置</h3>\n<p><code>justify-content</code>属性を使用すると、主軸の配置に影響を与えることができます。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511113617.png" alt="image-20210511113617325"></p>\n<h3 id="%E5%81%B4%E8%BB%B8%E9%85%8D%E7%BD%AE" tabindex="-1">側軸配置</h3>\n<p><code>align-items</code>属性を通じて、交差軸の配置に影響を与えることができます。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511114016.png" alt="image-20210511114016304"></p>\n<h3 id="%E6%9F%94%E8%BB%9F%E3%81%AA%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0" tabindex="-1">柔軟なプロジェクトのスケーリング</h3>\n<p>いわゆる伸縮性とは、<strong>弾性容器</strong>に<strong>余分な空間</strong>がある場合に<strong>主軸方向</strong>に伸ばす必要があるかどうか、および<strong>弾性容器</strong>に<strong>余裕がある</strong>場合に<strong>圧縮する必要があるかどうかを指します</strong>.スペースが不足しています<strong>柔軟な項目</strong>の <code>flex</code> 属性を使用して、伸縮率と圧縮率を設定します: <code>flex: 伸縮率、圧縮率、初期サイズ</code></p>\n<p>ストレッチの例:</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511120916.png" alt="image-20210511120916571"></p>\n<p>圧縮の例:</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511121459.png" alt="image-20210511121459341"></p>\n<p>デフォルトでは、<code>flex: 0 1 auto</code>です。</p>\n<h3 id="%E3%82%B9%E3%83%94%E3%83%B3%E3%83%89%E3%83%AB%E3%83%A9%E3%82%A4%E3%83%B3%E3%83%A9%E3%83%83%E3%83%97" tabindex="-1">スピンドルラインラップ</h3>\n<p>デフォルトでは、スピンドルの残量が不足している場合、圧縮率に従って圧縮が行われますが、スピンドル行折り返しが設定されている場合は、圧縮は行われず、そのまま行折り返しで表示されます。</p>\n<p><code>flex-wrap:wrap</code> を <strong>flex コンテナ</strong>に設定して、主軸をラップします。</p>\n<img src="http://mdrs.yuanjin.tech/img/20210511123310.png" alt="image-20210511123310673" style="zoom:50%;" />\n<blockquote>\n<p>それにも関わらず、複数の行と列にはグリッド レイアウトが推奨されます。</p>\n</blockquote>\n<h2 id="%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89" tabindex="-1">グリッド</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout">MDN 詳細ドキュメント</a></p>\n<p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">Ruan Yifeng グリッド レイアウト チュートリアル</a></p>\n<p>【グリッドレイアウトゲーム】(https://cssgridgarden.com/)</p>\n</blockquote>\n<p><strong>グリッド レイアウトは、複数行および複数列のレイアウトの究極のソリューションです</strong></p>\n<h3 id="%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E3%83%AC%E3%82%A4%E3%82%A2%E3%82%A6%E3%83%88%E3%82%92%E7%94%9F%E6%88%90%E3%81%99%E3%82%8B" tabindex="-1">グリッドレイアウトを生成する</h3>\n<img src="http://mdrs.yuanjin.tech/img/20210511165317.png" alt="image-20210511165317363" style="zoom:50%;" />\n<p>コンテナがグリッド レイアウトを生成すると、そのすべての子要素は <strong>グリッド アイテム</strong>になります</p>\n<h3 id="%E8%A1%8C%E3%81%A8%E5%88%97%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%99%E3%82%8B" tabindex="-1">行と列を定義する</h3>\n<p><code>grid-template-rows</code>: 行を定義します</p>\n<p><code>grid-template-columns</code>: 列を定義します</p>\n<p><strong>それらの構文は同じです</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511172305.png" alt="image-20210511172305100"></p>\n<h3 id="%E4%B8%A6%E3%81%B9%E6%9B%BF%E3%81%88%E6%96%B9%E5%90%91%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B" tabindex="-1">並べ替え方向を変更する</h3>\n<p>属性 <code>grid-auto-flow:column</code> を使用して子要素を列に配置します</p>\n<img src="http://mdrs.yuanjin.tech/img/20210511173447.png" alt="image-20210511173447321" style="zoom:50%;" />\n<h3 id="%E3%82%BB%E3%83%AB%E9%96%93%E3%81%AE%E3%82%AE%E3%83%A3%E3%83%83%E3%83%97" tabindex="-1">セル間のギャップ</h3>\n<pre><code class="language-css">row-gap: 10px; /* 行のギャップは 10px です */\ncolumn-gap: 20px; /* 列のギャップは 20px です */\ngap: 10px 20px; /* 行のギャップは 10 ピクセル、列のギャップは 20 ピクセル */\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512132025.png" alt="image-20210512132025687"></p>\n<h3 id="%E3%82%BB%E3%83%AB%E5%86%85%E3%81%AE%E6%95%B4%E5%88%97" tabindex="-1">セル内の整列</h3>\n<p>デフォルトでは、グリッド項目はセル内で水平方向と垂直方向に伸びてセルを埋め尽くします。</p>\n<p>属性 <code>justify-items</code> を使用して <strong>水平</strong> 配置を設定できます。</p>\n<p>属性 <code>align-items</code> を使用して垂直方向の配置を設定できます。</p>\n<p>それらの可能な値は同じです。</p>\n<pre><code class="language-css">justify-items: start 左 | end 右 | center 中 | stretch ストレッチ;\nalign-items: start 上 | end 下 | center 中 | stretch ストレッチ;\n</code></pre>\n<img src="http://mdrs.yuanjin.tech/img/20210511174450.png" alt="image-20210511174450356" style="zoom:50%;" />\n<p>短縮属性<code>place-items: 垂直配置水平配置</code>を使用して、両方の値を同時に設定できます。</p>\n<pre><code class="language-css">place-items: start center; /* 垂直方向は上、水平方向は中央揃え */\n</code></pre>\n<h3 id="%E3%82%B0%E3%83%AA%E3%83%83%E3%83%89%E9%A0%85%E7%9B%AE%E3%81%AE%E9%85%8D%E7%BD%AE" tabindex="-1">グリッド項目の配置</h3>\n<p>デフォルトでは、グリッド項目は次々とセルに配置され、各グリッドが 1 つのセルを占有します。</p>\n<p>ただし、グリッド項目に<code>grid-area</code>属性を設定して、この動作を変更できます。</p>\n<p>使用方法:</p>\n<pre><code class="language-css">grid-area: 開始行番号/開始列番号/終了行番号/終了列番号;\n</code></pre>\n<img src="http://mdrs.yuanjin.tech/img/20210511180028.png" alt="image-20210511180027983" style="zoom:50%;" />\n<h1 id="%E3%83%93%E3%82%B8%E3%83%A7%E3%83%B3" tabindex="-1">ビジョン</h1>\n<blockquote>\n<p>いわゆるビジュアルスタイルとは、テキストの色、背景色、背景画像など、ボックスの位置やサイズに影響を与えないスタイルを指します。</p>\n</blockquote>\n<h2 id="%E5%BD%B1" tabindex="-1">影</h2>\n<h3 id="%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6" tabindex="-1">ボックスシャドウ</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>ボックス全体の影は<code>box-shadow</code>プロパティで設定できます。</p>\n<p>以下にいくつかの例を示します</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/box-shadow.html?v=2" style="height:900px;"></iframe>\n<h3 id="%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6" tabindex="-1">テキストシャドウ</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>テキストの影は<code>text-shadow</code>で設定できます。</p>\n<p>以下にいくつかの例を示します</p>\n<h3 id="%E3%83%86%E3%82%AD%E3%82%B9%E3%83%88%E3%82%B7%E3%83%A3%E3%83%89%E3%82%A6-1" tabindex="-1">テキストシャドウ</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>テキストの影は<code>text-shadow</code>で設定できます。</p>\n<p>以下にいくつかの例を示します</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/text-shadow.html?v=3" style="height:500px;"></iframe>\n<h2 id="%E8%A7%92%E3%81%8C%E4%B8%B8%E3%81%84" tabindex="-1">角が丸い</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><code>border-radius</code>を設定することで、ボックスの角の丸みを設定できます</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512131026.png" alt="image-20210512131026084"></p>\n<p><code>border-radius</code> はさまざまな柔軟な方法で使用でき、次のコードをページに貼り付けてテストできます。</p>\n<pre><code class="language-css">border-radius: 10px; /* 4つの角の丸みを半径10pxで同時に設定します */\nborder-radius: 50%; /* 4 つのコーナー フィレットを同時に設定します。円の水平半径は幅の半分、垂直半径は高さの半分です */\nborder-radius: 10px 20px 30px 40px; /* 左上、右上、右下、左下の角の丸みをそれぞれ設定します */\n</code></pre>\n<h2 id="%E8%A7%92%E3%81%8C%E4%B8%B8%E3%81%84-1" tabindex="-1">角が丸い</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><code>border-radius</code>を設定することで、ボックスの角の丸みを設定できます</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512131026.png" alt="image-20210512131026084"></p>\n<p><code>border-radius</code> はさまざまな柔軟な方法で使用でき、次のコードをページに貼り付けてテストできます。</p>\n<pre><code class="language-css">border-radius: 10px; /* 4つの角の丸みを半径10pxで同時に設定します */\nborder-radius: 50%; /* 4 つのコーナー フィレットを同時に設定します。円の水平半径は幅の半分、垂直半径は高さの半分です */\nborder-radius: 10px 20px 30px 40px; /* 左上、右上、右下、左下の角の丸みをそれぞれ設定します */\n</code></pre>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/border-raduis.html?v=5" style="height:550px;">\n</iframe>\n<h2 id="%E8%83%8C%E6%99%AF%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3" tabindex="-1">背景のグラデーション</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><strong>背景画像</strong>を設定する場合、<code>url()</code> を使用して背景画像を読み込むことに加えて、<code>linear-gradient()</code> 関数を使用して背景のグラデーションを設定することもできます。</p>\n<p><code>linear-gradient()</code> はグラデーション画像を作成するために使用されます。構文は次のとおりです。</p>\n<pre><code class="language-css">/* グラデーションの背景を設定します。方向: 上から下、色: #e66465 から #9198e5 までのグラデーション */\nbackground: linear-gradient(to bottom, #e66465, #9198e5);\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512135028.png" alt="image-20210512135024676"></p>\n<h2 id="%E5%A4%89%E6%8F%9B" tabindex="-1">変換</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><code>transform</code>属性を使用すると、ボックスの形状を変更できます。</p>\n<p>このアトリビュートはさまざまな変形スキームをサポートしています。一般的なものは次のとおりです。</p>\n<ul>\n<li>translate 水平移動</li>\n<li>scale ズーム</li>\n<li>rotate 回転</li>\n</ul>\n<p><strong>どの変換であっても、視覚効果が変更されるだけであり、ボックスのレイアウトには影響しません</strong></p>\n<p><strong>変換ではブラウザのリフローや再レンダリングが発生しないため、非常に効率的です</strong></p>\n<h3 id="translate" tabindex="-1">translate</h3>\n<p><code>translate</code>を使用すると、相対位置決めと同様に、ボックスが元の位置からずれる可能性があります。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512140643.png" alt="image-20210512140622630"></p>\n<h3 id="scale" tabindex="-1">scale</h3>\n<p><code>translate</code> を使用して、元の寸法に基づいてボックスのスケールを作成します。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512141500.png" alt="image-20210512141500499"></p>\n<h3 id="rotate" tabindex="-1">rotate</h3>\n<p>元の画像に基づいて回転するには、<code>rotate</code>属性を使用します</p>\n<pre><code class="language-css">/* 元の画像を元に、時計回りに 45 度回転します */\ntransform: rotate(45deg);\n/* 元の画像を元に、時計回りに半回転します */\ntransform: rotate(0.5turn);\n</code></pre>\n<p>下のボタンをクリックして回転効果を試すことができます</p>\n<h2 id="%E8%83%8C%E6%99%AF%E3%81%AE%E3%82%B0%E3%83%A9%E3%83%87%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3-1" tabindex="-1">背景のグラデーション</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><strong>背景画像</strong>を設定する場合、<code>url()</code> を使用して背景画像を読み込むことに加えて、<code>linear-gradient()</code> 関数を使用して背景のグラデーションを設定することもできます。</p>\n<p><code>linear-gradient()</code> はグラデーション画像を作成するために使用されます。構文は次のとおりです。</p>\n<pre><code class="language-css">/* グラデーションの背景を設定します。方向: 上から下、色: #e66465 から #9198e5 までのグラデーション */\nbackground: linear-gradient(to bottom, #e66465, #9198e5);\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512135028.png" alt="image-20210512135024676"></p>\n<h2 id="%E5%A4%89%E6%8F%9B-1" tabindex="-1">変換</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><code>transform</code>属性を使用すると、ボックスの形状を変更できます。</p>\n<p>このアトリビュートはさまざまな変形スキームをサポートしています。一般的なものは次のとおりです。</p>\n<ul>\n<li>translate 水平移動</li>\n<li>scale ズーム</li>\n<li>rotate 回転</li>\n</ul>\n<p><strong>どの変換であっても、視覚効果が変更されるだけであり、ボックスのレイアウトには影響しません</strong></p>\n<p><strong>変換ではブラウザのリフローや再レンダリングが発生しないため、非常に効率的です</strong></p>\n<h3 id="translate-1" tabindex="-1">translate</h3>\n<p><code>translate</code>を使用すると、相対位置決めと同様に、ボックスが元の位置からずれる可能性があります。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512140643.png" alt="image-20210512140622630"></p>\n<h3 id="scale-1" tabindex="-1">scale</h3>\n<p><code>translate</code> を使用して、元の寸法に基づいてボックスのスケールを作成します。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512141500.png" alt="image-20210512141500499"></p>\n<h3 id="rotate-1" tabindex="-1">rotate</h3>\n<p>元の画像に基づいて回転するには、<code>rotate</code>属性を使用します</p>\n<pre><code class="language-css">/* 元の画像を元に、時計回りに 45 度回転します */\ntransform: rotate(45deg);\n/* 元の画像を元に、時計回りに半回転します */\ntransform: rotate(0.5turn);\n</code></pre>\n<p>下のボタンをクリックして回転効果を試すことができます</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/rotate.html" style="height:400px;">\n</iframe>\n<h3 id="%E5%A4%89%E5%BD%A2%E5%8E%9F%E7%82%B9%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B" tabindex="-1">変形原点を変更する</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>変形原点の位置は、特定の変形動作に影響します。</p>\n<p>デフォルトでは、変換の原点はボックスの中心にありますが、<code>transform-origin</code> で変更できます。</p>\n<pre><code class="language-css">transform-origin: center; /* 原点をボックスの中心に設定します */\ntransform-origin: left top; /* 原点をボックスの左上隅に設定します */\ntransform-origin: right bottom; /* 原点をボックスの右下隅に設定します */\ntransform-origin: 30px 60px; /* 原点をボックス座標 (30, 60) に設定します */\n</code></pre>\n<p>試してみてください。まず [原点を設定] ボタンをクリックして原点 (図の赤い点でマーク) を設定し、次に [変形] ボタンをクリックして変形します。</p>\n<h3 id="%E5%A4%89%E5%BD%A2%E5%8E%9F%E7%82%B9%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%99%E3%82%8B-1" tabindex="-1">変形原点を変更する</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>変形原点の位置は、特定の変形動作に影響します。</p>\n<p>デフォルトでは、変換の原点はボックスの中心にありますが、<code>transform-origin</code> で変更できます。</p>\n<pre><code class="language-css">transform-origin: center; /* 原点をボックスの中心に設定します */\ntransform-origin: left top; /* 原点をボックスの左上隅に設定します */\ntransform-origin: right bottom; /* 原点をボックスの右下隅に設定します */\ntransform-origin: 30px 60px; /* 原点をボックス座標 (30, 60) に設定します */\n</code></pre>\n<p>試してみてください。まず [原点を設定] ボタンをクリックして原点 (図の赤い点でマーク) を設定し、次に [変形] ボタンをクリックして変形します。</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/transform-origin.html?v2" style="height:600px;"></iframe>\n<h3 id="%E8%A4%87%E6%95%B0%E3%81%AE%E5%A4%89%E5%BD%A2%E3%81%AE%E9%87%8D%E3%81%AD%E5%90%88%E3%82%8F%E3%81%9B" tabindex="-1">複数の変形の重ね合わせ</h3>\n<p>複数のデフォメーション効果を一度に設定可能</p>\n<pre><code class="language-css">/* まず 45 度回転し、次に (100,100) を移動します */\ntransform: rotate(45deg) translate(100px, 100px);\n/* まず平行移動 (100, 100) し、次に 45 度回転します */\ntransform: translate(100px, 100px) rotate(45deg);\n</code></pre>\n<p>注: 回転すると座標系も回転するため、その後の変形効果に影響を与える可能性があります。</p>\n<p>次の例はこの点をよく示しています</p>\n<h3 id="%E8%A4%87%E6%95%B0%E3%81%AE%E5%A4%89%E5%BD%A2%E3%81%AE%E9%87%8D%E3%81%AD%E5%90%88%E3%82%8F%E3%81%9B-1" tabindex="-1">複数の変形の重ね合わせ</h3>\n<p>複数のデフォメーション効果を一度に設定可能</p>\n<pre><code class="language-css">/* まず 45 度回転し、次に (100,100) を移動します */\ntransform: rotate(45deg) translate(100px, 100px);\n/* まず平行移動 (100, 100) し、次に 45 度回転します */\ntransform: translate(100px, 100px) rotate(45deg);\n</code></pre>\n<p>注: 回転すると座標系も回転するため、その後の変形効果に影響を与える可能性があります。</p>\n<p>次の例はこの点をよく示しています</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/multi-transform.html" style="height:600px;"></iframe>\n<h1 id="%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B8%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3" tabindex="-1">トランジションとアニメーション</h1>\n<p>トランジションとアニメーションを使用して CSS プロパティの変更をよりスムーズに行う</p>\n<p><strong>トランジションとアニメーションは、すべての CSS プロパティに影響を与えることはできません</strong>、色、幅と高さ、フォント サイズなどの数値プロパティにのみ影響します。</p>\n<h2 id="transition" tabindex="-1">transition</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<pre><code class="language-css">transition: 遷移属性の持続時間 遷移関数の遷移遅延。;\n</code></pre>\n<ul>\n<li><strong>transition プロパティ</strong></li>\n</ul>\n<p>トランジションを適用する CSS プロパティ。たとえば、<code>transform</code>と入力すると、トランジションが <strong>transform</strong> 属性にのみ適用されることを意味します。</p>\n<p><code>all</code>を入力するか空白のままにすると、トランジションがすべての CSS 属性に適用されることを意味します。</p>\n<ul>\n<li><strong>間隔</strong></li>\n</ul>\n<p>CSS プロパティの変更の継続時間は単位である必要があります。たとえば、<code>3s</code>は 3 秒を意味し、<code>0.5s</code>または<code>500ms</code>は 500 ミリ秒を意味します。</p>\n<ul>\n<li><strong>遷移関数</strong></li>\n</ul>\n<p>これは本質的に CSS プロパティを変更するベジェ曲線関数であり、通常はプリセット値を直接使用します。</p>\n<p><code>ease-in-out</code>: スムーズな開始、スムーズな終了</p>\n<p><code>linear</code>: 線形変化</p>\n<p><code>ease-in</code>: スムーズなスタートのみ</p>\n<p><code>ease-out</code>: スムーズなエンディングのみ</p>\n<ul>\n<li><strong>移行遅延</strong></li>\n</ul>\n<p>記述ルールはデュレーションと同じで、トランジションエフェクトがトリガーされるまでの遅延時間を示します。これが入力されていない場合、遅延は発生しません。</p>\n<p><strong>JS では、要素の <code>transitionstart</code> および <code>transitionend</code> イベントをリッスンして、トランジションの開始時と終了時に別のことを行うことができます</strong></p>\n<h2 id="%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3" tabindex="-1">アニメーション</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><strong>アニメーションの本質は、事前定義された一連の CSS 変更ルールと、そのルールに名前を付けることです</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210513172902.png" alt="image-20210513172902413"></p>\n<p>その後、他の要素は次のようなルールを使用できます。</p>\n<pre><code class="language-css">animation: ルール名の長さ;\n</code></pre>\n<p>ルールを適用するときに詳細情報を指定することもできます</p>\n<pre><code class="language-css">animation: ルール名、継続時間、繰り返し回数、時間関数、アニメーションの方向、遅延時間;\n</code></pre>\n<p>いくつかの詳細:</p>\n<ul>\n<li>ルールを定義する場合、<code>0%</code>を<code>from</code>として記述できます</li>\n<li>ルールを定義する場合、<code>100%</code>を<code>to</code>と書くことができます。</li>\n<li>繰り返し回数が<code>無限</code>の場合、無限繰り返しを意味します</li>\n<li>アニメーションの方向が<code>交互</code>の場合、交互の逆方向を意味します。1 回目は順方向、2 回目は逆方向、3 回目は順方向、4 回目は逆方向、というようになります。</li>\n</ul>\n<p><strong>JS では、要素の <code>animationstart</code> および <code>animationnend</code> イベントをリッスンして、トランジションの開始時と終了時に別の処理を行うことができます</strong></p>\n<h1 id="%E3%81%9D%E3%81%AE%E4%BB%96" tabindex="-1">その他</h1>\n<h2 id="%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E8%A8%AD%E5%AE%9A" tabindex="-1">ボックスのサイズ設定</h2>\n<p>百聞は一見に如かず</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514150015.png" alt="image-20210514150015660"></p>\n<p>サイズを制御するには<code>border-box</code>を使用する方がより直感的であるため、多くの Web サイトでは次のコードを追加します。</p>\n<pre><code class="language-css">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2 id="%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3" tabindex="-1">フォントアイコン</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN font-face ディレクティブ</a></p>\n</blockquote>\n<p>css3 には <code>font-face</code> ディレクティブが追加されており、Web フォントをロードできるようになります。</p>\n<p>最も一般的なアプリケーションはフォント アイコンです。</p>\n<p><strong>フォント アイコンは基本的にテキストです。つまり、色は <code>color</code> によって設定され、サイズは <code>font-size</code> によって設定されます</strong></p>\n<p>中国で最も一般的に使用されているフォント アイコン プラットフォームは [Alibaba Vector Icon Library] (https://www.iconfont.cn/) です。</p>\n<p>プラットフォームにログインすると、すべてのフォントアイコンを無料で使用できます</p>\n<h2 id="%E7%94%BB%E5%83%8F%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E3%81%AE%E9%81%A9%E5%BF%9C" tabindex="-1">画像コンテンツの適応</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>css3 属性 <code>object-fit</code> は、マルチメディア コンテンツと要素が適応する方法を制御できます。これは通常、<code>img</code> 要素または <code>video</code> 要素で使用されます。</p>\n<p>百聞は一見に如かず</p>\n<p>下の図のすべての <code>img</code> 要素は幅と高さが固定されており、img からはみ出した部分は実際には表示されません。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514134908.png" alt="image-20210514134908778"></p>\n<h2 id="%E3%83%93%E3%83%A5%E3%83%BC%E3%83%9D%E3%83%BC%E3%83%88%E5%8D%98%E4%BD%8D" tabindex="-1">ビューポート単位</h2>\n<p>css3 は、それぞれ<code>ビューポートの幅</code>と<code>ビューポートの高さ</code>を表す単位として<code>vw</code>と<code>vh</code>の使用をサポートしています。</p>\n<p>たとえば、<code>1vh</code>はビューポートの高さの<code>1%</code>を表し、<code>100vw</code>はビューポートの幅の<code>100%</code>を表します。</p>\n<h2 id="%E6%93%AC%E4%BC%BC%E8%A6%81%E7%B4%A0%E3%82%BB%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC" tabindex="-1">擬似要素セレクター</h2>\n<p><code>::before</code> および <code>::after</code> セレクターを使用すると、CSS を通じて 1 つの要素に対して 2 つの子要素を生成できます。</p>\n<img src="http://mdrs.yuanjin.tech/img/20210514140049.png" alt="image-20210514140049244" style="zoom:50%;" />\n<p>疑似要素を使用して、HTML 内で空の要素が多すぎることを避ける</p>\n<p><strong>疑似要素には <code>content</code> 属性が必要です。コンテンツが必要ない場合は、<code>content:\'\'</code> を設定します。</strong></p>\n<h2 id="%E3%82%B9%E3%83%A0%E3%83%BC%E3%82%BA%E3%81%AA%E3%82%B9%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%AB" tabindex="-1">スムーズなスクロール</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>スクロールをよりスムーズにするには <code>scroll-behavior:smooth</code> を使用します</p>\n<p>MDN 効果を参照</p>\n<h1 id="%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B8%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3-1" tabindex="-1">トランジションとアニメーション</h1>\n<p>トランジションとアニメーションを使用して CSS プロパティの変更をよりスムーズに行う</p>\n<p><strong>トランジションとアニメーションは、すべての CSS プロパティに影響を与えることはできません</strong>、色、幅と高さ、フォント サイズなどの数値プロパティにのみ影響します。</p>\n<h2 id="transition-1" tabindex="-1">transition</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<pre><code class="language-css">transition: 遷移属性の持続時間 遷移関数の遷移遅延。;\n</code></pre>\n<ul>\n<li><strong>transition プロパティ</strong></li>\n</ul>\n<p>トランジションを適用する CSS プロパティ。たとえば、<code>transform</code>と入力すると、トランジションが <strong>transform</strong> 属性にのみ適用されることを意味します。</p>\n<p><code>all</code>を入力するか空白のままにすると、トランジションがすべての CSS 属性に適用されることを意味します。</p>\n<ul>\n<li><strong>間隔</strong></li>\n</ul>\n<p>CSS プロパティの変更の継続時間は単位である必要があります。たとえば、<code>3s</code>は 3 秒を意味し、<code>0.5s</code>または<code>500ms</code>は 500 ミリ秒を意味します。</p>\n<ul>\n<li><strong>遷移関数</strong></li>\n</ul>\n<p>これは本質的に CSS プロパティを変更するベジェ曲線関数であり、通常はプリセット値を直接使用します。</p>\n<p><code>ease-in-out</code>: スムーズな開始、スムーズな終了</p>\n<p><code>linear</code>: 線形変化</p>\n<p><code>ease-in</code>: スムーズなスタートのみ</p>\n<p><code>ease-out</code>: スムーズなエンディングのみ</p>\n<ul>\n<li><strong>移行遅延</strong></li>\n</ul>\n<p>記述ルールはデュレーションと同じで、トランジションエフェクトがトリガーされるまでの遅延時間を示します。これが入力されていない場合、遅延は発生しません。</p>\n<p><strong>JS では、要素の <code>transitionstart</code> および <code>transitionend</code> イベントをリッスンして、トランジションの開始時と終了時に別のことを行うことができます</strong></p>\n<h2 id="%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3-1" tabindex="-1">アニメーション</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p><strong>アニメーションの本質は、事前定義された一連の CSS 変更ルールと、そのルールに名前を付けることです</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210513172902.png" alt="image-20210513172902413"></p>\n<p>その後、他の要素は次のようなルールを使用できます。</p>\n<pre><code class="language-css">animation: ルール名の長さ;\n</code></pre>\n<p>ルールを適用するときに詳細情報を指定することもできます</p>\n<pre><code class="language-css">animation: ルール名、継続時間、繰り返し回数、時間関数、アニメーションの方向、遅延時間;\n</code></pre>\n<p>いくつかの詳細:</p>\n<ul>\n<li>ルールを定義する場合、<code>0%</code>を<code>from</code>として記述できます</li>\n<li>ルールを定義する場合、<code>100%</code>を<code>to</code>と書くことができます。</li>\n<li>繰り返し回数が<code>無限</code>の場合、無限繰り返しを意味します</li>\n<li>アニメーションの方向が<code>交互</code>の場合、交互の逆方向を意味します。1 回目は順方向、2 回目は逆方向、3 回目は順方向、4 回目は逆方向、というようになります。</li>\n</ul>\n<p><strong>JS では、要素の <code>animationstart</code> および <code>animationnend</code> イベントをリッスンして、トランジションの開始時と終了時に別の処理を行うことができます</strong></p>\n<h1 id="%E3%81%9D%E3%81%AE%E4%BB%96-1" tabindex="-1">その他</h1>\n<h2 id="%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AE%E3%82%B5%E3%82%A4%E3%82%BA%E8%A8%AD%E5%AE%9A-1" tabindex="-1">ボックスのサイズ設定</h2>\n<p>百聞は一見に如かず</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514150015.png" alt="image-20210514150015660"></p>\n<p>サイズを制御するには<code>border-box</code>を使用する方がより直感的であるため、多くの Web サイトでは次のコードを追加します。</p>\n<pre><code class="language-css">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2 id="%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3-1" tabindex="-1">フォントアイコン</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN font-face ディレクティブ</a></p>\n</blockquote>\n<p>css3 には <code>font-face</code> ディレクティブが追加されており、Web フォントをロードできるようになります。</p>\n<p>最も一般的なアプリケーションはフォント アイコンです。</p>\n<p><strong>フォント アイコンは基本的にテキストです。つまり、色は <code>color</code> によって設定され、サイズは <code>font-size</code> によって設定されます</strong></p>\n<p>中国で最も一般的に使用されているフォント アイコン プラットフォームは [Alibaba Vector Icon Library] (https://www.iconfont.cn/) です。</p>\n<p>プラットフォームにログインすると、すべてのフォントアイコンを無料で使用できます</p>\n<h2 id="%E7%94%BB%E5%83%8F%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E3%81%AE%E9%81%A9%E5%BF%9C-1" tabindex="-1">画像コンテンツの適応</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>css3 属性 <code>object-fit</code> は、マルチメディア コンテンツと要素が適応する方法を制御できます。これは通常、<code>img</code> 要素または <code>video</code> 要素で使用されます。</p>\n<p>百聞は一見に如かず</p>\n<p>下の図のすべての <code>img</code> 要素は幅と高さが固定されており、img からはみ出した部分は実際には表示されません。</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514134908.png" alt="image-20210514134908778"></p>\n<h2 id="%E3%83%93%E3%83%A5%E3%83%BC%E3%83%9D%E3%83%BC%E3%83%88%E5%8D%98%E4%BD%8D-1" tabindex="-1">ビューポート単位</h2>\n<p>css3 は、それぞれ<code>ビューポートの幅</code>と<code>ビューポートの高さ</code>を表す単位として<code>vw</code>と<code>vh</code>の使用をサポートしています。</p>\n<p>たとえば、<code>1vh</code>はビューポートの高さの<code>1%</code>を表し、<code>100vw</code>はビューポートの幅の<code>100%</code>を表します。</p>\n<h2 id="%E6%93%AC%E4%BC%BC%E8%A6%81%E7%B4%A0%E3%82%BB%E3%83%AC%E3%82%AF%E3%82%BF%E3%83%BC-1" tabindex="-1">擬似要素セレクター</h2>\n<p><code>::before</code> および <code>::after</code> セレクターを使用すると、CSS を通じて 1 つの要素に対して 2 つの子要素を生成できます。</p>\n<img src="http://mdrs.yuanjin.tech/img/20210514140049.png" alt="image-20210514140049244" style="zoom:50%;" />\n<p>疑似要素を使用して、HTML 内で空の要素が多すぎることを避ける</p>\n<p><strong>疑似要素には <code>content</code> 属性が必要です。コンテンツが必要ない場合は、<code>content:\'\'</code> を設定します。</strong></p>\n<h2 id="%E3%82%B9%E3%83%A0%E3%83%BC%E3%82%BA%E3%81%AA%E3%82%B9%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%AB-1" tabindex="-1">スムーズなスクロール</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN 詳細ドキュメント</a></p>\n</blockquote>\n<p>スクロールをよりスムーズにするには <code>scroll-behavior:smooth</code> を使用します</p>\n<p>MDN 効果を参照</p>\n',
      category: { id: 65, name: "CSS" },
    },
  },
  5: {
    code: 200,
    data: {
      id: 5,
      title: "webpack原理",
      description: "クラシックなエンジニアリング パッケージング ツールの原理を理解する",
      scanNumber: "0",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "webpack",
          name: "webpack",
          tag: "h1",
          children: [
            { anchor: "%E3%81%AA%E3%81%9C%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E5%8C%96", name: "なぜエンジニア化", tag: "h2", children: [] },
            { anchor: "%E5%8E%9F%E7%90%86", name: "原理", tag: "h2", children: [] },
            {
              anchor: "%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E5%8E%9F%E7%90%86",
              name: "コンパイル原理",
              tag: "h2",
              children: [
                { anchor: "1.-%E5%88%9D%E6%9C%9F%E5%8C%96", name: "1. 初期化", tag: "h3", children: [] },
                { anchor: "2.-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB", name: "2. コンパイル", tag: "h3", children: [] },
                { anchor: "3.-emit", name: "3. emit", tag: "h3", children: [] },
              ],
            },
            { anchor: "loader", name: "loader", tag: "h2", children: [] },
            { anchor: "plugins", name: "plugins", tag: "h2", children: [] },
            { anchor: "webpack.config", name: "webpack.config", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="webpack" tabindex="-1">webpack</h1>\n<h2 id="%E3%81%AA%E3%81%9C%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E5%8C%96" tabindex="-1">なぜエンジニア化</h2>\n<p><strong>注: ノード環境はローカル ファイルを読み取るため、この問題は発生しません</strong>\n<code>devtime</code>:</p>\n<ol>\n<li>モジュールの粒度が細かい</li>\n<li>さまざまなモジュール標準 <strong>CommonJs、ESModule</strong> を直接実装する</li>\n<li>新しい構文 <strong>ESNext</strong> を使用する</li>\n</ol>\n<p><code>runtime</code>:</p>\n<ol>\n<li>ファイルが少ないほど良い: リクエストも少なくなる 2.小 ​​ さいサイズ: 圧縮</li>\n<li>乱雑であればあるほど良い: ロジックを改ざんしたくないし、コピーされたくない。</li>\n<li>高い執行効率</li>\n</ol>\n<h2 id="%E5%8E%9F%E7%90%86" tabindex="-1">原理</h2>\n<p>コンパイル結果</p>\n<pre><code class="language-ts">//関数環境を通じてグローバル変数を汚染しないようにする\n;(function (modules) {\n  const cachedModules = {}\n  //ノード環境と同様の require を定義し、js コードを実行して、エクスポートを返します。\n  function __webpack_require(path) {\n    if (cachedModules[path]) {\n      return cachedModules[path].exports\n    }\n    const module = (cachedModules[path] = {\n      id: path,\n      loaded: false,\n      exports: {},\n    })\n    const exports = module.exports\n    modules[path].call(exports, module, exports, __webpack_require)\n    module.loaded = true\n    return module.exports\n  }\n  __webpack_require.entry = &quot;&quot;\n  __webpack_require.cache = cachedModules\n  return __webpack_require((__webpack_require.entry = &quot;./src/index.js&quot;))\n})({\n  //ノード環境と同様の Commonjs インポート\n  // _temp(module,exports, require,__dirname,__filename)只能说除了__dirname,__filename,都一样\n  &quot;./src/a.js&quot;: function (module, exports, require) {\n    //  const a = 1\n    //  console.log(a);\n    //  module.exports = {\n    // \ta\n    //  }\n    //ただし、これを行うと、使用されるコンソール出力が現在の js になります。\n    //これは絶対によくないです。eval は新しい仮想環境を開くことと同じです。\n    eval(\n      `\n\t\t\tconst a = 1\n\t\t\tconsole.log(a);\n\t\t\tmodule.exports = {\n\t\t\t   a\n\t\t\t} \n\t\t\t` + &quot;//# sourceURL=webpack:///./src/a.js?&quot;\n    )\n  },\n  &quot;./src/b.js&quot;: function (module, exports, require) {\n    const b = 2\n    exports.b = 2\n  },\n  &quot;./src/index.js&quot;: function (module, exports, require) {\n    const a = require(&quot;./src/a.js&quot;)\n    const b = require(&quot;./src/b.js&quot;)\n    console.log(a)\n    console.log(b)\n  },\n})\n</code></pre>\n<h2 id="%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E5%8E%9F%E7%90%86" tabindex="-1">コンパイル原理</h2>\n<h3 id="1.-%E5%88%9D%E6%9C%9F%E5%8C%96" tabindex="-1">1. 初期化</h3>\n<p><strong>ビルド</strong></p>\n<p>CSS の<code>computed style</code>と同様に、cli パラメーター、webpack.config.js、およびデフォルト設定がマージされて、最終的な設定オブジェクトが生成されます。<code>yargs</code> ライブラリに依存する。</p>\n<h3 id="2.-%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB" tabindex="-1">2. コンパイル</h3>\n<ol>\n<li><code>chunk</code>を作る\n<strong>what’s chunk?</strong>\nentry に従って、すべての依存関係を見つけます。各 entry は chunk に対応します</li>\n</ol>\n<pre><code class="language-ts">interface chunk {\n  name: &quot;main&quot; //メインのentry\n  id: string //開発環境はnameであり、本番環境は数字になります。\n  hash: string //chunk assetsを生成するとき,すべてのファイルの内容に基づいてchunk hashが生成されます。\n}\n</code></pre>\n<ol start="2">\n<li>依存関係を構築</li>\n</ol>\n<pre><code class="language-ts">interface IChunkModules {\n  //通常、これはパスです。完全な相対パスを均一に変換します，./src/**/* ./node_modules/**/*\n  [moduleId: string]: string //转换后的代码\n}\nconst moduleCache: IChunkModules = {}\nfunction createDepencies(entryPath) {\n  //1. モジュールがロードされているかどうかを確認する\n  if (moduleCache[entryPath]) {\n    return\n  }\n  //2. 解析\n  // 1) コンテンツを読む\n  const content = fs.readFileSync(entryPath)\n  // 2) AST分析 これはツリー構造です\n  const astResult = AST(content)\n  // 3) ツリーをloop，すべての依存関係を取得する(require,import),完全な相対パスとして記録される\n  const dependencies: string[] = loopTree(astResult)\n  // 4) 依存関数を置き換える require=&gt;__webpack_require\n  // 5）置き換えたコードを保存します\n  moduleCache[entryPath] = content.replaceAll(&quot;require&quot;, &quot;__webpack_require&quot;) //肯定不能这样写吧\n  // 6) 再帰dependencies,深さ優先\n  dependencies.forEach((path) =&gt; createDepencies(path))\n}\n</code></pre>\n<ol start="3">\n<li><code>chunk assets</code>を作成\n<code>chunk</code>のモジュールに基づいてリソース リストを生成します。各項目は特定のファイルに対応します。<code>bundle</code>とも呼ばれます</li>\n</ol>\n<pre><code class="language-ts">{\n\t[ファイル名: string]:文件内容\n\t\'./dist/bundle.js\':(function (modules){})({\n\t   \'./src/a.js\':function (module,exports,require){\n\t\t\teval(`\n\t\t\tconst a = 1\n\t\t\tconsole.log(a);\n\t\t\tmodule.exports = {\n\t\t\t   a\n\t\t\t}\n\t\t\t`+&quot;//# sourceURL=webpack:///./src/a.js?&quot;);\n\t\t},\n})\n</code></pre>\n<ol start="4">\n<li>chunk assets マージ\nchunk assets をマージして,総 hash を生成する</li>\n</ol>\n<h3 id="3.-emit" tabindex="-1">3. emit</h3>\n<p>fs を通じて chunk assets を emit</p>\n<h2 id="loader" tabindex="-1">loader</h2>\n<p>本质: ファイル内容=&gt;js 内容</p>\n<p>config</p>\n<pre><code class="language-ts">  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/, //pathマッチ\n        use: [\n          {\n            loader: [&quot;ts-loader&quot;],\n            options: {\n\t\t\t\t//Param\n\t\t\t},\n          },\n        ],\n        exclude: /node_modules/,\n      },\n    ],\n  },\n</code></pre>\n<p><strong>注:loaders は後ろから呼び出す。 decorator と同じ</strong></p>\n<pre><code class="language-ts">{\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        use: [&quot;./src/loaders/testloader/loader&quot;, &quot;./src/loaders/testloader/loader2&quot;],\n      },\n      {\n        test: /test\\.js/,\n        use: [&quot;./src/loaders/testloader/loader3&quot;, &quot;./src/loaders/testloader/loader2&quot;],\n      },\n    ]\n  }\n}\n\n// 结果\n2\n3\n2\n1\n\n// 原理\n\nlet fscontent = xxx\nconst rules = []\n///\\.js/マッチ成功\nrules.push(...[&quot;./src/loaders/testloader/loader&quot;, &quot;./src/loaders/testloader/loader2&quot;])\n///test\\.js/ マッチ成功\nrules.push(...[&quot;./src/loaders/testloader/loader3&quot;, &quot;./src/loaders/testloader/loader2&quot;])\n\nfor (let i = rules.length - 1; i + 1; i--) {\n  const loader = require(rules[i])\n  //fs の読み取り内容をローダーに渡します\n  fscontent = loader(fscontent)\n}\nreturn fscontent\n</code></pre>\n<p>例 css loader</p>\n<pre><code class="language-ts">//entry.js\nrequire(&quot;./style/index.css&quot;)\n//require 自体は CSS を読み取れない必要があります\n//Webpack はファイルの内容を確実に読み取ることができます。抽象 AST 解析でエラーが発生します。\n//つまり、ローダー経由でのみ、ファイルの内容 =&gt; 解析できません (js 内容)\n\n// webpack.config.js\n//\n {\n        test: /\\.css/,\n        use: [&quot;./src/loaders/cssLoader&quot;],\n }\n\n //loader\n module.exports = function (sourceCode) {\n  const res = `\n    const style = document.createElement(&quot;style&quot;)\n    style.innerHTML = \\`${sourceCode}\\`\n    document.head.appendChild(style)\n    module.exports = \\`${sourceCode}\\`\n  `\n  //   console.log(res)\n  return res\n}\n</code></pre>\n<h2 id="plugins" tabindex="-1">plugins</h2>\n<p>loaders とは異なり、plugins は、Webpack コンパイル プロセスで hooks を処理するために使用されます。</p>\n<pre><code class="language-ts">import { Compilation, Compiler } from &quot;webpack&quot;\n\nclass Compiler {\n  //初期化フェーズで作成される\n  //コンパイルと出力操作は内部で作成された Compilation によって完了します\n  // 監視時に再コンパイルするとコンパイルが再作成されるだけです\n}\n//バンドルサイズをカウントするプラグイン\nclass MyPlugin {\n  //コンパイラを作成した後、apply が実行されます。\n  apply(compiler: Compiler) {\n    compiler.hooks.emit.tap(&quot;MyFilePlugin&quot;, (compilation) =&gt; {\n      const assets = Object.keys(compilation.assets)\n      const res = assets\n        .map((x) =&gt; {\n          const size = compilation.assets[x].size()\n\n          return `[${x}]:\n    \t  size:${size / 1000}kb\n    \t`\n        })\n        .join(&quot;\\n\\n&quot;)\n      compilation.assets[this.filmeName] = {\n        source() {\n          return res\n        },\n        size() {\n          return Buffer.from(res).byteLength\n        },\n      }\n    })\n  }\n}\n</code></pre>\n<h2 id="webpack.config" tabindex="-1">webpack.config</h2>\n<p>関数も使える</p>\n<pre><code class="language-ts">module.export = (env) =&gt; {\n  return {\n    entry: {\n      main: &quot;./src/index.js&quot;,\n    },\n  }\n}\n</code></pre>\n',
      category: { id: 67, name: "Webpack" },
    },
  },
  6: {
    code: 200,
    data: {
      id: 6,
      title: "node package manager",
      description: "一般的なパッケージマネージャーとその違い",
      scanNumber: "0",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "npm-node-package-manager",
          name: "npm node package manager",
          tag: "h1",
          children: [
            { anchor: "%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%AE%E8%A8%AD%E5%AE%9A", name: "ダウンロードソースの設定", tag: "h2", children: [] },
            { anchor: ".gitignore", name: ".gitignore", tag: "h2", children: [] },
            { anchor: "npm-install", name: "npm install", tag: "h2", children: [] },
            {
              anchor: "%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-npm-init",
              name: "配置文件 npm init",
              tag: "h2",
              children: [
                { anchor: "package.json", name: "package.json", tag: "h3", children: [] },
                { anchor: "package-lock.json", name: "package-lock.json", tag: "h3", children: [] },
              ],
            },
            { anchor: "%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC", name: "语义版本", tag: "h2", children: [] },
            { anchor: "script", name: "script", tag: "h2", children: [] },
            { anchor: "json-%E4%BD%BF%E7%94%A8", name: "json 使用", tag: "h2", children: [] },
            { anchor: "%E5%91%BD%E4%BB%A4", name: "命令", tag: "h2", children: [] },
            { anchor: "publish", name: "publish", tag: "h2", children: [] },
          ],
        },
        { anchor: "yarn", name: "yarn", tag: "h1", children: [{ anchor: "%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89", name: "コマンド", tag: "h2", children: [] }] },
        { anchor: "cnpm", name: "cnpm", tag: "h1", children: [] },
        { anchor: "nvm", name: "nvm", tag: "h1", children: [] },
        { anchor: "pnpm", name: "pnpm", tag: "h1", children: [{ anchor: "pnpm-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84", name: "pnpm 目录结构", tag: "h2", children: [] }] },
      ],
      htmlContent:
        '<h1 id="npm-node-package-manager" tabindex="-1">npm node package manager</h1>\n<h2 id="%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89%E3%82%BD%E3%83%BC%E3%82%B9%E3%81%AE%E8%A8%AD%E5%AE%9A" tabindex="-1">ダウンロードソースの設定</h2>\n<p>npm config set registry https://registry.npm.taobao.org\nnmp config get registry</p>\n<h2 id=".gitignore" tabindex="-1">.gitignore</h2>\n<p>node_modules\nソースコードは node_modules を無視する</p>\n<h2 id="npm-install" tabindex="-1">npm install</h2>\n<pre><code class="language-ts">//複数\nnpm install axios jquery\nnpm i axios jquery\n\n// 以前は、package.json に保存するには --save/-S を追加する必要がありましたが、現在はその必要がありません。\nnpm i prettier -D/--save-dev 安装到 dev 里面\nnpm i typescript --global/-g\n\n// 実稼働環境パッケージのみをインストールする\nnpm i --production\n\n// 一部のパッケージは cli を提供します\n// 現時点では、これらのコマンドは、node_module/.bin に存在し、npx (非グローバル インストール) を通じて実行されます。\n// usr/appdata/roaming/npm\nnpx\n\n</code></pre>\n<h2 id="%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-npm-init" tabindex="-1">配置文件 npm init</h2>\n<h3 id="package.json" tabindex="-1">package.json</h3>\n<p>ほとんどは名前を見ればわかると思いますので省略させていただきます。検索手順は次のとおりです</p>\n<pre><code class="language-tex">\nrequire(\'jquery\') =&gt;\n 1.ファイルとして探す。node_modules/jquery.js見つからない場合は2に回る\n 2.パッケージとして探す。 package.json が存在するかどうかを確認し、main が構成されている場合は、`node_modules/jquery/${main}.js`を探す。ないなら、 `node_modules/jquery/index.js`を探す。\n なかったら、3に回ります。\n 3.父のファイルに戻って繰り返します\n</code></pre>\n<h3 id="package-lock.json" tabindex="-1">package-lock.json</h3>\n<p>場合によっては、依存関係が複雑すぎて、異なるパッケージが同じパッケージの小さいバージョンに依存し、さまざまな競合が発生することがあります。\nlock は、このプロジェクトのすべての正確な依存関係を記録します。\nプロジェクトに package-lock.json が存在する場合は、package-lock.json の内容がインストールされます。存在しない場合は、package.json がインストールされます。</p>\n<h2 id="%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC" tabindex="-1">语义版本</h2>\n<p>パッケージに依存するパッケージを作成すると、他の人があなたのパッケージをインストールするときに、その人がインストールするパッケージがあなたのものと同じか最新のものになるようにしますか?</p>\n<pre><code class="language-tex">   &gt; 大于版本\n\t  &gt;=\n\t  &lt;\n\t  &lt;=\n\t  - 1.2.1-3.4.1 の间\n\t  x  1.1.x  　パッチのバージョンは自由\n\t  ~  ~1.1.6  パッチのバージョン&gt;=6\n\t  ^  ^4.4.0  メインバージョンは変更しない\n\t  *  lastest\n</code></pre>\n<h2 id="script" tabindex="-1">script</h2>\n<pre><code class="language-tex">     npxはスクリプト内で省略できます\n     start、test、stopはrun省略できます\n     npm start デフォルトのエントリserve.js\n\n\n     ## 環境変数\n     1. 永久設定 process.env.NODE_ENV (NODE_ENV 変数をシステム環境変数に追加します) お勧めしない\n     2. 临时设置 windows: set NODE_ENV=development\n                 mac: export NODE_ENV=development\n</code></pre>\n<pre><code class="language-json">    start: &quot;nodemon script/start.js&quot;\n</code></pre>\n<h2 id="json-%E4%BD%BF%E7%94%A8" tabindex="-1">json 使用</h2>\n<pre><code class="language-js">const json = require(&quot;./package.json&quot;)\n</code></pre>\n<h2 id="%E5%91%BD%E4%BB%A4" tabindex="-1">命令</h2>\n<ol>\n<li>\n<p>最新バージョンを正確にインストールする\nnpm i --save-exact/-E package &lt;=&gt; &quot;konva&quot;: &quot;9.3.6&quot;</p>\n</li>\n<li>\n<p>バージョンの指定\nnpm i lodash@2.1.1</p>\n</li>\n<li>\n<p>インストールパスを問い合わせる\nnpm root [-g]</p>\n</li>\n<li>\n<p>パッケージ情報を確認する（公式サイトを直接確認）\nnpm view vue\nview aliases:v info show</p>\n</li>\n<li>\n<p>インストールパッケージを表示する\nnpm list [-g] [--depth=\'依存の深さ\']\nlist aliases:ls la ll</p>\n</li>\n<li>\n<p>更新可能なパッケージを表示する\nnpm outdated</p>\n</li>\n<li>\n<p>更新\nnpm update [-g] [package]\nupdate aliases: up, upgrade</p>\n</li>\n<li>\n<p>アンインストール\nnpm uninstall [-g] package</p>\n</li>\n<li>\n<p>npm config ls [-l] [--json] 查看生效的配置</p>\n</li>\n<li>\n<p>npm config get/set/delete 配置 npm config get registry</p>\n</li>\n<li>\n<p>依存関係パッケージの脆弱性を表示する\nnpm audit</p>\n</li>\n<li>\n<p>このパッケージがインストールされた理由を確認する\nnpm explain vue</p>\n</li>\n</ol>\n<p>npm 更新 :\nnpm i npm -g\nnpm update -g npm</p>\n<h2 id="publish" tabindex="-1">publish</h2>\n<pre><code class="language-tex">npm公式サイトのアカウント登録\nnpm cli 登録\nnpm login/logout\nnpm whoami\n\npackjsonを埋める\n\nadd LICENSE http://choosealicense.online/appendix\nadd README.MD\nnpm publish\n</code></pre>\n<h1 id="yarn" tabindex="-1">yarn</h1>\n<p>当時の npm は非常にゴミで、シリアルダウンロード、非フラットな構造、煩雑な出力、そして npx がありませんでした...\nそこで、Facebook、Chrome、その他の大手企業は、npm の運用を最適化するために糸を作成しました。\n現在、npm と yarn には大きな違いはありません</p>\n<h2 id="%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89" tabindex="-1">コマンド</h2>\n<pre><code class="language-tex">yarn init --yes/-y\n\nyarn [global/-g] add package@ package [--dev/-D] [--exact/-E]\n\nすべてインストールする\nyarn install [--production/--prod]\n\n(start,stop,test)は run 省略できます\nyarn run script\nyarn run package 内蔵コマンド　(npxはこれを参考した)\n\n\nパッケージのコマンド フォルダーを表示する\nyarn [global/-g] bin\nyarn info package\nyarn [global/-g] list [--depth]\n\nyarn outdate\n\nyarn [global/-g] update\n\nyarn remove package\n\nyarn check 查看 package.json 与 yarn.lock 是否匹配\nyarn audit\nyarn why\n\n\n\nscaffold\nyarn create\n\n過去のやり方\n\n1.   yarn add create-react-app -g\n2.   create-react-app my-app\n\n今\nyarn create react-app my-app\n\n</code></pre>\n<h1 id="cnpm" tabindex="-1">cnpm</h1>\n<p>npm config set registry の出現によって、意味なくなった。</p>\n<h1 id="nvm" tabindex="-1">nvm</h1>\n<p>node バージョン管理ツール</p>\n<p>nvm install\nnvm use</p>\n<h1 id="pnpm" tabindex="-1">pnpm</h1>\n<p>単純な node_modules ディレクトリ\n間接的な依存関係の使用を避ける\nディスク使用量を削減する</p>\n<p>原理: 現在のディスク コピーのルート ディレクトリに直接ダウンロードします。各インストール中に存在する場合は、コピーの代わりにリンクが直接作成されます (ショートカットと同様)。これは、パッケージのコピーが存在することを意味します。ツリー構造に戻る</p>\n<pre><code>[拡張] ファイルの本質は外部ストレージへのポインタです\n削除されるのはポインタであるため、削除はサイズとは関係ありません。これがデータを復元できる理由でもあります。\n\nハード リンク: Unix オペレーティング システムでは、新しいポインタが現在の場所を指すことは参照と同等です。\nハードリンクが Windows でもサポートされるようになりました\nmklink /h リンク名ターゲット ファイル (フォルダーではなくファイルのみを指定できます)\n削除してもハードリンクには影響しません\nソフトリンク (シンボリックリンク): フォルダーまたはファイルを指します。\nmklin /d リンク名ターゲットファイル\nシンボリック リンクは常にリンクされたコンテンツに関連付けられます\n\nノード内: ノードはハードリンクかどうかを区別できません。\nソフトリンクは元の場所を見つけて実行します\n\n</code></pre>\n<h2 id="pnpm-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" tabindex="-1">pnpm 目录结构</h2>\n<pre><code class="language-tex">node_modules\n  .pnpm\n\t node_modules\n     registry\n\t\t  node_modules\n\n   librarys\n</code></pre>\n',
      category: { id: 74, name: "NPM" },
    },
  },
  1: {
    code: 200,
    data: {
      id: 1,
      title: "HTTP および HTTPS プロトコル",
      description: "HTTP および HTTPS プロトコルを理解し、ネットワーク リクエストの原則を学ぶ",
      scanNumber: "0",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "http",
          name: "http",
          tag: "h1",
          children: [
            { anchor: "c%2Fs-b%2Fs", name: "c/s b/s", tag: "h2", children: [] },
            { anchor: "url-uniform-resource-location", name: "url uniform resource location", tag: "h2", children: [] },
            {
              anchor: "http-protocol-tcp%2Fip-%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99",
              name: "http protocol TCP/IP に基づいています",
              tag: "h2",
              children: [
                { anchor: "request", name: "Request", tag: "h3", children: [] },
                { anchor: "response", name: "Response", tag: "h3", children: [] },
                { anchor: "ajax-webapi", name: "ajax webApi", tag: "h3", children: [] },
              ],
            },
            {
              anchor: "https-protocol-tcp%2Fip%E3%80%81ssl-%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99",
              name: "https protocol TCP/IP、SSL に基づいています",
              tag: "h2",
              children: [{ anchor: "%E6%9A%97%E5%8F%B7%E5%8C%96%E6%96%B9%E5%BC%8F", name: "暗号化方式", tag: "h3", children: [] }],
            },
          ],
        },
      ],
      htmlContent:
        '<h1 id="http" tabindex="-1">http</h1>\n<h2 id="c%2Fs-b%2Fs" tabindex="-1">c/s b/s</h2>\n<p><code>client(クライアント)</code> <code>browser(ブラウザ)</code> <code>browserサーバー</code>\nサーバーは特定のポートをリッスンするアプリケーションです\nクライアントは単なるアプリケーションです\nリクエストを発行するのはクライアントです\nサーバーは Response に応答します</p>\n<h2 id="url-uniform-resource-location" tabindex="-1">url <code>uniform resource location</code></h2>\n<p>構成</p>\n<p>http://www.baidu.com/s?wd=test#home\n<code>schema/protocol</code>:http\n<code>host</code>: www.baidu.com (または ip)\n<code>port</code>: 80\n<code>path</code>:/s\n<code>params</code>:?wd=test\n<code>hash</code>:#home</p>\n<h2 id="http-protocol-tcp%2Fip-%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99" tabindex="-1">http protocol <code>TCP/IP に基づいています</code></h2>\n<ol>\n<li>各リクエストとレスポンスは独立しています。。</li>\n<li>渡されるメッセージはすべて<code>string</code>で、形式は次のとおりです。</li>\n</ol>\n<h3 id="request" tabindex="-1">Request</h3>\n<pre><code class="language-ts">   request line   post  /api/user  HTTP/1.1\n   request header Content-Type: application/json\n                  User-Agent: Molila5.0 ………………\n\t\t\t\t  HOST:\n\t\t\t\t  origin:\n\t\t\t\t  Connection:\n\n   request Body   {\n\t                 id:xxxx\n                  }\n\n</code></pre>\n<p>従来のルール,<code>get</code>と<code>delete</code>は body 持ってません。params しかつかえません。\n<code>post</code>と <code>put</code>は body 持ってます。</p>\n<p><strong>Content-Type</strong></p>\n<ol>\n<li>\n<p>x-www-form-urlencoded</p>\n<pre><code class="language-ts">id = xxx\n</code></pre>\n</li>\n<li>\n<p>json</p>\n<pre><code class="language-ts">{\n  id: xxx\n}\n</code></pre>\n</li>\n<li>\n<p>form-data</p>\n</li>\n</ol>\n<p>​ ファイルアップロードにもちいてます。</p>\n<h3 id="response" tabindex="-1">Response</h3>\n<pre><code class="language-ts">   response line    HTTP/1.1 200 Ok\n   response header  Content-Type: text/html;charset=utf-8\n                    Server: BWS/1.1\n\n   response body    &lt;html&gt;&lt;/html&gt;\n\n</code></pre>\n<p><strong>応答コード</strong>\n<code>1**</code> message サーバーはリクエストを受信し、クライアントが送信を続ける必要があります。\n<code>2**</code> success\n<code>3**</code> redirect\n<code>4**</code> client error\n<code>5**</code> server error</p>\n<h3 id="ajax-webapi" tabindex="-1">ajax <code>webApi</code></h3>\n<pre><code class="language-ts">//ネイティブajax\nconst xhr = new XMLHttpRequest()\n\nxhr.onreadystatechange = function () {\n  switch (xhr.readyState) {\n    case 1:\n      console.log(&quot;open execute&quot;)\n      break\n    case 2:\n      console.log(&quot;send method execute&quot;)\n      break\n    case 3:\n      console.log(&quot;receiving response body&quot;)\n      break\n    case 4:\n      console.log(&quot;received all response&quot;)\n      const res = JSON.parse(xhr.responseText)\n      break\n  }\n}\n\nxhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/json&quot;)\nxhr.open(&quot;post&quot;, &quot;www.baidu.com&quot;)\nxhr.send(\n  JSON.stringify({\n    a: 1,\n  }) || null\n)\n</code></pre>\n<pre><code class="language-ts">// Fetch ES6で,Promiseでajaxを実現します\nfetch(&quot;www.baidu.com&quot;, {\n  method: &quot;post&quot;,\n  headers: {\n    &quot;Content-Type&quot;: &quot;application/json&quot;,\n  },\n  body: JSON.stringify({}),\n}).then((res) =&gt; res.json() /**応答本文の受信をします */)\n</code></pre>\n<h2 id="https-protocol-tcp%2Fip%E3%80%81ssl-%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99" tabindex="-1">https protocol <code>TCP/IP、SSL に基づいています</code></h2>\n<h3 id="%E6%9A%97%E5%8F%B7%E5%8C%96%E6%96%B9%E5%BC%8F" tabindex="-1">暗号化方式</h3>\n<ol>\n<li><code>対称暗号化</code>、暗号化と復号化に同じキーが使用されます。</li>\n<li><code>非対称暗号化</code>、キーのペアを生成します。公開キー暗号化は秘密キーでのみ復号化できます。</li>\n</ol>\n<p><strong>https 前の問題</strong></p>\n<pre><code class="language-ts">A ----公開キー----&gt; B\n&lt;---公開キー*key--\n-----key*(data)--&gt;\n// 第三者が他人の公開鍵を保存して自分の公開鍵を公開すると、その後の通信が改ざんされる可能性があります。\n</code></pre>\n<p><strong>今</strong>\n認証局(Certificate Authority)の秘密キーを使用して、Web サイトの公開キー、Web サイトの証明書の署名 (signature)、発行局、および Web サイトのドメイン名を暗号化して証明書(Digital Certificate)を生成します。</p>\n<p>公開キーは誰でも持つことができるため、内部の公開キーを誰でも見ることができますが。ブラウザはこの公開情報を使用して Web サイトの証明書の署名を計算できます。計算された署名がユーザーが指定した署名と一致しないことが判明したとばれます。</p>\n',
      category: { id: 73, name: "Network" },
    },
  },
} as unknown as Record<any, IResponse<IDetailArticle>>
export const blogDetail = {
  1: {
    code: 200,
    data: {
      id: 1,
      title: "HTTP与HTTPS协议",
      description: "了解HTTP与HTTPS协议,学习网络请求原理",
      scanNumber: "1",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "http",
          name: "http",
          tag: "h1",
          children: [
            { anchor: "c%2Fs-b%2Fs", name: "c/s b/s", tag: "h2", children: [] },
            { anchor: "url-uniform-resource-location", name: "url uniform resource location", tag: "h2", children: [] },
            {
              anchor: "http-protocol-%E5%BB%BA%E7%AB%8B%E5%9C%A8-tcp%2Fip-%E5%9F%BA%E7%A1%80%E4%B8%8A",
              name: "http protocol 建立在 TCP/IP 基础上",
              tag: "h2",
              children: [
                { anchor: "request", name: "Request", tag: "h3", children: [] },
                { anchor: "response", name: "Response", tag: "h3", children: [] },
              ],
            },
            { anchor: "ajax-webapi", name: "ajax webApi", tag: "h2", children: [] },
            {
              anchor: "https-protocol-%E5%BB%BA%E7%AB%8B%E5%9C%A8-tcp%2Fip-ssl(%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE)%E4%B9%8B%E4%B8%8A",
              name: "https protocol 建立在 TCP/IP SSL(加密协议)之上",
              tag: "h2",
              children: [{ anchor: "%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F", name: "加密方式", tag: "h3", children: [] }],
            },
          ],
        },
      ],
      htmlContent:
        '<h1 id="http" tabindex="-1">http</h1>\n<h2 id="c%2Fs-b%2Fs" tabindex="-1">c/s b/s</h2>\n<p><code>client</code> <code>browser</code> <code>server</code>\n服务器就是一个应用程序,监听某一个 port\n客户端也就一个应用程序\n发出 Request 的是客户端\n响应 Response 的是服务器</p>\n<h2 id="url-uniform-resource-location" tabindex="-1">url uniform resource location</h2>\n<p>http://www.baidu.com/s?wd=test#home\nschema/protocol http\nhost: www.baidu.com /ip\nport: 80\npath:/s\nparams:?wd=test\nhash:#home</p>\n<h2 id="http-protocol-%E5%BB%BA%E7%AB%8B%E5%9C%A8-tcp%2Fip-%E5%9F%BA%E7%A1%80%E4%B8%8A" tabindex="-1">http protocol 建立在 TCP/IP 基础上</h2>\n<ol>\n<li>每次请求-响应是独立的。断开式连接。</li>\n<li>传递消息都是 string, 格式为</li>\n</ol>\n<h3 id="request" tabindex="-1">Request</h3>\n<pre><code class="language-ts">   请求行          post  /api/user  HTTP/1.1\n   请求头 Header   Content-Type: application/json\n                  User-Agent: Molila5.0 ………………\n\t\t\t\t  HOST:\n\t\t\t\t  origin:\n\t\t\t\t  Connection:\n\n   请求体 Body    {\n\t                 id:xxxx\n                  }\n\n\n</code></pre>\n<p>约定俗成的</p>\n<p>get delete 没有 body,传参只能 params\npost put 有</p>\n<p><strong>Content-Type</strong></p>\n<ol>\n<li>\n<p>x-www-form-urlencoded</p>\n<pre><code class="language-ts">id = xxx\n</code></pre>\n</li>\n<li>\n<p>json</p>\n<pre><code class="language-ts">{\n  id: xxx\n}\n</code></pre>\n</li>\n<li>\n<p>form-data</p>\n</li>\n</ol>\n<p>​ 文件上传</p>\n<h3 id="response" tabindex="-1">Response</h3>\n<pre><code class="language-ts">   响应行  HTTP/1.1 200 Ok\n   响应头  Content-Type: text/html;charset=utf-8\n          Server: BWS/1.1\n\n   响应体  &lt;html&gt;&lt;/html&gt;\n\n</code></pre>\n<p>响应码\n1** 信息 服务器接到请求 需要客户端继续发送\n2** 成功\n3** 重定向\n4** 客户端错误\n5** 服务器错误</p>\n<h2 id="ajax-webapi" tabindex="-1">ajax webApi</h2>\n<pre><code class="language-ts">// //原生ajax\nconst xhr = new XMLHttpRequest()\n\nxhr.onreadystatechange = function () {\n  switch (xhr.readyState) {\n    case 1:\n      console.log(&quot;open 方法被调用&quot;)\n      break\n    case 2:\n      console.log(&quot;send method execute&quot;)\n      break\n    case 3:\n      console.log(&quot;receiving response body&quot;)\n      break\n    case 4:\n      console.log(&quot;received all response&quot;)\n      const res = JSON.parse(xhr.responseText)\n      break\n  }\n}\n\nxhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/json&quot;)\nxhr.open(&quot;post&quot;, &quot;www.baidu.com&quot;)\nxhr.send(\n  JSON.stringify({\n    a: 1,\n  }) || null\n)\n\n// Fetch 使用ES6 Promise方法实现ajax\nfetch(&quot;www.baidu.com&quot;, {\n  method: &quot;post&quot;,\n  headers: {\n    &quot;Content-Type&quot;: &quot;application/json&quot;,\n  },\n  body: JSON.stringify({}),\n}).then((res) =&gt; res.json() /**继续接收响应体 */)\n</code></pre>\n<h2 id="https-protocol-%E5%BB%BA%E7%AB%8B%E5%9C%A8-tcp%2Fip-ssl(%E5%8A%A0%E5%AF%86%E5%8D%8F%E8%AE%AE)%E4%B9%8B%E4%B8%8A" tabindex="-1">https protocol 建立在 TCP/IP SSL(加密协议)之上</h2>\n<h3 id="%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F" tabindex="-1">加密方式</h3>\n<ol>\n<li>对称加密 加密解密都有同一个 key</li>\n<li>非对称加密 生成一对密钥, 公钥加密只能用私钥解密</li>\n</ol>\n<p>现在的传输方式大概</p>\n<p>A ----公钥----&gt; B\n&lt;---公钥<em>key--\n-----key</em>(data)--&gt;\n但是第三方可以篡改，他保存别人的公钥，放送出自己的公钥，之后的通信就会被篡改</p>\n<p><strong>https 原理</strong>\n使用 Certificate Authority 的私钥 加密 网站的公钥，网站的证书签名(signature)，加上颁发机构，网站域名生成证书 Digital Certificate</p>\n<p>公钥谁都能有,所以里面的公钥谁都能看到，但是你想篡改，浏览器可以通过这些公开信息计算出网站的证书签名,如果发现计算出来的签名和你给的签名不一致，\n就是被发现</p>\n<pre><code>\t\t\t\t ---域名,网站公钥---&gt;CA ---&gt;域名,网站的公钥,CA公钥通过算法生成签名---&gt;生成DA\n\t\t\t\tA&lt;-------DA--------\n    B&lt;---DA(有A的公钥)-----\n    B-A的公钥*key--&gt;\n\t &lt;---key*data-&gt;\n</code></pre>\n<p>​</p>\n',
      category: { id: 73, name: "Network" },
    },
  },
  2: {
    code: 200,
    data: {
      id: 2,
      title: "NodeJs学习",
      description: "了解HTTP与HTTPS协议,学习网络请求原理",
      scanNumber: "24",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "node",
          name: "node",
          tag: "h1",
          children: [
            {
              anchor: "%E6%A6%82%E8%BF%B0",
              name: "概述",
              tag: "h2",
              children: [
                { anchor: "what's-node", name: "what's node", tag: "h3", children: [] },
                { anchor: "why-need-node", name: "why need node", tag: "h3", children: [] },
                { anchor: "%E7%89%B9%E7%82%B9", name: "特点", tag: "h3", children: [] },
              ],
            },
            { anchor: "global", name: "global", tag: "h2", children: [] },
            {
              anchor: "%E6%A8%A1%E5%9D%97%E5%8C%96-commonjs",
              name: "模块化 commonJs",
              tag: "h2",
              children: [
                { anchor: "%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE", name: "模块查找", tag: "h3", children: [] },
                { anchor: "module", name: "module", tag: "h3", children: [] },
                { anchor: "require", name: "require", tag: "h3", children: [] },
                { anchor: "require-%E7%BB%86%E8%8A%82", name: "require 细节", tag: "h3", children: [] },
                { anchor: "nodejs-%E4%B8%AD%E7%9A%84-es-%E6%A8%A1%E5%9D%97", name: "NodeJS 中的 ES 模块", tag: "h3", children: [] },
              ],
            },
            {
              anchor: "%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97",
              name: "内置模块",
              tag: "h2",
              children: [
                { anchor: "os", name: "os", tag: "h3", children: [] },
                { anchor: "path", name: "path", tag: "h3", children: [] },
                { anchor: "url", name: "url", tag: "h3", children: [] },
                { anchor: "util", name: "util", tag: "h3", children: [] },
                { anchor: "fs", name: "fs", tag: "h3", children: [] },
                { anchor: "stream", name: "stream", tag: "h3", children: [] },
                { anchor: "net-net", name: "net net", tag: "h3", children: [] },
                { anchor: "http", name: "http", tag: "h3", children: [] },
                { anchor: "https", name: "https", tag: "h3", children: [] },
                { anchor: "events", name: "events", tag: "h3", children: [] },
              ],
            },
            { anchor: "%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F", name: "生命周期", tag: "h2", children: [] },
            {
              anchor: "node-%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9C",
              name: "node 中数据库驱动操作",
              tag: "h2",
              children: [{ anchor: "sequelize", name: "Sequelize", tag: "h3", children: [] }],
            },
            { anchor: "logjs-%E8%AE%B0%E5%BD%95-log", name: "logjs 记录 log", tag: "h2", children: [] },
            {
              anchor: "express-%EF%BC%88%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E9%94%99%E8%AF%AF%EF%BC%89",
              name: "express （无法直接处理异步错误）",
              tag: "h2",
              children: [
                { anchor: "rest-%E9%A3%8E%E6%A0%BC", name: "rest 风格", tag: "h3", children: [] },
                { anchor: "route", name: "Route", tag: "h3", children: [] },
                { anchor: "%E4%B8%AD%E9%97%B4%E4%BB%B6(%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0)-middleware", name: "中间件(处理函数) middleWare", tag: "h3", children: [] },
              ],
            },
            {
              anchor: "cookie-session-jwt-%E5%8E%9F%E7%90%86",
              name: "cookie session jwt 原理",
              tag: "h2",
              children: [
                { anchor: "cookie", name: "cookie", tag: "h3", children: [] },
                { anchor: "session", name: "session", tag: "h3", children: [] },
                { anchor: "jwt", name: "jwt", tag: "h3", children: [] },
                {
                  anchor:
                    "%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-(cors)-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-%E5%8D%8F%E8%AE%AE%EF%BC%8C%E7%AB%AF%E5%8F%A3%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%90%8D",
                  name: "跨域问题 (CORS) 浏览器同源策略 协议，端口，主机名",
                  tag: "h3",
                  children: [],
                },
              ],
            },
            { anchor: "%E5%90%8E%E7%AB%AF%E5%B8%B8%E7%94%A8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84", name: "后端常用三层架构", tag: "h2", children: [] },
            { anchor: "%E8%B7%AF%E7%94%B1%E5%B1%82-route", name: "路由层 Route", tag: "h2", children: [] },
            { anchor: "%E6%9C%8D%E5%8A%A1%E5%B1%82-service", name: "服务层 Service", tag: "h2", children: [] },
            { anchor: "%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82-dao", name: "数据访问层 DAO", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="node" tabindex="-1">node</h1>\n<h2 id="%E6%A6%82%E8%BF%B0" tabindex="-1">概述</h2>\n<h3 id="what\'s-node" tabindex="-1">what\'s node</h3>\n<pre><code> js的运行环境\n 通常:浏览器端 =&gt;javascript\n      node  =&gt; nodeJs\n</code></pre>\n<h3 id="why-need-node" tabindex="-1">why need node</h3>\n<p>浏览器中仅提供了 js 解释器 + webapi(Dom Bom ajax)\n能力有限 文件读写限制\n跨域问题\nnode js + NodeApi 可以完全控制电脑(system)\n可以开发应用程序、服务器应用</p>\n<h3 id="%E7%89%B9%E7%82%B9" tabindex="-1">特点</h3>\n<pre><code>单线程  IO\n运算不如传统后端\n</code></pre>\n<h2 id="global" tabindex="-1">global</h2>\n<pre><code>```ts 实现与window一样\n   const global = {\n\t  setTimeout():Object{\n\n\t  },\n\t  setImmediate(){\n\n\t  },\n\t  setInterval(){\n\n\t  },\n\t  console,\n\n\t  process:{\n\t\t  //命令行目录\n\t\t   cwd(){},\n\t\t   //强制退出node进程\n\t\t   exit(){},\n\t\t   //命令行中参数\n\t\t   argv,\n\t\t   //操作系统\n\t\t   platform,\n\t\t   //杀进程\n\t\t   kill(pid){},\n\t\t   //环境变量\n\t\t   env\n\t  },\n\n\n\t  /**\n\t   * 现在计算机中的内存地址的最新单位byte, 1byte = 8bit(1bit就是一个二进)。4bit 可以表示2^4=16 0-15范围的数。也就是说,用一个16进制数就可以\n\t   * 表示一个字节byte。这个Buffer会用到16进制\n\t   */\n\t  Buffer,\n\n\n   }\n   global.global = global\n\n   //全局 但不在global里面\n   __dirname,\n   __filename,\n\n```\n</code></pre>\n<h2 id="%E6%A8%A1%E5%9D%97%E5%8C%96-commonjs" tabindex="-1">模块化 commonJs</h2>\n<h3 id="%E6%A8%A1%E5%9D%97%E6%9F%A5%E6%89%BE" tabindex="-1">模块查找</h3>\n<pre><code class="language-ts">\t   // 1.绝对路径\n\t   require(\'D:\\\\XXXX\')\n\t   //2. 相对路径\n\t\t//1)\n\t\trequire(\'./src\')\n\t\t//2)\n\t\trequire(\'axios\')\n\t    //  找到之后转换为绝对路径导入\n\n\t//    后缀名\n\t//   自动补全\n\tjs json node mjs\n\n\t// 文件名查找顺序\n\t//  1.当文件查出\n\t     require(\'./src\')\n\t\t src.js/json/node/mjs\n\t\t// 2.当包来找\n\t\t ./src/main/index.js\n\n</code></pre>\n<h3 id="module" tabindex="-1">module</h3>\n<pre><code class="language-js">\t{\n\t\t//绝对路径当id\n\t\tid: \'E:\\\\Tlight\\\\node\\\\dist\\\\module.js\',\n\t\tpath: \'E:\\\\Tlight\\\\node\\\\dist\',\n\t\texports: {},\n\t\tfilename: \'E:\\\\Tlight\\\\node\\\\dist\\\\module.js\',\n\t\tloaded: false,\n\t\tchildren: [],\n\t\tpaths: [    //这就是一层一层往上找包的原因\n\t\t\t\'E:\\\\Tlight\\\\node\\\\dist\\\\node_modules\',\n\t\t\t\'E:\\\\Tlight\\\\node\\\\node_modules\',\n\t\t\t\'E:\\\\Tlight\\\\node_modules\',\n\t\t\t\'E:\\\\node_modules\'\n\t\t]\n\t}\n</code></pre>\n<h3 id="require" tabindex="-1">require</h3>\n<pre><code class="language-js">{\n\t//返回绝对路径\n  resolve: [Function: resolve] { paths: [Function: paths] }, //静态方法\n  //入口模块\n  main: {\n    id: \'.\',\n    path: \'E:\\\\Tlight\\\\node\\\\dist\',\n    exports: {},\n    filename: \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\',\n    loaded: false,\n    children: [],\n    paths: [\n      \'E:\\\\Tlight\\\\node\\\\dist\\\\node_modules\',\n      \'E:\\\\Tlight\\\\node\\\\node_modules\',\n      \'E:\\\\Tlight\\\\node_modules\',\n      \'E:\\\\node_modules\'\n    ]\n  },\n  extensions: [Object: null prototype] { //自动解析的文件类型\n    \'.js\': [Function (anonymous)],\n    \'.json\': [Function (anonymous)],\n    \'.node\': [Function (anonymous)]\n  },\n  //缓存的模块对象\n  cache: [Object: null prototype] {\n    \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\': {\n      id: \'.\',\n      path: \'E:\\\\Tlight\\\\node\\\\dist\',\n      exports: {},\n      filename: \'E:\\\\Tlight\\\\node\\\\dist\\\\index.js\',\n      loaded: false,\n      children: [],\n      paths: [Array]\n    }\n  }\n}\n</code></pre>\n<h3 id="require-%E7%BB%86%E8%8A%82" tabindex="-1">require 细节</h3>\n<p>假如有一个模块</p>\n<pre><code class="language-js">console.log(__dirname, __filename)\nmodule.exports = {\n  a: 1,\n}\nexports.b = 2\nthis.c = 3\n</code></pre>\n<p>请问导出的是什么？</p>\n<p><strong>require 原理</strong></p>\n<pre><code class="language-js">   function require(modulePath){\n\t  //step1 转换为绝对路径\n\t  const absolutePath = xxx(modulePath)\n\t  //step2 判断是否已缓存\n\t  if(require.cache[absolutePath]){\n\t\t //有就直接返回缓存结果\n\t\t return require.cache[absolutePath].result\n\t  }\n\t  //step3 读取文件内容\n      const fileContent = xxx()\n\t  //step4 包裹到一个函数中\n\t  function _temp(module,exports, require,__dirname,__filename){\n\t\t...fileContent\n\t\t// console.log(__dirname, __filename);\n\t\t// module.exports = {\n\t\t// a: 1,\n\t\t// };\n\t\t// exports.b = 2;\n\t\t// this.c = 3;\n\t  }\n\n\t  //5.创建module对象\n\t  module.exports = {}\n\t  const exports = module.exports\n\n\t  _temp.call(module.exports,module,exports,require,module.path,module.filename)\n\n\t  require.cache[module.id] = module.exports\n      return module.exports\n   }\n\n</code></pre>\n<p>exports === this</p>\n<h3 id="nodejs-%E4%B8%AD%E7%9A%84-es-%E6%A8%A1%E5%9D%97" tabindex="-1">NodeJS 中的 ES 模块</h3>\n<p>可以用,但互操作有问题。现在是要么全是 es 模块，要么全是 commonJs 模块。\n当然可以使用 webpack 解决\n我现在的 ts 编译后的 Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });\n其实也可以\n将 es 模块的静态加载,转换为类似 require 的函数环境</p>\n<pre><code class="language-mjs">export const a = 1\nexport default 1\n</code></pre>\n<pre><code class="language-mjs">import * as obj from &quot;./es.mjs&quot;\nconsole.log(obj)\n</code></pre>\n<p>当父模块变成 js 时就有问题了 SyntaxError: Cannot use import statement outside a module</p>\n<h2 id="%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97" tabindex="-1">内置模块</h2>\n<blockquote>\n<p><a href="https://nodejs.org/docs/">官方文档</a></p>\n</blockquote>\n<h3 id="os" tabindex="-1">os</h3>\n<pre><code class="language-ts">//系统换行符\nconsole.log(os.EOL)\n//架构 x64\nconsole.log(os.arch())\n//cpus\nconsole.log(os.cpus())\n//空闲内存\nconsole.log(os.freemem())\n// 用户目录\nconsole.log(os.homedir())\n//主机名\nconsole.log(os.hostname())\n//临时目录\nconsole.log(os.tmpdir())\n</code></pre>\n<h3 id="path" tabindex="-1">path</h3>\n<p>filename d:\\xxx.txt 文件的绝对路径\nbasename xxx.txt</p>\n<pre><code class="language-ts">const basename = path.basename(&quot;xxx/xxxx/a.txt&quot;, &quot;html&quot;)\nconsole.log(basename)\nconst dir = path.dirname(&quot;xxx/xxxx/a.txt&quot;)\nconsole.log(dir)\n\nconst ext = path.extname(&quot;xxx/xxx/a.txt&quot;)\nconsole.log(ext)\n\nconst fullpath = path.join(&quot;d:/t&quot;, &quot;a&quot;, &quot;index&quot;, &quot;./test&quot;)\nconsole.log(fullpath)\n\n//分隔符\\\nconst separate = path.sep\nconsole.log(separate)\n\n//;\nconst d = path.delimiter\nconsole.log(process.env.PATH?.split(d))\n\nconst validpath = path.normalize(&quot;D:/a/b/index.ts&quot;)\nconsole.log(validpath)\n\nconst relativePath = path.relative(&quot;a/b/c&quot;, &quot;a/index&quot;)\nconsole.log(relativePath)\n\n//是相当于命令行\nconst absolutePath = path.resolve(&quot;./a.js&quot;)\nconst absolutePathBymodule = path.resolve(__dirname, &quot;./a.js&quot;)\nconsole.log(absolutePath, absolutePathBymodule, __dirname)\n</code></pre>\n<h3 id="url" tabindex="-1">url</h3>\n<pre><code class="language-ts">const u = new url.URL(&quot;http://qcscimdb.benq.corp.com:81/MAI1InspectionResolve/#/home?user=Tlight.HY.Xia&quot;)\nconsole.log(u, u.searchParams.has(&quot;user&quot;))\n\nfor (let key of u.searchParams) {\n  console.log(key)\n}\nconst config = {\n  href: &quot;http://qcscimdb.benq.corp.com:81/MAI1InspectionResolve&quot;,\n  origin: &quot;http://qcscimdb.benq.corp.com:81&quot;,\n  protocol: &quot;http:&quot;,\n  username: &quot;&quot;,\n  password: &quot;&quot;,\n  host: &quot;qcscimdb.benq.corp.com:81&quot;,\n  hostname: &quot;qcscimdb.benq.corp.com&quot;,\n  port: &quot;81&quot;,\n  pathname: &quot;/MAI1InspectionResolve/&quot;,\n  search: &quot;&quot;,\n  hash: &quot;#/home?user=Tlight&quot;,\n}\n\nconsole.log(url.format(config))\n</code></pre>\n<h3 id="util" tabindex="-1">util</h3>\n<pre><code class="language-ts">util.isDeepStrictEqual({ 1: 1 }, { 1: 2 })\nutil.promisify(delay2)\nutil.callbackify(delay)\n</code></pre>\n<h3 id="fs" tabindex="-1">fs</h3>\n<p>文件 io cpu 只跟内存打交道,把文件读入内存才能操作，但 io 的操作远远慢于 cpu 内存</p>\n<pre><code class="language-ts">Stats {\n  dev: 24198785,\n  mode: 33206,\n  nlink: 1,\n  uid: 0,\n  gid: 0,\n  rdev: 0,\n  blksize: 4096,\n  ino: 281474979039900,\n  size: 0,\n  blocks: 0,\n  atimeMs: 1718958726062.4705,\n  mtimeMs: 1718958640012.3835,\n  ctimeMs: 1718958640012.3835,\n  birthtimeMs: 1718957669240.9294,\n  //访问\n  atime: 2024-06-21T08:32:06.062Z,\n  //修改\n  mtime: 2024-06-21T08:30:40.012Z,\n  //访问状态修改\n  ctime: 2024-06-21T08:30:40.012Z,\n  birthtime: 2024-06-21T08:14:29.241Z\n}\n\n\nconst getAbsolutePath = (relativePath: string) =&gt; {\n  const res = path.resolve(__dirname, relativePath);\n  //   console.log(res, __dirname);\n\n  return res;\n};\nfs.readFile(getAbsolutePath(&quot;./fs.txt&quot;), (err, res) =&gt; {\n  //   console.log(res);\n\n  fs.writeFile(\n    getAbsolutePath(&quot;./fs.txt&quot;),\n    os.EOL + &quot;abc&quot;,\n    {\n      flag: &quot;a&quot;, //追加内容\n    },\n    () =&gt; {}\n  );\n  fs.writeFile(\n    getAbsolutePath(&quot;./fs2.txt&quot;),\n    Buffer.from(&quot;text from buffer&quot;),\n    () =&gt; {}\n  );\n  //    fs.promises.stat(getAbsolutePath(&quot;./fs2.txt&quot;));\n  fs.promises.stat(getAbsolutePath(&quot;./&quot;)).then((v) =&gt; {\n    console.log(v.isDirectory);\n  });\n  fs.promises.readdir(getAbsolutePath(&quot;./&quot;)).then((v) =&gt; {\n    console.log(v);\n  });\n\n  fs.promises\n    .access(getAbsolutePath(&quot;test&quot;), constants.F_OK)\n    .catch((v) =&gt; {\n      console.log(v);\n      return fs.promises.mkdir(getAbsolutePath(&quot;test&quot;));\n    })\n    .then((v) =&gt; {\n      fs.promises.readFile(getAbsolutePath(&quot;./fs.txt&quot;)).then((res) =&gt; {\n        fs.promises.writeFile(getAbsolutePath(&quot;test/test.txt&quot;), res);\n      });\n    });\n});\n</code></pre>\n<pre><code class="language-ts">\n</code></pre>\n<h3 id="stream" tabindex="-1">stream</h3>\n<p>使用刚才的方式，太吃内存了,使用流一点点执行 IO</p>\n<ol>\n<li>可读流 readable</li>\n<li>可写流 writable</li>\n<li>双工流 duplex\n解决背压： rs.pipe(ws) 原理看 source</li>\n</ol>\n<h3 id="net-net" tabindex="-1">net net</h3>\n<p>建立连接之后的 socket 就是一个双工流文件\n使用 TCP/IP 协议实现 http 请求</p>\n<pre><code class="language-ts">import { parseHtml } from &quot;.&quot;\nimport net from &quot;net&quot;\n\nconst server = net.createServer()\nserver.listen(&quot;8585&quot;)\n\nserver.on(&quot;connection&quot;, (socket) =&gt; {\n  socket.on(&quot;data&quot;, (chunk) =&gt; {\n    console.log(parseHtml(chunk.toString(&quot;utf-8&quot;)))\n  })\n  const res = `\nHTTP/1.1 200 Ok\nContent-Type: image/jpeg\n\n\n `\n  socket.write(res.trimStart())\n  socket.end()\n  //   server.close()\n})\n</code></pre>\n<h3 id="http" tabindex="-1">http</h3>\n<h3 id="https" tabindex="-1">https</h3>\n<h4>加密方式</h4>\n<ol>\n<li>对称加密 加密解密都有同一个 key</li>\n<li>非对称加密 生成一对密钥, 公钥加密只能用私钥解密</li>\n</ol>\n<p>现在的传输方式大概</p>\n<p>A ----公钥----&gt; B\n&lt;---公钥<em>key--\n-----key</em>(data)--&gt;\n但是第三方可以篡改，他保存别人的公钥，放送出自己的公钥，之后的通信就会被篡改</p>\n<p><strong>https 原理</strong>\n使用 Certificate Authority 的私钥 加密 网站的公钥，网站的证书签名(signature)，加上颁发机构，网站域名生成证书 Digital Certificate</p>\n<p>公钥谁都能有,所以里面的公钥谁都能看到，但是你想篡改，浏览器可以通过这些公开信息计算出网站的证书签名,如果发现计算出来的签名和你给的签名不一致，\n就是被发现</p>\n<pre><code>\t\t\t\t ---域名,网站公钥---&gt;CA ---&gt;域名,网站的公钥,CA公钥通过算法生成签名---&gt;生成DA\n\t\t\t\tA&lt;-------DA--------\n    B&lt;---DA-----\n    B-公钥*key--&gt;\n\t &lt;---key*data-&gt;\n</code></pre>\n<p><strong>操作和 http 模块一模一样,只是 createServer 的时候要给证书和私钥</strong></p>\n<h3 id="events" tabindex="-1">events</h3>\n<pre><code class="language-ts">import events, { EventEmitter } from &quot;events&quot;\n\nconst em = new EventEmitter()\n\nem.on(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test1&quot;)\n})\n\nem.on(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test2&quot;)\n})\nem.once(&quot;test&quot;, () =&gt; {\n  console.log(&quot;test3&quot;)\n})\nconsole.log(em.listeners(&quot;test&quot;))\n\nem.emit(&quot;test&quot;)\nconsole.log(em.listeners(&quot;test&quot;))\n</code></pre>\n<h2 id="%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" tabindex="-1">生命周期</h2>\n<p>event loop ----timers timers 队列(要运算) 存放计时器回调 注：队列内容来着于计时器线程，需要计算;setTimeout 底层最小值为 1\n|\nnexttrick |\npromise |\n(每次循环先要 |\n清空的微队列; |\nnexttrick |\n优先级最高) pull 轮询队列 除了 timers，checks 。包括文件读取，用户请求;如果所有队列都空了,且有要等待的会卡在这;其他队列有东西了,就会从这里开始走一个新的循环\n|\n|\n|\n-----checks checks 队列 setImmediate 回调队列</p>\n<h2 id="node-%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E6%93%8D%E4%BD%9C" tabindex="-1">node 中数据库驱动操作</h2>\n<p>orm object relation mapping</p>\n<h3 id="sequelize" tabindex="-1">Sequelize</h3>\n<p>自己尝试一些常用方法，方便记忆就写了一个类</p>\n<pre><code class="language-ts">interface ISequelizeHelperInit {\n  user: string\n  password: string\n  database: string\n  host: string\n  dialect: Dialect\n}\nclass SequelizeHelper {\n  private _sequelize: Sequelize\n  private _connectedModels: Set&lt;typeof Model&gt; = new Set()\n  private constructor({ user, password, database, host, dialect }: ISequelizeHelperInit) {\n    this._sequelize = new Sequelize(database, user, password, {\n      host,\n      dialect,\n      logging: (err) =&gt; logHelper.sqlLogger.debug(err),\n    })\n  }\n  get instance() {\n    return this._sequelize\n  }\n  /**\n   * 默认alter: true,会改表\n   * @param association\n   * @param arg\n   * @returns\n   */\n  async initModels(\n    association?: (() =&gt; any) | null,\n    ...arg: Array&lt;{\n      model: ModelStatic&lt;Model&lt;any, any&gt;&gt;\n      attributes: ModelAttributes&lt;\n        Model,\n        // \'foreign keys\' are optional in Model.init as they are added by association declaration methods\n        Optional&lt;Attributes&lt;Model&gt;, BrandedKeysOf&lt;Attributes&lt;Model&gt;, symbol&gt;&gt;\n      &gt;\n      options: Partial&lt;InitOptions&lt;Model&lt;any, any&gt; | any&gt;&gt;\n    }&gt;\n  ) {\n    // return await Promise.all(\n\n    arg.map(async (m) =&gt; {\n      //@ts-ignore\n      m.model.init(m.attributes, {\n        sequelize: this._sequelize,\n        ...m.options,\n      })\n\n      //   return m.model.sync({\n      //     alter: true\n      //   })\n    })\n    association &amp;&amp; association()\n\n    // )\n    const res = await this._sequelize.sync({ alter: true }).catch(() =&gt; false)\n    // association()\n    if (!!res) {\n      arg.forEach((m) =&gt; {\n        this._connectedModels.add(m.model)\n      })\n    }\n    return !!res\n  }\n  async testConnection() {\n    try {\n      await this._sequelize.authenticate()\n      return true\n    } catch (error) {\n      console.error(&quot;Unable to connect to the database:&quot;, error)\n      return false\n    }\n  }\n  bulkCreate&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, instances: Partial&lt;InstanceType&lt;T&gt;&gt;[]) {\n    console.log(instances)\n\n    //@ts-ignore\n    this.hasModel(model) &amp;&amp; model.bulkCreate(instances)\n  }\n  hasModel(v: typeof Model) {\n    if (!this._connectedModels.has(v)) {\n      console.error(&quot;please init first&quot;)\n      throw &quot;&quot;\n    }\n    return true\n  }\n\n  /**\n   *\n   * @param model\n   * @param instance\n   * @returns\n   * 只做记录Sequelize的数据库操作\n   * 不强制使用 Service层一个ts文件只操作一个类,不混杂\n   */\n  insert2Model&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, instance: Partial&lt;InstanceType&lt;T&gt;&gt;) {\n    //@ts-ignore\n    return this.hasModel(model) &amp;&amp; model.create(instance).then((res) =&gt; res.toJSON())\n  }\n  updateModel&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: { [key in keyof Attributes&lt;InstanceType&lt;T&gt;&gt;]?: Attributes&lt;InstanceType&lt;T&gt;&gt;[key] }, conditions: Partial&lt;InstanceType&lt;T&gt;&gt;) {\n    //@ts-ignore\n\n    return this.hasModel(model) &amp;&amp; model.update(modelInstance, { where: { ...conditions } })\n  }\n  deleteFromModel&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n      model.destroy({\n        where: {\n          ...modelInstance,\n        },\n      })\n    )\n  }\n\n  select&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model.findAll({\n        where: {\n          ...modelInstance,\n        },\n      })\n    )\n  }\n  selectSetWhere&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, func: () =&gt; WhereOptions&lt;InferAttributes&lt;InstanceType&lt;T&gt;&gt;&gt;) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model\n        .findAll({\n          where: func(),\n        })\n        .then((res) =&gt; res.map((m) =&gt; m.toJSON()))\n    )\n  }\n  selectPageData&lt;T extends typeof Model&lt;any, any&gt;&gt;(model: T, modelInstance: InstanceType&lt;T&gt;, page = 1, limit = 10) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n      model\n        .findAndCountAll({\n          where: {\n            ...modelInstance,\n          },\n          offset: (page - 1) * +limit,\n          limit: +limit,\n        })\n        .then(({ rows, count }) =&gt; {\n          return {\n            count,\n            rows: rows.map((m) =&gt; m.toJSON()),\n          }\n        })\n    )\n  }\n  selectAssolationData&lt;T extends typeof Model&lt;any, any&gt;&gt;(\n    model: T,\n    {\n      func = function () {\n        return {}\n      },\n      includes = null,\n    }: {\n      func: () =&gt; WhereOptions&lt;InferAttributes&lt;InstanceType&lt;T&gt;&gt;&gt;\n      includes: Model&lt;any, any&gt;[]\n    }\n  ) {\n    return (\n      this.hasModel(model) &amp;&amp;\n      //@ts-ignore\n\n      model\n        .findAll({\n          where: func(),\n          ...(includes\n            ? {\n                include: includes,\n              }\n            : {}),\n        })\n        .then((res) =&gt; res.map((m) =&gt; m.toJSON()))\n    )\n  }\n\n  static _instance: SequelizeHelper\n  static getInstance(data: ISequelizeHelperInit): SequelizeHelper {\n    if (this._instance) {\n      return this._instance\n    }\n    this._instance = new SequelizeHelper(data)\n    return this.getInstance(data)\n  }\n}\n\n/**\n * 设置模型统一配置，在SequelizeHelper里面统一注册\n * @param param0\n * @returns\n */\nfunction setModel&lt;T extends Model, M extends InstanceType&lt;ModelStatic&lt;T&gt;&gt;&gt;({\n  model,\n  attributes,\n  options = {},\n}: {\n  model: ModelStatic&lt;T&gt;\n  attributes: ModelAttributes&lt;M, Optional&lt;Attributes&lt;M&gt;, BrandedKeysOf&lt;Attributes&lt;M&gt;, never&gt;&gt;&gt;\n  options?: Partial&lt;InitOptions&lt;T&gt;&gt;\n}) {\n  return {\n    model,\n    attributes,\n    options,\n  }\n}\n</code></pre>\n<p><strong>使用</strong>\n初始化</p>\n<pre><code class="language-ts">const sequelizeHelperInstance = SequelizeHelper.getInstance({\n  ...(require(&quot;./config.json&quot;) as Record&lt;&quot;user&quot; | &quot;password&quot;, string&gt;),\n  database: process.env.DB_NAME,\n  dialect: process.env.DB_Type,\n  host: process.env.DB_HOST,\n})\n\nsequelizeHelperInstance.testConnection().then(() =&gt; {\n  console.log(&quot;db connect success&quot;)\n})\n</code></pre>\n<p>模型定义</p>\n<pre><code class="language-ts">export class Blog extends Model&lt;InferAttributes&lt;Blog, { omit: &quot;id&quot; | &quot;blogType&quot; }&gt;, InferCreationAttributes&lt;Blog, { omit: &quot;id&quot; | &quot;blogType&quot; }&gt;&gt; implements IBlog {\n  declare id: string\n  declare title: string\n  declare description: string\n  declare toc: string\n  declare htmlContent: string\n  declare thumb: string\n  declare scanNumber: string\n  declare commentNumber: string\n  declare createDate: string\n  declare isValid: &quot;Y&quot; | &quot;N&quot;\n  declare blogType: string\n}\n\nexport const blogSetting = setModel({\n  model: Blog,\n  attributes: {\n    title: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    description: {\n      allowNull: true,\n      type: DataTypes.STRING,\n      defaultValue: 0,\n    },\n    toc: {\n      type: DataTypes.TEXT,\n      allowNull: false,\n    },\n    htmlContent: {\n      type: DataTypes.TEXT,\n      allowNull: false,\n    },\n    isValid: {\n      type: DataTypes.STRING(1),\n      allowNull: false,\n      defaultValue: &quot;Y&quot;,\n    },\n    thumb: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    scanNumber: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    commentNumber: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n    createDate: {\n      type: DataTypes.STRING,\n      allowNull: false,\n    },\n  },\n  options: {\n    tableName: &quot;blog&quot;,\n  },\n})\n</code></pre>\n<p>同步模型</p>\n<pre><code class="language-ts">sequelizeHelperInstance.initModels(association, AdminSetting, homeSetting, blogTypeSetting, blogSetting, messageSetting)\n</code></pre>\n<h4>MD5 加密</h4>\n<p>只能加密不能解密 加密结果固定,用于加密密码</p>\n<h4>时间 北京时间与 utc 时间</h4>\n<p>使用时间戳统一(换算成 utc 时间)</p>\n<h2 id="logjs-%E8%AE%B0%E5%BD%95-log" tabindex="-1">logjs 记录 log</h2>\n<pre><code class="language-ts">import log, { getLogger } from &quot;log4js&quot;\nlog.configure({\n  appenders: {\n    sql: {\n      type: &quot;dateFile&quot;,\n      filename: path.resolve(__dirname, &quot;../../../logs&quot;, &quot;sql&quot;, &quot;logs.log&quot;),\n      layout: {\n        type: &quot;pattern&quot;,\n        pattern: &quot;%c [%d{yyyy-MM-dd hh:mm:ss}] [%p] %m %n&quot;,\n      },\n      keepFileExt: true,\n    },\n    default: {\n      type: &quot;stdout&quot;,\n      //   filename: path.resolve(__dirname, &quot;logs&quot;, &quot;default&quot;, &quot;logs.log&quot;),\n      //   keepFileExt: true\n    },\n  },\n  categories: {\n    sql: {\n      appenders: [&quot;sql&quot;],\n      level: &quot;all&quot;,\n    },\n    default: {\n      appenders: [&quot;default&quot;],\n      level: &quot;all&quot;,\n    },\n  },\n})\n\nprocess.on(&quot;exit&quot;, () =&gt; {\n  log.shutdown()\n})\n\nexport default {\n  sqlLogger: getLogger(&quot;sql&quot;),\n  logger: getLogger(&quot;default&quot;),\n}\n</code></pre>\n<h2 id="express-%EF%BC%88%E6%97%A0%E6%B3%95%E7%9B%B4%E6%8E%A5%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E9%94%99%E8%AF%AF%EF%BC%89" tabindex="-1">express （无法直接处理异步错误）</h2>\n<p>直接使用 http 模块肯定是没有问题，通过 url 路径调用不同的方法会有大量判断;传输的数据是通过 stream 的方法,需要你手动接受完 parseHtml</p>\n<h3 id="rest-%E9%A3%8E%E6%A0%BC" tabindex="-1">rest 风格</h3>\n<p>/api/user get 查询\n/api/user post 保存\n/api/user put 修改\n/api/user delete 删除</p>\n<p>又可以模块化了</p>\n<h3 id="route" tabindex="-1">Route</h3>\n<p><strong>自己尝试写的路由配置</strong></p>\n<pre><code class="language-ts">type Method = &quot;all&quot; | &quot;get&quot; | &quot;post&quot; | &quot;put&quot; | &quot;delete&quot; | &quot;patch&quot; | &quot;options&quot; | &quot;head&quot;\n\n/**\n * base route config\n */\ninterface IRouterItem {\n  method: Method\n  url: string\n  handler: (request: Request, response: Response) =&gt; Promise&lt;any&gt;\n  needAuth?: boolean\n  canCORS?: boolean\n}\n</code></pre>\n<p>统一管理路由</p>\n<pre><code class="language-ts">export class RouterHelper {\n  /**\n   * all routes\n   */\n  private _routerCache: Record&lt;string, IRouterItem[]&gt; = {}\n  private constructor(private _app: Express) {}\n  registerRouter(baseUrl: string, router: Router, routerItems: IRouterItem[]) {\n    if (this._routerCache[baseUrl]) {\n      throw new Error(&quot;this baseUrl has been used&quot;)\n    }\n    this.addRouters(router, routerItems)\n    this._app.use(baseUrl, router)\n    this._routerCache[baseUrl] = routerItems\n  }\n  private addRouters(router: Router, routerItems: IRouterItem[]) {\n    routerItems.forEach((item) =&gt; {\n      router[item.method](item.url, response2Client(item.handler))\n    })\n  }\n  /**\n   *\n   * @param param0\n   * @returns\n   * get current route config\n   * 查询对应路由配置\n   */\n  getRouterItem&lt;T extends { baseUrl: string; url: string; method: Method }&gt;({ baseUrl, url, method }: T) {\n    // console.log(this._routerCache)\n\n    for (let baseurl in this._routerCache) {\n      for (let item of this._routerCache[baseurl]) {\n        if (method.toUpperCase() === item.method.toUpperCase() &amp;&amp; pathToRegexp(handlePathEnd(baseurl + item.url)).test((baseUrl + url).split(&quot;?&quot;)[0])) return item\n      }\n    }\n  }\n\n  private static _instance: RouterHelper\n  static Instance(app: Express): RouterHelper {\n    if (this._instance) {\n      return this._instance\n    } else {\n      this._instance = new RouterHelper(app)\n      return this.Instance(app)\n    }\n  }\n}\n\n/**\n * 处理路径类似 /login/ 与 /login 冲突问题\n * @param path\n * @returns\n */\nfunction handlePathEnd(path: string) {\n  if (path.slice(-1) === &quot;/&quot;) {\n    return handlePathEnd(path.slice(0, path.length - 1))\n  }\n  return path\n}\n/**\n * response method,it can response data that func return\n * 套了一层，配置路由时不用关心如何返回数据\n * @param func\n * @returns\n */\nconst response2Client = (func: IRouterItem[&quot;handler&quot;]): RequestHandler =&gt; {\n  return async function (request, response, next) {\n    try {\n      const res = await func(request, response)\n      // console.log(res, getResponseData(res), response.headersSent)\n      response.send(getResponseData(res))\n    } catch (err) {\n      //   console.log(err)\n      next(err)\n    }\n  }\n}\n</code></pre>\n<p>方便定义路由写了一个 hook</p>\n<pre><code class="language-ts">export function useRoutes({ router = express.Router(), routerItems, baseUrl }: { router?: Router; routerItems: IRouterItem[]; baseUrl: string }) {\n  function registerRouter(RouterHelperInstance: RouterHelper) {\n    RouterHelperInstance.registerRouter(baseUrl, router, routerItems)\n  }\n\n  return {\n    registerRouter,\n  }\n}\n</code></pre>\n<p><strong>使用</strong></p>\n<pre><code class="language-ts">const { registerRouter } = useRoutes({\n  routerItems: [\n    {\n      method: &quot;get&quot;,\n      url: &quot;/&quot;,\n      async handler(request) {\n        return blogServiceInstance.getBlogsPagenation(request.query as any)\n      },\n      canCORS: true,\n      //   needAuth: true\n    },\n    //...\n  ],\n  baseUrl: &quot;/api/blog&quot;,\n})\n\nexport { registerRouter }\n</code></pre>\n<h3 id="%E4%B8%AD%E9%97%B4%E4%BB%B6(%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0)-middleware" tabindex="-1">中间件(处理函数) middleWare</h3>\n<pre><code class="language-ts">app.get(\n  &quot;/abc/:id&quot;,\n  () =&gt; {\n    中间件1\n    next()\n  },\n  () =&gt; {\n    中间件2\n  }\n)\n</code></pre>\n<p>任意中间件都可以响应，但只能响应一次\n想要执行后续中间件，需要手动调用 next\n一直没有响应,但最后一个中间件调用 next,404\n调用 next(new Error())/throw new error 会寻找后续处理异常中间件</p>\n<pre><code class="language-ts">//use的匹配范围更广\napp.use(&quot;/abc&quot;, (err, req, res, next) =&gt; {\n  console.log(err)\n  if (err) {\n    res.send({\n      err: &quot;err&quot;,\n    })\n  }\n})\nuse的匹配范围更广, use里面的request可以获取到当前匹配的baseURl\n</code></pre>\n<p>自己写的中间件</p>\n<p>authorization</p>\n<pre><code class="language-ts">export function authorizationMiddleWare(): RequestHandler {\n  return function (request, response, next) {\n    let { baseUrl, url, method } = request\n    //路由统一管理就可以直接查了\n    const routerItem = RouterHelperInstance?.getRouterItem({ baseUrl, url, method: method as any })\n    if (!routerItem) {\n      throw new NotFoundError(&quot;path not found:&quot; + baseUrl + url + &quot;,method&quot; + method)\n    } else {\n      if (routerItem.needAuth) {\n        const res = JWTHelperIns.validateJwtToken(request)\n        if (res &amp;&amp; res.loginId) {\n          request.user = res\n          next()\n        } else {\n          throw new ForbiddenError(&quot;authorization fail,please login again&quot;)\n        }\n      } else {\n        next()\n      }\n    }\n  }\n}\n</code></pre>\n<p>cors</p>\n<pre><code class="language-ts">export default function (): RequestHandler {\n  return function (request, response, next) {\n    //是否跨域\n    if (&quot;origin&quot; in request.headers) {\n      let { method, path, baseUrl } = request\n      if (method.toUpperCase() === &quot;OPTIONS&quot;) {\n        method = request.headers[&quot;access-control-request-method&quot;]\n      }\n      const currentRouter = RouterHelperInstance.getRouterItem({\n        baseUrl,\n        method: method as any,\n        url: path,\n      })\n\n      //此路由是否允许跨域\n      if (currentRouter?.canCORS &amp;&amp; whiteList.includes(request.headers.origin)) {\n        //1.简单请求 添加 access-control-allow-origin\n        if (typeof request.headers.origin !== &quot;undefined&quot;) {\n          response.header(&quot;access-control-allow-origin&quot;, request.headers.origin)\n        }\n        //2. 预检请求\n        if (request.method.toUpperCase() === &quot;OPTIONS&quot;) {\n          response.header(&quot;access-control-allow-headers&quot;, request.headers[&quot;access-control-request-headers&quot;])\n          response.header(&quot;access-control-allow-methods&quot;, request.headers[&quot;access-control-request-method&quot;])\n          //未来多少秒内不要发预检了\n          response.header(&quot;access-control-max-age&quot;, &quot;3600&quot;)\n        }\n        //3.带身份凭证 允许带cookie\n        response.header(&quot;access-control-allow-credentials&quot;, &quot;true&quot;)\n      }\n      //预检请求就不往后面走了\n      if (request.method.toUpperCase() === &quot;OPTIONS&quot;) {\n        return response.status(200).end()\n      }\n    }\n    next()\n  }\n}\n</code></pre>\n<p>统一错误请求</p>\n<pre><code class="language-ts">export function errorHandler(): ErrorRequestHandler {\n  return function (err, request, response, next) {\n    const { message, code } = getResponseErrorData(err)\n    response.status(code).send({ message, code })\n  }\n}\n\nenum EServiceErrorCode {\n  UploadError = &quot;413&quot;,\n  ForbiddenError = &quot;401&quot;,\n  ValidateError = &quot;406&quot;,\n  NotFoundError = &quot;406&quot;,\n  UnknownError = &quot;500&quot;,\n}\n\n/**\n * base class\n */\nabstract class SeviceError extends Error {\n  code: EServiceErrorCode\n  constructor(message: string, code: EServiceErrorCode) {\n    super(message)\n    this.code = code\n  }\n}\n\nclass UploadError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.UploadError)\n  }\n}\n\nclass ForbiddenError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.ForbiddenError)\n  }\n}\n\nclass ValidateError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.ValidateError)\n  }\n}\n\nclass NotFoundError extends SeviceError {\n  constructor(res = &quot;file/api not found&quot;) {\n    super(res, EServiceErrorCode.NotFoundError)\n  }\n}\n\nclass UnknownError extends SeviceError {\n  constructor(message: string) {\n    super(message, EServiceErrorCode.UnknownError)\n  }\n}\n</code></pre>\n<h2 id="cookie-session-jwt-%E5%8E%9F%E7%90%86" tabindex="-1">cookie session jwt 原理</h2>\n<p>接口虽好，但如何控制，又或者如何确认是哪个人，不是伪造的信息。因为 http 是无状态的。</p>\n<h3 id="cookie" tabindex="-1">cookie</h3>\n<p>存在客户端 <code>key=value;path=/;domain=?;expire=?;max-age=?secure;httponly</code></p>\n<p>浏览器是会自动存储 cookie.浏览器发送 cookie 规则。</p>\n<ol>\n<li>没有过期</li>\n<li>看 domain(基域) 与端口无关。</li>\n<li>看 path</li>\n<li>secure = true 只能 https\n如果满足条件，浏览器会自动在请求头里面加入 cookie</li>\n</ol>\n<p>只有<strong>key,path,domain</strong>全相同才是同一个 cookie</p>\n<pre><code class="language-ts">interface Cookie{\n   [key: string]: sting\n\n   /**\n\t* 不设置默认当前请求路径\n    */\n   path?: string\n\n   domain?: string\n   /**\n\t* GMT时间，就是UTC时间\n\t* new Date().toGMTString()\n\t* \'Mon, 01 Jul 2024 10:43:49 GMT\'\n    */\n   expire?: string\n   /**\n\t* 多少秒后过期\n    */\n   max-age?: string  //既没有max-age也没有expire的话，就是回话解说词\n\n   /**\n\t* 不设置都发\n\t* 设置只能https\n    */\n   secure?:boolean\n\n   /**\n\t* 只能服务端设置\n\t* 如果设置表示只在传输时使用，js无法使用\n\t* js使用可能会发生xxr(跨站脚本攻击)\n\t* 比如在网站里面嵌入一个iframe,他的js能访问到源网站的cookie\n    */\n   httponly\n}\n</code></pre>\n<h3 id="session" tabindex="-1">session</h3>\n<p>存在服务端，占用服务器资源 sessionid 通过 cookie 传给客户端。通过 sessionid 确认。</p>\n<h3 id="jwt" tabindex="-1">jwt</h3>\n<p>可脱离浏览器端，压根没有 cookie 啊！JSON WEB TOKEN 应运而生\njwt 可以出现在 response 的如何地方，cookie，headers，body\nOAuth2 的话 request 里面\nGET PATH HTTP/1.1\n...\nauthorization： bearer jwt 令牌\n...</p>\n<pre><code class="language-ts">   interface JWT{\n\t   header: {\n\t\t  //    类型\n\t\t  typ:&quot;JWT&quot;,\n\t\t  //    signature签名算法\n\t\t  alg: string|&quot;H256&quot;|...\n\t   }\n\t   //主体信息\n\t   payload: {\n           //一些可选对象\n\t   }\n\t   //保证不被篡改\n\t   signature: string\n   }\n    instance:  base64(header).base64(payload).signature\n    // 服务器端判断\n\tH256(header,payload,服务器端的密钥) === signature\n</code></pre>\n<p>自己写的 Helper</p>\n<pre><code class="language-ts">enum Oath2Token {\n  key = &quot;bearer&quot;,\n}\n\nclass JWTHelper {\n  /**\n   * add token to cookie and authorization\n   * @param res\n   * @param payload\n   * @param maxAge ms\n   */\n  publish(res: Response, payload = {}, maxAge = 3600 * 24 * 1000) {\n    const token = jwt.sign(payload, this._secret, {\n      expiresIn: maxAge,\n    })\n    //可以放cookie\n    // res.cookie(this._cookieKey, token, {\n    //   maxAge,\n    //   path: &quot;/&quot;,\n    // })\n    res.header(&quot;authorization&quot;, token)\n    res.header(&quot;access-control-expose-headers&quot;, &quot;Authorization&quot;)\n  }\n  validateJwtToken(request: Request) {\n    let token: string = request.cookies ? request.cookies[this._cookieKey] : &quot;&quot;\n    if (!token) {\n      token = request.headers.authorization\n    } else {\n      //if token from cookie, add bearer\n      token = &quot;bearer &quot; + token\n    }\n\n    if (!token) {\n      throw new ForbiddenError(&quot;don\'t have token&quot;)\n    }\n    //处理oatu2 的 bearer\n    const tokenArr = token.split(&quot; &quot;)\n    if (tokenArr.length === 2) {\n      if (tokenArr[0].toLowerCase() !== Oath2Token.key) {\n        throw new Error(&quot;token format error&quot;)\n      }\n      token = tokenArr[1]\n    }\n\n    try {\n      const res = jwt.verify(token, this._secret) as ILoginReturn\n      return res\n    } catch (e) {\n      throw e\n    }\n  }\n  constructor(private _secret: string, private _cookieKey: string) {}\n}\n\nconst defaultSetting = {\n  secret: Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-8),\n  cookieKey: &quot;token&quot;,\n}\n\nconst JWTHelperIns = new JWTHelper(defaultSetting.secret, defaultSetting.cookieKey)\n\nexport default JWTHelperIns\n</code></pre>\n<p>​</p>\n<h3 id="%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98-(cors)-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-%E5%8D%8F%E8%AE%AE%EF%BC%8C%E7%AB%AF%E5%8F%A3%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%90%8D" tabindex="-1">跨域问题 (CORS) 浏览器同源策略 协议，端口，主机名</h3>\n<ol>\n<li>jsonp 太古老，不推荐 script 标签只能发送 get 请求 (资源文件允许跨域)</li>\n</ol>\n<pre><code class="language-ts">//back end\nconst res = {}\nresponse.header(&quot;content-type&quot;, &quot;application/javascript&quot;)\nresponse.send(`callback${JSON.stringify(res)}`)\n\n//front end\nfunction jsonp(url) {\n  const el = document.createElement(&quot;script&quot;)\n  el.src = url\n  document.body.appendChild(el)\n  el.onload = () =&gt; {\n    el.remove()\n  }\n}\n\nfunction callback(data) {}\n</code></pre>\n<ol start="2">\n<li>\n<p>CORS cross origin resource sharing</p>\n<ol>\n<li>\n<p>简单请求\nmethod: get post head(下载)\nheader 没有额外信息\ncontent-type : text/pain;multipart/form-data;application/x-www-form-urlencoded</p>\n<p>浏览器自动添加 origin 头\n后端只要返回 Access-Control-Allow-Origin:*/具体域名(推荐使用具体)</p>\n</li>\n<li>\n<p>带预检的请求\n不是简单请求就会用 OPTIONS 预检\n浏览器\nOPTIONS /path HTTP/1.1\nAccess-Control-Request-Method:GET\nAccess-Control-Request-Headers:a\nOrigin:xxxx</p>\n</li>\n</ol>\n<p>后端允许\nAccess-Control-Request-Method:GET\nAccess-Control-Request-Headers:a\naccess-control-max-age:?:&quot;3600&quot; //未来多少秒内不需要预检 3) 带身份凭证(如 cookie) <strong>注：当 Access-Control-Allow-Origin 为*时,不能带凭证</strong>\n&quot;access-control-allow-credentials&quot;：&quot;true&quot;</p>\n</li>\n</ol>\n<h2 id="%E5%90%8E%E7%AB%AF%E5%B8%B8%E7%94%A8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84" tabindex="-1">后端常用三层架构</h2>\n<h2 id="%E8%B7%AF%E7%94%B1%E5%B1%82-route" tabindex="-1">路由层 Route</h2>\n<pre><code class="language-tex"> 提供对外API express配置路由    略\n</code></pre>\n<h2 id="%E6%9C%8D%E5%8A%A1%E5%B1%82-service" tabindex="-1">服务层 Service</h2>\n<p>业务逻辑</p>\n<p>这边使用使用了自己写的装饰器来简单判断合法</p>\n<pre><code class="language-ts">class AdminService {\n  /**\n   * 判断login成功与否\n   * @param param0\n   * @returns\n   */\n  @FuncIntercepter({}, { groups: [&quot;checkUserValid&quot;] })\n  async isUserValidate(@ParamType(AdminValidate) { loginId, loginPwd }: Partial&lt;IAdmin&gt;) {\n    loginPwd = md5(loginPwd)\n    const res = await AdminDaoInstance.queryUser({ loginId, loginPwd })\n    if (res &amp;&amp; res.dataValues) {\n      return { res: true, row: res.dataValues }\n    }\n    return { res: false }\n  }\n  /**\n   * set Authorization header\n   * @param response\n   * @param param1\n   */\n  @FuncIntercepter()\n  async setAuthorization(response: Express.Response, @ParamType(AdminValidate) { loginId, name, remember, role }: Partial&lt;ILoginData&gt;) {\n    remember = remember ? +remember : 1\n    JWTHelperIns.publish(response as any, { loginId, name, role }, 60 * 60 * 24 * remember)\n  }\n  @FuncIntercepter()\n  async updateUserPwd&lt;T extends IUpdateUserPwd&gt;(@ParamType(AdminValidate) { loginId, loginPwd, oldPwd, name }: T) {\n    const { res, row } = await this.isUserValidate({ loginId, loginPwd: oldPwd })\n    if (res &amp;&amp; row) {\n      // console.log(row);\n      const { id } = row as IAdmin\n      return await AdminDaoInstance.updateUser(\n        {\n          loginPwd: md5(loginPwd),\n          name,\n        },\n        { id }\n      )\n    } else {\n      throw new ValidateError(&quot;old password error&quot;)\n    }\n  }\n}\n</code></pre>\n<h2 id="%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82-dao" tabindex="-1">数据访问层 DAO</h2>\n<p>与数据库交互 通常是 ORM,相当于 MVVM,与数据库之间依赖一个抽象</p>\n<pre><code class="language-ts">class AdminDao {\n  async queryUser({ loginId, loginPwd }: Pick&lt;IAdmin, &quot;loginId&quot; | &quot;loginPwd&quot;&gt;) {\n    return await Admin.findOne({\n      where: {\n        loginId,\n        loginPwd,\n        isValid: &quot;Y&quot;,\n      },\n    })\n  }\n  async updateUser(newInfo: Partial&lt;IAdmin&gt;, where: Partial&lt;IAdmin&gt;) {\n    return await Admin.update(newInfo, {\n      where,\n    })\n  }\n}\n</code></pre>\n',
      category: { id: 63, name: "Node" },
    },
  },
  3: {
    code: 200,
    data: {
      id: 3,
      title: "JS查漏补缺",
      description: "了解HTTP与HTTPS协议,学习网络请求原理",
      scanNumber: "0",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "js",
          name: "js",
          tag: "h1",
          children: [
            { anchor: "%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0", name: "构造函数", tag: "h2", children: [] },
            { anchor: "%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6-property-descriptor", name: "属性描述符 property descriptor", tag: "h2", children: [] },
            {
              anchor: "es6",
              name: "ES6",
              tag: "h2",
              children: [
                { anchor: "1.-symbol", name: "1. symbol", tag: "h3", children: [] },
                { anchor: "2.-iterator", name: "2. iterator", tag: "h3", children: [] },
                { anchor: "3.-%E7%94%9F%E6%88%90%E5%99%A8(generator)", name: "3. 生成器(generator)", tag: "h3", children: [] },
              ],
            },
            { anchor: "reflect", name: "Reflect", tag: "h2", children: [] },
            { anchor: "proxy", name: "proxy", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="js" tabindex="-1">js</h1>\n<h2 id="%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" tabindex="-1">构造函数</h2>\n<ol>\n<li><strong>js 中所有对象都是通过构造函数产生的</strong></li>\n</ol>\n<pre><code class="language-ts">      const obj = {1:1} =&gt; const o = new Object()  o[1] = 1\n      const arr = [1,2] =&gt; const arr2 = new Array(1,2)\n      const sum = (a,b)=&gt;a+b =&gt; const sum = new Function(\'a\',\'b\',\'return a+b\')\n</code></pre>\n<ol start="2">\n<li>\n<p><strong>prototype 三角关系</strong>\n每次 <code>new instance</code> 的时候，会产生大量重复内容，占大量内存。特别是方法。\n函数(对象)有一个属性叫<strong>prototype 的对象{}</strong>,instance 的<code>__proto__</code>(隐式原型)也会指向它。\n所以公用成员的会放在 prototype\n现代浏览器中 <strong><code>[[Prototype]]</code></strong> 就是 <code>__proto__</code></p>\n</li>\n<li>\n<p><code>this</code> <strong>一般取决于调用</strong>\n特殊的:</p>\n<ol>\n<li>()=&gt;{}\n定义时确定<code>this</code></li>\n<li>手动</li>\n</ol>\n<pre><code class="language-ts">     function a(){\n       ...\n     }\n     a() &lt;=&gt; a.call()\n\n     a.call(this,...argment)\n     a.apply(this,...arg:[])\n\n</code></pre>\n</li>\n<li>\n<p>原型链 -- 隐式原型链 常见方法</p>\n<ol>\n<li>instanceof\n<strong><code>__proto__</code>/constructor.prototype</strong> 上面是否存在 。简单理解为 <code>是</code></li>\n<li>Object.getPrototypeOf(o)\n获取隐式原型 不建议直接用<code>__proto__</code></li>\n<li>const obj = Object.create(target)\n设置原型 斩断原型链</li>\n<li>Object.setPrototypeOf(a1,a2)\n设置原型</li>\n<li>继承\nUser.call(this,name)\nObject.setPrototypeOf(VipUser.prototype,User.prototype)\n<strong>注: 现在 Reflect.setPrototypeOf，Reflect.getPrototypeOf 也可以操作</strong></li>\n</ol>\n</li>\n</ol>\n<h2 id="%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6-property-descriptor" tabindex="-1">属性描述符 property descriptor</h2>\n<pre><code class="language-ts">interface Descriptor {\n  value: 2\n  writable: true\n  enumerable: true //影响遍历,for in, Object.keys() in 会遍历__proto__\n  configurable: true //属性描述符是否可以修改\n  get: () =&gt; {}\n  set: () =&gt; {}\n}\nObject.defineProperty(obj, &quot;key&quot;, {})\n</code></pre>\n<p><strong>注: get,set 与 value,writable 互斥</strong></p>\n<h4>存取器属性</h4>\n<p>属性描述符中设置了 get,set\n以函数代替属性, 提升了可操作性</p>\n<h2 id="es6" tabindex="-1">ES6</h2>\n<h3 id="1.-symbol" tabindex="-1">1. symbol</h3>\n<h3 id="2.-iterator" tabindex="-1">2. iterator</h3>\n<p>迭代器</p>\n<pre><code class="language-ts">function next() {\n  return { done: boolen, value: T }\n}\n</code></pre>\n<p><strong>迭代器协议</strong></p>\n<p>对象 具有知名符合属性<code>symbol.iterator</code>,并且该属性是一个迭代器创建函数，iterable</p>\n<h3 id="3.-%E7%94%9F%E6%88%90%E5%99%A8(generator)" tabindex="-1">3. 生成器(generator)</h3>\n<p><strong>通过构造函数 Generator 创造的对象, 生成器既是一个迭代器(有 next),也是一个 iterable 对象[symbol.iterator]</strong></p>\n<ol>\n<li>\n<p>生成器可以有返回值, 第一次 done: true 的 value 就是返回值</p>\n<pre><code class="language-ts">\tfunction *g(){\n\t\tyield 2\n\t\treturn 1\n\t}\n\tconst g = g()\n\tg.next() {done: false,value:2}\n\tg.next() {done: true, value:1}\n\tg.next() {done: true,value: undefined}\n</code></pre>\n</li>\n<li>\n<p>生成器 next()的参数会交给 yeild 表达式的返回值</p>\n<pre><code class="language-ts">\tfunction *g(){\n\t\tlet i = yield 2\n\t\tyield i + 1\n\t}\n\tconst g = g()\n\tg.next() {done: false,value:2}\n\tg.next(10) {done: true, value:11}\n\tg.next() {done: true,value: undefined}\n</code></pre>\n<p><strong>第一次 next() 传参没有意义，见上</strong></p>\n</li>\n<li>\n<p>生成器嵌套</p>\n<pre><code class="language-ts">function *g(){\n\tyield 2\n\treturn 1\n}\nfunction *g2(){\n\tyield *g()\n\tyield 3\n}\nconst g = g2()\ng.next() {done: false,value:2}\ng.next() {done: false, value:3}\ng.next() {done: true,value: undefined}\n</code></pre>\n</li>\n<li>\n<p>其他 API\n<strong>return</strong>\n可以提前结束生成器</p>\n<pre><code class="language-ts">function* g() {\n  yield 2\n  return 1\n}\nconst g = g()\ng.return(0)\n</code></pre>\n<p><strong>throw</strong>\n这生成器中产生错误</p>\n</li>\n</ol>\n<h2 id="reflect" tabindex="-1">Reflect</h2>\n<p>js 内置 Api 访问底层功能 函数式编程</p>\n<h2 id="proxy" tabindex="-1">proxy</h2>\n<p>拦截一些底层操作，通常与 Reflect 公用，比如 vue 的 track，trigger 操作</p>\n<pre><code class="language-ts">const targetProxy = new Proxy(target, {\n  set() {\n    const type = target.hasOwnProperty(key) ? ETriggerType.set : ETriggerType.add\n\n    const oldValue = target[key]\n    const oldLength = Array.isArray(target) ? target.length : null\n\n    const res = Reflect.set(target, key, newValue, receiver)\n\n    if (isChanged(oldValue, newValue)) {\n      trigger({\n        target,\n        type,\n        key: key as any,\n      })\n      //数组的长度变化处理\n      if (Array.isArray(target)) {\n        const newLength = target.length\n        //如果隐式修改了length手动触发length更新\n        if (key !== &quot;length&quot; &amp;&amp; oldLength !== newLength) {\n          trigger({\n            target,\n            type: ETriggerType.set,\n            key: &quot;length&quot;,\n          })\n        }\n        //如果显示修改length,变大是正常的，变小的话，手动触发删除\n        else if (newLength &lt; (oldLength as number)) {\n          for (let i = newLength; i &lt; (oldLength as number); i++) {\n            trigger({\n              target,\n              type: ETriggerType.delete,\n              key: i,\n            })\n          }\n        }\n      }\n    }\n    return res\n  },\n  get() {\n    //获取原始对象,不会存到proxyMap\n    if (key === RAW) {\n      return target\n    }\n    //数组可能存在一些问题,因为默认情况下对象成员全部通过get成了代理\n    //   console.log(key, target)\n    if (Array.isArray(target) &amp;&amp; [...Object.values(EArrayErrorType), ...Object.values(EArrayErrorType2)].includes(key as any)) {\n      return arrayInstrumentactions[key]\n    }\n\n    const res = Reflect.get(target, key, receiver)\n\n    //拦截收集依赖\n    track({\n      target,\n      key,\n      type: ETrackType.get,\n    })\n    //   console.log(&quot;拦截&quot; + (key as any))\n    if (res instanceof Object &amp;&amp; typeof res === &quot;object&quot;) {\n      return reactive(res)\n    }\n    return res\n  },\n})\n</code></pre>\n',
      category: { id: 64, name: "JavaScript" },
    },
  },
  4: {
    code: 200,
    data: {
      id: 4,
      title: "常用CSS3汇总",
      description: "HTML5+CSS3大大改善了开发体验,js确实很重要，css也是不可或缺的，让我们看看ccs3究竟新增了哪来内容",
      scanNumber: "0",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "%E5%B8%83%E5%B1%80",
          name: "布局",
          tag: "h1",
          children: [
            {
              anchor: "%E5%BC%B9%E6%80%A7%E7%9B%92",
              name: "弹性盒",
              tag: "h2",
              children: [
                { anchor: "%E7%94%9F%E6%88%90%E5%BC%B9%E6%80%A7%E5%AE%B9%E5%99%A8%E5%92%8C%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE", name: "生成弹性容器和弹性项目", tag: "h3", children: [] },
                { anchor: "%E6%9B%B4%E6%94%B9%E6%96%B9%E5%90%91", name: "更改方向", tag: "h3", children: [] },
                { anchor: "%E4%B8%BB%E8%BD%B4%E6%8E%92%E5%88%97", name: "主轴排列", tag: "h3", children: [] },
                { anchor: "%E4%BE%A7%E8%BD%B4%E6%8E%92%E5%88%97", name: "侧轴排列", tag: "h3", children: [] },
                { anchor: "%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE%E4%BC%B8%E7%BC%A9", name: "弹性项目伸缩", tag: "h3", children: [] },
                { anchor: "%E4%B8%BB%E8%BD%B4%E6%8D%A2%E8%A1%8C", name: "主轴换行", tag: "h3", children: [] },
              ],
            },
            {
              anchor: "%E7%BD%91%E6%A0%BC",
              name: "网格",
              tag: "h2",
              children: [
                { anchor: "%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80", name: "生成网格布局", tag: "h3", children: [] },
                { anchor: "%E5%AE%9A%E4%B9%89%E8%A1%8C%E5%92%8C%E5%88%97", name: "定义行和列", tag: "h3", children: [] },
                { anchor: "%E6%94%B9%E5%8F%98%E6%8E%92%E5%88%97%E6%96%B9%E5%90%91", name: "改变排列方向", tag: "h3", children: [] },
                { anchor: "%E5%8D%95%E5%85%83%E6%A0%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%99", name: "单元格之间的间隙", tag: "h3", children: [] },
                { anchor: "%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E9%83%A8%E7%9A%84%E5%AF%B9%E9%BD%90", name: "单元格内部的对齐", tag: "h3", children: [] },
                { anchor: "%E7%BD%91%E6%A0%BC%E9%A1%B9%E7%9B%AE%E5%AE%9A%E4%BD%8D", name: "网格项目定位", tag: "h3", children: [] },
              ],
            },
          ],
        },
        {
          anchor: "%E8%A7%86%E8%A7%89",
          name: "视觉",
          tag: "h1",
          children: [
            {
              anchor: "%E9%98%B4%E5%BD%B1",
              name: "阴影",
              tag: "h2",
              children: [
                { anchor: "%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1", name: "盒子阴影", tag: "h3", children: [] },
                { anchor: "%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1", name: "文字阴影", tag: "h3", children: [] },
              ],
            },
            { anchor: "%E5%9C%86%E8%A7%92", name: "圆角", tag: "h2", children: [] },
            { anchor: "%E8%83%8C%E6%99%AF%E6%B8%90%E5%8F%98", name: "背景渐变", tag: "h2", children: [] },
            {
              anchor: "%E5%8F%98%E5%BD%A2",
              name: "变形",
              tag: "h2",
              children: [
                { anchor: "translate-%E5%B9%B3%E7%A7%BB", name: "translate 平移", tag: "h3", children: [] },
                { anchor: "scale-%E7%BC%A9%E6%94%BE", name: "scale 缩放", tag: "h3", children: [] },
                { anchor: "rotate-%E6%97%8B%E8%BD%AC", name: "rotate 旋转", tag: "h3", children: [] },
                { anchor: "%E6%94%B9%E5%8F%98%E5%8F%98%E5%BD%A2%E5%8E%9F%E7%82%B9", name: "改变变形原点", tag: "h3", children: [] },
                { anchor: "%E5%A4%9A%E7%A7%8D%E5%8F%98%E5%BD%A2%E5%8F%A0%E5%8A%A0", name: "多种变形叠加", tag: "h3", children: [] },
              ],
            },
          ],
        },
        {
          anchor: "%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB",
          name: "过渡和动画",
          tag: "h1",
          children: [
            { anchor: "%E8%BF%87%E6%B8%A1", name: "过渡", tag: "h2", children: [] },
            { anchor: "%E5%8A%A8%E7%94%BB", name: "动画", tag: "h2", children: [] },
          ],
        },
        {
          anchor: "%E5%85%B6%E4%BB%96",
          name: "其他",
          tag: "h1",
          children: [
            { anchor: "box-sizing", name: "box-sizing", tag: "h2", children: [] },
            { anchor: "%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87", name: "字体图标", tag: "h2", children: [] },
            { anchor: "%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E9%80%82%E5%BA%94", name: "图像内容适应", tag: "h2", children: [] },
            { anchor: "%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D", name: "视口单位", tag: "h2", children: [] },
            { anchor: "%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8", name: "伪元素选择器", tag: "h2", children: [] },
            { anchor: "%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8", name: "平滑滚动", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="%E5%B8%83%E5%B1%80" tabindex="-1">布局</h1>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511102802.png" alt="image-20210511102549096"></p>\n<p><strong>浮动</strong>：做文字环绕效果</p>\n<p><strong>弹性盒</strong>：单行或单列布局</p>\n<p><strong>网格</strong>：多行多列布局</p>\n<h2 id="%E5%BC%B9%E6%80%A7%E7%9B%92" tabindex="-1">弹性盒</h2>\n<blockquote>\n<p>详细文档见<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout">MDN</a></p>\n<p><a href="https://flexboxfroggy.com/">弹性盒小游戏</a></p>\n</blockquote>\n<h3 id="%E7%94%9F%E6%88%90%E5%BC%B9%E6%80%A7%E5%AE%B9%E5%99%A8%E5%92%8C%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE" tabindex="-1">生成弹性容器和弹性项目</h3>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511112624.png" alt="image-20210511112624876"></p>\n<p>**默认情况下，**弹性项目沿着主轴依次排列，侧轴拉伸</p>\n<h3 id="%E6%9B%B4%E6%94%B9%E6%96%B9%E5%90%91" tabindex="-1">更改方向</h3>\n<p>通过<code>flex-direction</code>可更改主轴方向</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511112510.png" alt="image-20210511112510632"></p>\n<h3 id="%E4%B8%BB%E8%BD%B4%E6%8E%92%E5%88%97" tabindex="-1">主轴排列</h3>\n<p>通过<code>justify-content</code>属性，可以影响主轴的排列方式</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511113617.png" alt="image-20210511113617325"></p>\n<h3 id="%E4%BE%A7%E8%BD%B4%E6%8E%92%E5%88%97" tabindex="-1">侧轴排列</h3>\n<p>通过<code>align-items</code>属性，可以影响侧轴的排列方式</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511114016.png" alt="image-20210511114016304"></p>\n<h3 id="%E5%BC%B9%E6%80%A7%E9%A1%B9%E7%9B%AE%E4%BC%B8%E7%BC%A9" tabindex="-1">弹性项目伸缩</h3>\n<p>所谓伸缩，是指在<strong>主轴方向</strong>上，当<strong>弹性容器</strong>有<strong>额外空间</strong>时，是否需要拉伸，当<strong>空间不足</strong>时，是否需要<strong>压缩</strong></p>\n<p>在<strong>弹性项目</strong>上使用<code>flex</code>属性，可设置拉伸和压缩比例：<code>flex: 拉伸比例 压缩比例 初始尺寸</code></p>\n<p>拉伸示例：</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511120916.png" alt="image-20210511120916571"></p>\n<p>压缩示例：</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511121459.png" alt="image-20210511121459341"></p>\n<p>默认情况下，<code>flex: 0 1 auto</code></p>\n<h3 id="%E4%B8%BB%E8%BD%B4%E6%8D%A2%E8%A1%8C" tabindex="-1">主轴换行</h3>\n<p>默认情况，当主轴剩余空间不足时，按照压缩比例进行压缩，但如果设置了主轴换行，则不会压缩，直接换行显示</p>\n<p>给<strong>弹性容器</strong>设置<code>flex-wrap: wrap</code>，即可主轴换行</p>\n<img src="http://mdrs.yuanjin.tech/img/20210511123310.png" alt="image-20210511123310673" style="zoom:50%;" />\n<blockquote>\n<p>尽管如此，多行多列仍然推荐使用网格布局</p>\n</blockquote>\n<h2 id="%E7%BD%91%E6%A0%BC" tabindex="-1">网格</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout">MDN 详细文档</a></p>\n<p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">阮一峰网格布局教程</a></p>\n<p><a href="https://cssgridgarden.com/">网格布局小游戏</a></p>\n</blockquote>\n<p><strong>网格布局是多行多列布局的终极解决方案</strong></p>\n<h3 id="%E7%94%9F%E6%88%90%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80" tabindex="-1">生成网格布局</h3>\n<img src="http://mdrs.yuanjin.tech/img/20210511165317.png" alt="image-20210511165317363" style="zoom:50%;" />\n<p>容器生成网格布局后，其所有子元素为<strong>网格项目</strong></p>\n<h3 id="%E5%AE%9A%E4%B9%89%E8%A1%8C%E5%92%8C%E5%88%97" tabindex="-1">定义行和列</h3>\n<p><code>grid-template-rows</code>：定义行</p>\n<p><code>grid-template-columns</code>：定义列</p>\n<p><strong>它们的语法是相同的</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210511172305.png" alt="image-20210511172305100"></p>\n<h3 id="%E6%94%B9%E5%8F%98%E6%8E%92%E5%88%97%E6%96%B9%E5%90%91" tabindex="-1">改变排列方向</h3>\n<p>使用属性<code>grid-auto-flow: column</code>，可使子元素按列排放</p>\n<img src="http://mdrs.yuanjin.tech/img/20210511173447.png" alt="image-20210511173447321" style="zoom:50%;" />\n<h3 id="%E5%8D%95%E5%85%83%E6%A0%BC%E4%B9%8B%E9%97%B4%E7%9A%84%E9%97%B4%E9%9A%99" tabindex="-1">单元格之间的间隙</h3>\n<pre><code class="language-css">row-gap: 10px; /* 行间隙为10px */\ncolumn-gap: 20px; /* 列间隙为20px */\ngap: 10px 20px; /* 行间隙为10px，列间隙为20px */\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512132025.png" alt="image-20210512132025687"></p>\n<h3 id="%E5%8D%95%E5%85%83%E6%A0%BC%E5%86%85%E9%83%A8%E7%9A%84%E5%AF%B9%E9%BD%90" tabindex="-1">单元格内部的对齐</h3>\n<p>默认情况下，网格项目在单元格内部水平和垂直拉伸，以撑满单元格</p>\n<p>可以使用属性<code>justify-items</code>设置<strong>水平方向</strong>的排列方式</p>\n<p>可以使用属性<code>align-items</code>设置<strong>垂直方向</strong>的排列方式</p>\n<p>它们的可取值是相同的：</p>\n<pre><code class="language-css">justify-items: start 左 | end 右 | center 中 | stretch 拉伸;\nalign-items: start 上 | end 下 | center 中 | stretch 拉伸;\n</code></pre>\n<img src="http://mdrs.yuanjin.tech/img/20210511174450.png" alt="image-20210511174450356" style="zoom:50%;" />\n<p>可以使用速写属性<code>place-items: 垂直对齐方式 水平对齐方式</code>同时设置这两个值</p>\n<pre><code class="language-css">place-items: start center; /* 垂直靠上，水平居中 */\n</code></pre>\n<h3 id="%E7%BD%91%E6%A0%BC%E9%A1%B9%E7%9B%AE%E5%AE%9A%E4%BD%8D" tabindex="-1">网格项目定位</h3>\n<p>默认情况下，网格项目依次排列到单元格中，每个网格占据一个单元格</p>\n<p>但可以对网格项目设置<code>grid-area</code>属性来改变这一行为</p>\n<p>使用方式为：</p>\n<pre><code class="language-css">grid-area: 起始行线编号/起始列线编号/结束行线编号/结束列线编号;\n</code></pre>\n<img src="http://mdrs.yuanjin.tech/img/20210511180028.png" alt="image-20210511180027983" style="zoom:50%;" />\n<h1 id="%E8%A7%86%E8%A7%89" tabindex="-1">视觉</h1>\n<blockquote>\n<p>所谓视觉类样式，是指不影响盒子位置、尺寸的样式，例如文字颜色、背景颜色、背景图片等</p>\n</blockquote>\n<h2 id="%E9%98%B4%E5%BD%B1" tabindex="-1">阴影</h2>\n<h3 id="%E7%9B%92%E5%AD%90%E9%98%B4%E5%BD%B1" tabindex="-1">盒子阴影</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>box-shadow</code>属性可以设置整个盒子的阴影</p>\n<p>下面是一些示例</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/box-shadow.html?v=2" style="height:900px;"></iframe>\n<h3 id="%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1" tabindex="-1">文字阴影</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>text-shadow</code>可以设置文字阴影</p>\n<p>下面是一些示例</p>\n<h3 id="%E6%96%87%E5%AD%97%E9%98%B4%E5%BD%B1-1" tabindex="-1">文字阴影</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/text-shadow">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>text-shadow</code>可以设置文字阴影</p>\n<p>下面是一些示例</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/text-shadow.html?v=3" style="height:500px;"></iframe>\n<h2 id="%E5%9C%86%E8%A7%92" tabindex="-1">圆角</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">MDN 详细文档</a></p>\n</blockquote>\n<p>通过设置<code>border-radius</code>，可以设置盒子的圆角</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512131026.png" alt="image-20210512131026084"></p>\n<p><code>border-radius</code>可以有很多灵活的用法，将下面的代码依次粘贴到页面中测试一下</p>\n<pre><code class="language-css">border-radius: 10px; /* 同时设置4个角的圆角，半径为10px */\nborder-radius: 50%; /* 同时设置4个角的圆角，圆的横向半径为宽度一半，纵向半径为高度一半 */\nborder-radius: 10px 20px 30px 40px; /* 分别设置左上、右上、右下、左下的圆角 */\n</code></pre>\n<h2 id="%E5%9C%86%E8%A7%92-1" tabindex="-1">圆角</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">MDN 详细文档</a></p>\n</blockquote>\n<p>通过设置<code>border-radius</code>，可以设置盒子的圆角</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512131026.png" alt="image-20210512131026084"></p>\n<p><code>border-radius</code>可以有很多灵活的用法，将下面的代码依次粘贴到页面中测试一下</p>\n<pre><code class="language-css">border-radius: 10px; /* 同时设置4个角的圆角，半径为10px */\nborder-radius: 50%; /* 同时设置4个角的圆角，圆的横向半径为宽度一半，纵向半径为高度一半 */\nborder-radius: 10px 20px 30px 40px; /* 分别设置左上、右上、右下、左下的圆角 */\n</code></pre>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/border-raduis.html?v=5" style="height:550px;"></iframe>\n<h2 id="%E8%83%8C%E6%99%AF%E6%B8%90%E5%8F%98" tabindex="-1">背景渐变</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()">MDN 详细文档</a></p>\n</blockquote>\n<p>在设置<strong>背景图片</strong>时，除了可以使用<code>url()</code>加载一张背景图，还可以使用<code>linear-gradient()</code>函数设置背景渐变</p>\n<p><code>linear-gradient()</code>用于创建一张渐变的图片，语法为：</p>\n<pre><code class="language-css">/* 设置渐变背景，方向：从上到下，颜色：从#e66465渐变到#9198e5 */\nbackground: linear-gradient(to bottom, #e66465, #9198e5);\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512135028.png" alt="image-20210512135024676"></p>\n<h2 id="%E5%8F%98%E5%BD%A2" tabindex="-1">变形</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>transform</code>属性，可以使盒子的形态发生变化</p>\n<p>该属性支持多种变形方案，常见的有:</p>\n<ul>\n<li>translate，平移</li>\n<li>scale，缩放</li>\n<li>rotate，旋转</li>\n</ul>\n<p><strong>无论是哪一种 transform，都只是视觉效果的变化，不会影响盒子的布局</strong></p>\n<p><strong>transform 不会导致浏览器 reflow 和 rerender，因此效率极高</strong></p>\n<h3 id="translate-%E5%B9%B3%E7%A7%BB" tabindex="-1">translate 平移</h3>\n<p>使用<code>translate</code>可以让盒子在原来位置上产生位移，类似于相对定位</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512140643.png" alt="image-20210512140622630"></p>\n<h3 id="scale-%E7%BC%A9%E6%94%BE" tabindex="-1">scale 缩放</h3>\n<p>使用<code>translate</code>可以让盒子在基于原来的尺寸发生缩放</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512141500.png" alt="image-20210512141500499"></p>\n<h3 id="rotate-%E6%97%8B%E8%BD%AC" tabindex="-1">rotate 旋转</h3>\n<p>使用<code>rotate</code>属性可以在原图基础上进行旋转</p>\n<pre><code class="language-css">/* 在原图的基础上，顺时针旋转45度角 */\ntransform: rotate(45deg);\n/* 在原图的基础上，顺时针旋转半圈 */\ntransform: rotate(0.5turn);\n</code></pre>\n<p>可以点击下面的按钮试一下旋转效果</p>\n<h2 id="%E8%83%8C%E6%99%AF%E6%B8%90%E5%8F%98-1" tabindex="-1">背景渐变</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient()">MDN 详细文档</a></p>\n</blockquote>\n<p>在设置<strong>背景图片</strong>时，除了可以使用<code>url()</code>加载一张背景图，还可以使用<code>linear-gradient()</code>函数设置背景渐变</p>\n<p><code>linear-gradient()</code>用于创建一张渐变的图片，语法为：</p>\n<pre><code class="language-css">/* 设置渐变背景，方向：从上到下，颜色：从#e66465渐变到#9198e5 */\nbackground: linear-gradient(to bottom, #e66465, #9198e5);\n</code></pre>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512135028.png" alt="image-20210512135024676"></p>\n<h2 id="%E5%8F%98%E5%BD%A2-1" tabindex="-1">变形</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform">MDN 详细文档</a></p>\n</blockquote>\n<p>通过<code>transform</code>属性，可以使盒子的形态发生变化</p>\n<p>该属性支持多种变形方案，常见的有:</p>\n<ul>\n<li>translate，平移</li>\n<li>scale，缩放</li>\n<li>rotate，旋转</li>\n</ul>\n<p><strong>无论是哪一种 transform，都只是视觉效果的变化，不会影响盒子的布局</strong></p>\n<p><strong>transform 不会导致浏览器 reflow 和 rerender，因此效率极高</strong></p>\n<h3 id="translate-%E5%B9%B3%E7%A7%BB-1" tabindex="-1">translate 平移</h3>\n<p>使用<code>translate</code>可以让盒子在原来位置上产生位移，类似于相对定位</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512140643.png" alt="image-20210512140622630"></p>\n<h3 id="scale-%E7%BC%A9%E6%94%BE-1" tabindex="-1">scale 缩放</h3>\n<p>使用<code>translate</code>可以让盒子在基于原来的尺寸发生缩放</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210512141500.png" alt="image-20210512141500499"></p>\n<h3 id="rotate-%E6%97%8B%E8%BD%AC-1" tabindex="-1">rotate 旋转</h3>\n<p>使用<code>rotate</code>属性可以在原图基础上进行旋转</p>\n<pre><code class="language-css">/* 在原图的基础上，顺时针旋转45度角 */\ntransform: rotate(45deg);\n/* 在原图的基础上，顺时针旋转半圈 */\ntransform: rotate(0.5turn);\n</code></pre>\n<p>可以点击下面的按钮试一下旋转效果</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/rotate.html" style="height:400px;"></iframe>\n<h3 id="%E6%94%B9%E5%8F%98%E5%8F%98%E5%BD%A2%E5%8E%9F%E7%82%B9" tabindex="-1">改变变形原点</h3>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-origin">MDN 详细文档</a></p>\n</blockquote>\n<p>变形原点的位置，会影响到具体的变形行为</p>\n<p>默认情况下，变形的原点在盒子中心，你可以通过<code>transform-origin</code>来改变它</p>\n<pre><code class="language-css">transform-origin: center; /* 设置原点在盒子中心 */\ntransform-origin: left top; /* 设置原点在盒子左上角 */\ntransform-origin: right bottom; /* 设置原点在盒子右下角 */\ntransform-origin: 30px 60px; /* 设置原点在盒子坐标 (30, 60) 位置 */\n</code></pre>\n<p>试一试，先点击设置原点的按钮来设置原点(已在图片中使用红色小点标记)，然后点击变形按钮进行变形</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/transform-origin.html?v2" style="height:600px;"></iframe>\n<h3 id="%E5%A4%9A%E7%A7%8D%E5%8F%98%E5%BD%A2%E5%8F%A0%E5%8A%A0" tabindex="-1">多种变形叠加</h3>\n<p>可以一次性设置多种变形效果</p>\n<pre><code class="language-css">/* 先旋转45度，再平移(100,100) */\ntransform: rotate(45deg) translate(100px, 100px);\n/* 先平移(100, 100)，再旋转45度 */\ntransform: translate(100px, 100px) rotate(45deg);\n</code></pre>\n<p>注意：旋转会导致坐标系也跟着旋转，从而可能影响到后续的变形效果</p>\n<p>下面的例子可以很好的说明这一点</p>\n<h3 id="%E5%A4%9A%E7%A7%8D%E5%8F%98%E5%BD%A2%E5%8F%A0%E5%8A%A0-1" tabindex="-1">多种变形叠加</h3>\n<p>可以一次性设置多种变形效果</p>\n<pre><code class="language-css">/* 先旋转45度，再平移(100,100) */\ntransform: rotate(45deg) translate(100px, 100px);\n/* 先平移(100, 100)，再旋转45度 */\ntransform: translate(100px, 100px) rotate(45deg);\n</code></pre>\n<p>注意：旋转会导致坐标系也跟着旋转，从而可能影响到后续的变形效果</p>\n<p>下面的例子可以很好的说明这一点</p>\n<iframe src="http://mdrs.yuanjin.tech/html/css-manual/multi-transform.html" style="height:600px;"></iframe>\n<blockquote>\n<p>本来打算把这个效果嵌入到 markdown，但由于嵌入后出现一些未知的 bug，因此只能粘贴效果地址了</p>\n</blockquote>\n<h1 id="%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB" tabindex="-1">过渡和动画</h1>\n<p>使用过渡和动画，可以让 css 属性变化更加丝滑</p>\n<p><strong>过渡和动画无法对所有的 CSS 属性产生影响，能够产生影响的只有数值类属性</strong>，例如：颜色、宽高、字体大小等等</p>\n<h2 id="%E8%BF%87%E6%B8%A1" tabindex="-1">过渡</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN 详细文档</a></p>\n</blockquote>\n<pre><code class="language-css">transition: 过渡属性 持续时间 过渡函数 过渡延迟;\n</code></pre>\n<ul>\n<li>\n<p><strong>过渡属性</strong></p>\n<p>针对哪个 css 属性应用过渡。例如填写<code>transform</code>，则表示仅针对<strong>transform</strong>属性应用过渡。</p>\n<p>若填写<code>all</code>或不填写，则表示针对所有 css 属性都应用过渡</p>\n</li>\n<li>\n<p><strong>持续时间</strong></p>\n<p>css 属性变化所持续的时间，需要带上单位。例如<code>3s</code>表示 3 秒，<code>0.5s</code>或<code>500ms</code>均表示 500 毫秒</p>\n</li>\n<li>\n<p><strong>过渡函数</strong></p>\n<p>本质是 css 属性变化的贝塞尔曲线函数，通常直接使用预设值：</p>\n<p><code>ease-in-out</code>：平滑开始，平滑结束</p>\n<p><code>linear</code>：线性变化</p>\n<p><code>ease-in</code>：仅平滑开始</p>\n<p><code>ease-out</code>：仅平滑结束</p>\n</li>\n<li>\n<p><strong>过渡延迟</strong></p>\n<p>书写规则和持续时间一样，表示过渡效果延迟多久后触发，不填则无延迟</p>\n</li>\n</ul>\n<p><strong>在 JS 中，可以监听元素的<code>transitionstart</code>和<code>transitionend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</strong></p>\n<h2 id="%E5%8A%A8%E7%94%BB" tabindex="-1">动画</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">MDN 详细文档</a></p>\n</blockquote>\n<p><strong>动画的本质是预先定义的一套 css 变化规则，然后给该规则取个名字</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210513172902.png" alt="image-20210513172902413"></p>\n<p>然后，其他元素即可使用这样的规则：</p>\n<pre><code class="language-css">animation: 规则名 持续时间;\n</code></pre>\n<p>在应用规则时，还可以指定更多的信息</p>\n<pre><code class="language-css">animation: 规则名 持续时间 重复次数 时间函数 动画方向 延迟时间;\n</code></pre>\n<p>一些细节：</p>\n<ul>\n<li>定义规则时，<code>0%</code>可以书写为<code>from</code></li>\n<li>定义规则时，<code>100%</code>可以书写为<code>to</code></li>\n<li>重复次数为<code>infinite</code>时，表示无限重复</li>\n<li>动画方向为<code>alternate</code>时，表示交替反向，第 1 次正向，第 2 次反向，第 3 次正向，第 4 次方向，以此类推</li>\n</ul>\n<p><strong>在 JS 中，可以监听元素的<code>animationstart</code>和<code>animationnend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</strong></p>\n<h1 id="%E5%85%B6%E4%BB%96" tabindex="-1">其他</h1>\n<h2 id="box-sizing" tabindex="-1">box-sizing</h2>\n<p>一图胜千言</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514150015.png" alt="image-20210514150015660"></p>\n<p>使用<code>border-box</code>控制尺寸更加直观，因此，很多网站都会加入下面的代码</p>\n<pre><code class="language-css">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2 id="%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87" tabindex="-1">字体图标</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN font-face 指令</a></p>\n</blockquote>\n<p>css3 新增了<code>font-face</code>指令，该指令可以让我们加载网络字体</p>\n<p>其最常见的应用就是字体图标</p>\n<p><strong>字体图标本质上是文字，即通过<code>color</code>设置颜色，通过<code>font-size</code>设置尺寸</strong></p>\n<p>国内使用最多的字体图标平台是<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></p>\n<p>登录平台后即可免费使用其所有字体图标</p>\n<h2 id="%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E9%80%82%E5%BA%94" tabindex="-1">图像内容适应</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">MDN 详细文档</a></p>\n</blockquote>\n<p>css3 属性<code>object-fit</code>可以控制<strong>多媒体内容和与元素</strong>的适应方式，通常应用在<code>img</code>或<code>video</code>元素中</p>\n<p>一图胜千言</p>\n<p>下图中的所有<code>img</code>元素均被固定了宽高，溢出 img 的部分实际上均不会显示</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514134908.png" alt="image-20210514134908778"></p>\n<h2 id="%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D" tabindex="-1">视口单位</h2>\n<p>css3 支持使用<code>vw</code>和<code>vh</code>作为单位，分别表示<code>视口宽度</code>和<code>视口高度</code></p>\n<p>例如<code>1vh</code>表示视口高度的<code>1%</code>，<code>100vw</code>表示视口宽度的<code>100%</code></p>\n<h2 id="%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8" tabindex="-1">伪元素选择器</h2>\n<p>通过<code>::before</code>和<code>::after</code>选择器，可以通过 css 给元素生成两个子元素</p>\n<img src="http://mdrs.yuanjin.tech/img/20210514140049.png" alt="image-20210514140049244" style="zoom:50%;" />\n<p>使用伪元素可以避免在 HTML 中使用过多的空元素</p>\n<p><strong>伪元素必须要有<code>content</code>属性，否则不能生效，如果不需要有元素内容，设置<code>content:\'\'</code></strong></p>\n<h2 id="%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8" tabindex="-1">平滑滚动</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN 详细文档</a></p>\n</blockquote>\n<p>使用<code>scroll-behavior: smooth</code>，可以让滚动更加丝滑</p>\n<p>参见 MDN 效果即可</p>\n<blockquote>\n<p>本来打算把这个效果嵌入到 markdown，但由于嵌入后出现一些未知的 bug，因此只能粘贴效果地址了</p>\n</blockquote>\n<h1 id="%E8%BF%87%E6%B8%A1%E5%92%8C%E5%8A%A8%E7%94%BB-1" tabindex="-1">过渡和动画</h1>\n<p>使用过渡和动画，可以让 css 属性变化更加丝滑</p>\n<p><strong>过渡和动画无法对所有的 CSS 属性产生影响，能够产生影响的只有数值类属性</strong>，例如：颜色、宽高、字体大小等等</p>\n<h2 id="%E8%BF%87%E6%B8%A1-1" tabindex="-1">过渡</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN 详细文档</a></p>\n</blockquote>\n<pre><code class="language-css">transition: 过渡属性 持续时间 过渡函数 过渡延迟;\n</code></pre>\n<ul>\n<li>\n<p><strong>过渡属性</strong></p>\n<p>针对哪个 css 属性应用过渡。例如填写<code>transform</code>，则表示仅针对<strong>transform</strong>属性应用过渡。</p>\n<p>若填写<code>all</code>或不填写，则表示针对所有 css 属性都应用过渡</p>\n</li>\n<li>\n<p><strong>持续时间</strong></p>\n<p>css 属性变化所持续的时间，需要带上单位。例如<code>3s</code>表示 3 秒，<code>0.5s</code>或<code>500ms</code>均表示 500 毫秒</p>\n</li>\n<li>\n<p><strong>过渡函数</strong></p>\n<p>本质是 css 属性变化的贝塞尔曲线函数，通常直接使用预设值：</p>\n<p><code>ease-in-out</code>：平滑开始，平滑结束</p>\n<p><code>linear</code>：线性变化</p>\n<p><code>ease-in</code>：仅平滑开始</p>\n<p><code>ease-out</code>：仅平滑结束</p>\n</li>\n<li>\n<p><strong>过渡延迟</strong></p>\n<p>书写规则和持续时间一样，表示过渡效果延迟多久后触发，不填则无延迟</p>\n</li>\n</ul>\n<p><strong>在 JS 中，可以监听元素的<code>transitionstart</code>和<code>transitionend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</strong></p>\n<h2 id="%E5%8A%A8%E7%94%BB-1" tabindex="-1">动画</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations">MDN 详细文档</a></p>\n</blockquote>\n<p><strong>动画的本质是预先定义的一套 css 变化规则，然后给该规则取个名字</strong></p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210513172902.png" alt="image-20210513172902413"></p>\n<p>然后，其他元素即可使用这样的规则：</p>\n<pre><code class="language-css">animation: 规则名 持续时间;\n</code></pre>\n<p>在应用规则时，还可以指定更多的信息</p>\n<pre><code class="language-css">animation: 规则名 持续时间 重复次数 时间函数 动画方向 延迟时间;\n</code></pre>\n<p>一些细节：</p>\n<ul>\n<li>定义规则时，<code>0%</code>可以书写为<code>from</code></li>\n<li>定义规则时，<code>100%</code>可以书写为<code>to</code></li>\n<li>重复次数为<code>infinite</code>时，表示无限重复</li>\n<li>动画方向为<code>alternate</code>时，表示交替反向，第 1 次正向，第 2 次反向，第 3 次正向，第 4 次方向，以此类推</li>\n</ul>\n<p><strong>在 JS 中，可以监听元素的<code>animationstart</code>和<code>animationnend</code>事件，从而在过渡开始和过渡结束时做一些别的事情</strong></p>\n<h1 id="%E5%85%B6%E4%BB%96-1" tabindex="-1">其他</h1>\n<h2 id="box-sizing-1" tabindex="-1">box-sizing</h2>\n<p>一图胜千言</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514150015.png" alt="image-20210514150015660"></p>\n<p>使用<code>border-box</code>控制尺寸更加直观，因此，很多网站都会加入下面的代码</p>\n<pre><code class="language-css">* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n</code></pre>\n<h2 id="%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87-1" tabindex="-1">字体图标</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN font-face 指令</a></p>\n</blockquote>\n<p>css3 新增了<code>font-face</code>指令，该指令可以让我们加载网络字体</p>\n<p>其最常见的应用就是字体图标</p>\n<p><strong>字体图标本质上是文字，即通过<code>color</code>设置颜色，通过<code>font-size</code>设置尺寸</strong></p>\n<p>国内使用最多的字体图标平台是<a href="https://www.iconfont.cn/">阿里巴巴矢量图标库</a></p>\n<p>登录平台后即可免费使用其所有字体图标</p>\n<h2 id="%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E9%80%82%E5%BA%94-1" tabindex="-1">图像内容适应</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit">MDN 详细文档</a></p>\n</blockquote>\n<p>css3 属性<code>object-fit</code>可以控制<strong>多媒体内容和与元素</strong>的适应方式，通常应用在<code>img</code>或<code>video</code>元素中</p>\n<p>一图胜千言</p>\n<p>下图中的所有<code>img</code>元素均被固定了宽高，溢出 img 的部分实际上均不会显示</p>\n<p><img src="http://mdrs.yuanjin.tech/img/20210514134908.png" alt="image-20210514134908778"></p>\n<h2 id="%E8%A7%86%E5%8F%A3%E5%8D%95%E4%BD%8D-1" tabindex="-1">视口单位</h2>\n<p>css3 支持使用<code>vw</code>和<code>vh</code>作为单位，分别表示<code>视口宽度</code>和<code>视口高度</code></p>\n<p>例如<code>1vh</code>表示视口高度的<code>1%</code>，<code>100vw</code>表示视口宽度的<code>100%</code></p>\n<h2 id="%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8-1" tabindex="-1">伪元素选择器</h2>\n<p>通过<code>::before</code>和<code>::after</code>选择器，可以通过 css 给元素生成两个子元素</p>\n<img src="http://mdrs.yuanjin.tech/img/20210514140049.png" alt="image-20210514140049244" style="zoom:50%;" />\n<p>使用伪元素可以避免在 HTML 中使用过多的空元素</p>\n<p><strong>伪元素必须要有<code>content</code>属性，否则不能生效，如果不需要有元素内容，设置<code>content:\'\'</code></strong></p>\n<h2 id="%E5%B9%B3%E6%BB%91%E6%BB%9A%E5%8A%A8-1" tabindex="-1">平滑滚动</h2>\n<blockquote>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-behavior">MDN 详细文档</a></p>\n</blockquote>\n<p>使用<code>scroll-behavior: smooth</code>，可以让滚动更加丝滑</p>\n<p>参见 MDN 效果即可</p>\n',
      category: { id: 65, name: "CSS" },
    },
  },
  5: {
    code: 200,
    data: {
      id: 5,
      title: "webpack原理",
      description: "了解经典工程化打包工具原理",
      scanNumber: "1",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "webpack",
          name: "webpack",
          tag: "h1",
          children: [
            { anchor: "%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9F", name: "为什么要工程化？", tag: "h2", children: [] },
            { anchor: "%E5%8E%9F%E7%90%86", name: "原理", tag: "h2", children: [] },
            {
              anchor: "%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86",
              name: "编译原理",
              tag: "h2",
              children: [
                { anchor: "1.-%E5%88%9D%E5%A7%8B%E5%8C%96", name: "1. 初始化", tag: "h3", children: [] },
                { anchor: "2.-%E7%BC%96%E8%AF%91", name: "2. 编译", tag: "h3", children: [] },
                { anchor: "3.-%E8%BE%93%E5%87%BA-emit", name: "3. 输出 emit", tag: "h3", children: [] },
              ],
            },
            { anchor: "loader", name: "loader", tag: "h2", children: [] },
            { anchor: "plugins", name: "plugins", tag: "h2", children: [] },
            { anchor: "webpack.config", name: "webpack.config", tag: "h2", children: [] },
          ],
        },
      ],
      htmlContent:
        '<h1 id="webpack" tabindex="-1">webpack</h1>\n<h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%B7%A5%E7%A8%8B%E5%8C%96%EF%BC%9F" tabindex="-1">为什么要工程化？</h2>\n<p><strong>注:node 环境是读取本地文件,不存在此问题</strong>\n<code>devtime</code>:</p>\n<ol>\n<li>模块细粒度</li>\n<li>直接不同模块标准 <strong>CommonJs,ESModule</strong></li>\n<li>使用新语法 <strong>ESNext</strong></li>\n</ol>\n<p><code>runtime</code>:</p>\n<ol>\n<li>文件越少越好:请求少</li>\n<li>体积小：压缩</li>\n<li>越乱越好：不想被篡改逻辑，不想被抄</li>\n<li>执行效率高</li>\n</ol>\n<h2 id="%E5%8E%9F%E7%90%86" tabindex="-1">原理</h2>\n<p>コンパイル結果</p>\n<pre><code class="language-ts">//通过函数环境来避免污染全局变量\n;(function (modules) {\n  const cachedModules = {}\n  //定义一个类似于node环境的require,运行js代码,返回exports\n  function __webpack_require(path) {\n    if (cachedModules[path]) {\n      return cachedModules[path].exports\n    }\n    const module = (cachedModules[path] = {\n      id: path,\n      loaded: false,\n      exports: {},\n    })\n    const exports = module.exports\n    modules[path].call(exports, module, exports, __webpack_require)\n    module.loaded = true\n    return module.exports\n  }\n  __webpack_require.entry = &quot;&quot;\n  __webpack_require.cache = cachedModules\n  return __webpack_require((__webpack_require.entry = &quot;./src/index.js&quot;))\n})({\n  //类似于node环境的commonjs导入\n  // _temp(module,exports, require,__dirname,__filename)只能说除了__dirname,__filename,都一样\n  &quot;./src/a.js&quot;: function (module, exports, require) {\n    //  const a = 1\n    //  console.log(a);\n    //  module.exports = {\n    // \ta\n    //  }\n    //但是这样做会让使用的控制台输出都在当前的js里面,\n    //这肯定是不行的,我们是想去模块里面,eval相当于新开了一个虚拟环境\n    eval(\n      `\n\t\t\tconst a = 1\n\t\t\tconsole.log(a);\n\t\t\tmodule.exports = {\n\t\t\t   a\n\t\t\t} \n\t\t\t` + &quot;//# sourceURL=webpack:///./src/a.js?&quot;\n    )\n  },\n  &quot;./src/b.js&quot;: function (module, exports, require) {\n    const b = 2\n    exports.b = 2\n  },\n  &quot;./src/index.js&quot;: function (module, exports, require) {\n    const a = require(&quot;./src/a.js&quot;)\n    const b = require(&quot;./src/b.js&quot;)\n    console.log(a)\n    console.log(b)\n  },\n})\n</code></pre>\n<h2 id="%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86" tabindex="-1">编译原理</h2>\n<h3 id="1.-%E5%88%9D%E5%A7%8B%E5%8C%96" tabindex="-1">1. 初始化</h3>\n<p><strong>加载配置</strong></p>\n<p>类似于 css 计算 <code>computed style</code>,会将 cli 参数,webpack.config.js,默认配置进行融合,生成最终配置对象\n依托于 <code>yargs</code> 库</p>\n<h3 id="2.-%E7%BC%96%E8%AF%91" tabindex="-1">2. 编译</h3>\n<ol>\n<li>\n<p>创建 chunk\nwhat’s chunk?\n根据入口,找所有依赖。每个入口对应一个 chunk</p>\n<pre><code class="language-ts">interface chunk {\n  name: &quot;main&quot; //只有一个入口就是main\n  id: string //开发环境就是name,生产环境会变成数字\n  hash: string //产生chunk assets时,根据所有文件内容生成chunk hash\n}\n</code></pre>\n</li>\n<li>\n<p>构建依赖</p>\n</li>\n</ol>\n<pre><code class="language-ts">interface IChunkModules {\n  //一般是路径,统一转换完整相对路径./src/**/* ./node_modules/**/*\n  [moduleId: string]: string //转换后的代码\n}\nconst moduleCache: IChunkModules = {}\nfunction createDepencies(entryPath) {\n  //1. 判断是否已经加载过该模块\n  if (moduleCache[entryPath]) {\n    return\n  }\n  //2. 没用加载就开始解析\n  // 1) 读取内容\n  const content = fs.readFileSync(entryPath)\n  // 2) AST 抽象语法数分析 这是一棵树\n  const astResult = AST(content)\n  // 3) 遍历树 获取所有依赖 require,import,记录为完整相对路径\n  const dependencies: string[] = loopTree(astResult)\n  // 4) 替换依赖函数 require=&gt;__webpack_require\n  // 5）保存替换后的代码\n  moduleCache[entryPath] = content.replaceAll(&quot;require&quot;, &quot;__webpack_require&quot;) //肯定不能这样写吧\n  // 6) 递归dependencies,深度优先\n  dependencies.forEach((path) =&gt; createDepencies(path))\n}\n</code></pre>\n<ol start="3">\n<li>产生 chunk assets(资源列表) <code>bundle</code>\n根据 chunk 的 modules 生成资源列表。每个项就是对应一个具体文件。也叫 bundle</li>\n</ol>\n<pre><code class="language-ts">{\n\t[文件名: string]:文件内容\n\t\'./dist/bundle.js\':(function (modules){})({\n\t   \'./src/a.js\':function (module,exports,require){\n\t\t\t//  const a = 1\n         //  console.log(a);\n\t\t\t//  module.exports = {\n\t\t\t// \ta\n\t\t\t//  }\n\t\t\t //但是这样做会让使用的控制台输出都在当前的js里面,\n\t\t\t //这肯定是不行的,我们是想去模块里面,eval相当于新开了一个虚拟环境\n\t\t\teval(`\n\t\t\tconst a = 1\n\t\t\tconsole.log(a);\n\t\t\tmodule.exports = {\n\t\t\t   a\n\t\t\t}\n\t\t\t`+&quot;//# sourceURL=webpack:///./src/a.js?&quot;);\n\t\t},\n})\n</code></pre>\n<ol start="4">\n<li>合并 chunk assets(可能有多个 chunk)\n合并 chunk assets,生成总 hash</li>\n</ol>\n<h3 id="3.-%E8%BE%93%E5%87%BA-emit" tabindex="-1">3. 输出 emit</h3>\n<p>将合并后 chunk assets 通过 fs 模块输出</p>\n<h2 id="loader" tabindex="-1">loader</h2>\n<p>本质: 文件内容=&gt;可以别分析(js 内容)</p>\n<pre><code class="language-ts">  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/, //路径匹配\n        // use: [&quot;ts-loader&quot;],//loader路径配置,其实用的就是node的require\n        use: [\n          {\n            loader: [&quot;ts-loader&quot;],\n            options: {\n\t\t\t\t//配置通过loader-utils取this上读取\n\t\t\t},\n          },\n        ],\n        exclude: /node_modules/,\n      },\n    ],\n  },\n</code></pre>\n<p><strong>注:loaders 是倒着执行的,类似于 decorator</strong></p>\n<pre><code class="language-ts">{\n  module: {\n    rules: [\n      {\n        test: /\\.js/,\n        use: [&quot;./src/loaders/testloader/loader&quot;, &quot;./src/loaders/testloader/loader2&quot;],\n      },\n      {\n        test: /test\\.js/,\n        use: [&quot;./src/loaders/testloader/loader3&quot;, &quot;./src/loaders/testloader/loader2&quot;],\n      },\n    ]\n  }\n}\n\n// 输出结果\n2\n3\n2\n1\n\n// 原理\n\nlet fscontent = xxx\nconst rules = []\n///\\.js/匹配成功\nrules.push(...[&quot;./src/loaders/testloader/loader&quot;, &quot;./src/loaders/testloader/loader2&quot;])\n///test\\.js/ 匹配成功\nrules.push(...[&quot;./src/loaders/testloader/loader3&quot;, &quot;./src/loaders/testloader/loader2&quot;])\n\nfor (let i = rules.length - 1; i + 1; i--) {\n  const loader = require(rules[i])\n  //将fs读取内容交给loader\n  fscontent = loader(fscontent)\n}\nreturn fscontent\n</code></pre>\n<p>例 css loader</p>\n<pre><code class="language-ts">//entry.js\nrequire(&quot;./style/index.css&quot;)\n//require本身肯定是不能读取css\n//webpack是肯定能读取出来文件内容的,错误发生在抽象AST分析那块\n//也就是说只有通过loader,将文件内容=&gt;可以别分析(js内容)就行\n\n// webpack.config.js\n//\n {\n        test: /\\.css/,\n        use: [&quot;./src/loaders/cssLoader&quot;],\n }\n\n //loader\n module.exports = function (sourceCode) {\n  const res = `\n    const style = document.createElement(&quot;style&quot;)\n    style.innerHTML = \\`${sourceCode}\\`\n    document.head.appendChild(style)\n    module.exports = \\`${sourceCode}\\`\n  `\n  //   console.log(res)\n  return res\n}\n</code></pre>\n<h2 id="plugins" tabindex="-1">plugins</h2>\n<p>与 loaders 不同,plugins 是用于处理 webpack 编译过程中的 hooks</p>\n<pre><code class="language-ts">import { Compilation, Compiler } from &quot;webpack&quot;\n\nclass Compiler {\n  //创建于初始化阶段\n  //编译与输出这些操作是内部创建的Compilation完成\n  // watch时,重新编译只是重新创建Compilation\n}\n//统计bundle大小的plugins\nclass MyPlugin {\n  //创建Compiler之后就会运行apply\n  apply(compiler: Compiler) {\n    compiler.hooks.emit.tap(&quot;MyFilePlugin&quot;, (compilation) =&gt; {\n      const assets = Object.keys(compilation.assets)\n      const res = assets\n        .map((x) =&gt; {\n          const size = compilation.assets[x].size()\n\n          return `[${x}]:\n    \t  size:${size / 1000}kb\n    \t`\n        })\n        .join(&quot;\\n\\n&quot;)\n      compilation.assets[this.filmeName] = {\n        source() {\n          return res\n        },\n        size() {\n          return Buffer.from(res).byteLength\n        },\n      }\n    })\n  }\n}\n</code></pre>\n<h2 id="webpack.config" tabindex="-1">webpack.config</h2>\n<p>导出可以使用函数,增加可操作性</p>\n<pre><code class="language-ts">module.export = (env) =&gt; {\n  return {\n    entry: {\n      main: &quot;./src/index.js&quot;,\n    },\n  }\n}\n</code></pre>\n',
      category: { id: 67, name: "Webpack" },
    },
  },
  6: {
    code: 200,
    data: {
      id: 6,
      title: "node包管理器",
      description: "常见包管理器及其区别",
      scanNumber: "0",
      commentNumber: "4",
      createDate: "2024-09-16",
      toc: [
        {
          anchor: "npm-node-package-manager",
          name: "npm node package manager",
          tag: "h1",
          children: [
            { anchor: "%E5%8E%86%E5%8F%B2", name: "历史", tag: "h2", children: [] },
            { anchor: "%E8%AE%BE%E7%BD%AE%E4%B8%8B%E8%BD%BD%E6%BA%90", name: "设置下载源", tag: "h2", children: [] },
            { anchor: ".gitignore", name: ".gitignore", tag: "h2", children: [] },
            { anchor: "%E5%AE%89%E8%A3%85-npm-install", name: "安装 npm install", tag: "h2", children: [] },
            {
              anchor: "%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-npm-init",
              name: "配置文件 npm init",
              tag: "h2",
              children: [
                { anchor: "package.json", name: "package.json", tag: "h3", children: [] },
                { anchor: "package-lock.json", name: "package-lock.json", tag: "h3", children: [] },
              ],
            },
            { anchor: "%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC", name: "语义版本", tag: "h2", children: [] },
            { anchor: "script", name: "script", tag: "h2", children: [] },
            { anchor: "json-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8", name: "json 文件的使用", tag: "h2", children: [] },
            { anchor: "%E5%91%BD%E4%BB%A4", name: "命令", tag: "h2", children: [] },
            { anchor: "%E5%8F%91%E5%B8%83", name: "发布", tag: "h2", children: [] },
          ],
        },
        { anchor: "yarn", name: "yarn", tag: "h1", children: [] },
        { anchor: "cnpm-%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89", name: "cnpm 没有意义", tag: "h1", children: [] },
        {
          anchor:
            "nvm-node-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5-nvm%2C%E5%A4%A7%E6%A6%82%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%87%BA%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4%2C%E5%B9%B2%E5%95%A5%E7%9A%84",
          name: "nvm node 版本管理工具 安装之后直接 nvm,大概就能看出来哪些命令,干啥的",
          tag: "h1",
          children: [],
        },
        { anchor: "pnpm", name: "pnpm", tag: "h1", children: [{ anchor: "pnpm-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84", name: "pnpm 目录结构", tag: "h3", children: [] }] },
      ],
      htmlContent:
        '<h1 id="npm-node-package-manager" tabindex="-1">npm node package manager</h1>\n<h2 id="%E5%8E%86%E5%8F%B2" tabindex="-1">历史</h2>\n<p>node 模块化 ==&gt; 第三方 lib 发展==&gt;包管理复杂化==&gt;npm 应运而生==&gt;node 发展 npmjs.com，cli=&gt;command-line interface</p>\n<h2 id="%E8%AE%BE%E7%BD%AE%E4%B8%8B%E8%BD%BD%E6%BA%90" tabindex="-1">设置下载源</h2>\n<p>registry(注册) 数据库服务器\nnpm config set registry https://registry.npm.taobao.org\nnmp config get registry</p>\n<h2 id=".gitignore" tabindex="-1">.gitignore</h2>\n<p>node_modules\n源码要忽略 node_modules</p>\n<h2 id="%E5%AE%89%E8%A3%85-npm-install" tabindex="-1">安装 npm install</h2>\n<p>npm install axios jquery 可以一下安装多个\nnpm i axios jquery\n(以前要加 --save/-S 保存到 package.json 里面,现在不需要)\nnpm i prettier -D/--save-dev 安装到 dev 里面\nnpm i typescript --global/-g</p>\n<p>npm i --production 只安装生产环境包</p>\n<p>有些 package 会提供 cli\n这时这些命令会存在 node_module/.bin 通过 npx 运行 (非全局安装)\nusr/appdata/roaming/npm</p>\n<h2 id="%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-npm-init" tabindex="-1">配置文件 npm init</h2>\n<h3 id="package.json" tabindex="-1">package.json</h3>\n<p>大部分看名字就知道了，就略了\nmain:\'index.js\' entry point 0. 是不是 node 内部模块 require(\'fs\')\nrequire(\'jquery\') =&gt; 1.当文件找 node_modules/jquery.js 如果找不到就 2 2.当包来找 有没有 package.json 且配置了 main, 有就 node_modules/jquery/${main}.js\n没有就 node_modules/jquery/index.js 3.返回上一级重复</p>\n<h3 id="package-lock.json" tabindex="-1">package-lock.json</h3>\n<p>有时，依赖过于复杂，可能不同 package 依赖同一个 package 的不太大版本，各种冲突\nlock 记录了此项目的所有确切依赖关系\n项目中存在 package-lock.json 时，会安装 package-lock.json 内容，不存在才会安装 package.json</p>\n<h2 id="%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC" tabindex="-1">语义版本</h2>\n<p>你编写一个包依赖一个 package，别人安装你的包的时候，你想要他安装的 package 是和你的一样还是可以最新？</p>\n<pre><code class="language-js">   &gt; 大于版本\n\t  &gt;=\n\t  &lt;\n\t  &lt;=\n\t  - 1.2.1-3.4.1 之间\n\t  x  1.1.x  补丁版本号随意\n\t  ~  ~1.1.6  补丁版本&gt;=6\n\t  ^  ^4.4.0  主版本不变\n\t  *  lastest 最新\n</code></pre>\n<h2 id="script" tabindex="-1">script</h2>\n<pre><code> 脚本里面可以省略npx\n start、test、stop可以省略run\n npm start 默认serve.js\n\n ```js\n   start: &quot;nodemon script/start.js&quot;\n ```\n ## 环境变量\n 1. 永久设置 process.env.NODE_ENV (系统环境变量里面加一个NODE_ENV变量) 但不推荐\n 2. 临时设置 windows: set NODE_ENV=development\n             mac: export NODE_ENV=development\n\t\t\t 可以用插件在script中兼容\n</code></pre>\n<h2 id="json-%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8" tabindex="-1">json 文件的使用</h2>\n<p>直接 require</p>\n<pre><code class="language-js">const json = require(&quot;./package.json&quot;)\n</code></pre>\n<h2 id="%E5%91%BD%E4%BB%A4" tabindex="-1">命令</h2>\n<ol>\n<li>\n<p>精确安装最新版\nnpm i --save-exact/-E package &lt;=&gt; &quot;konva&quot;: &quot;9.3.6&quot;(此时的最新版)</p>\n</li>\n<li>\n<p>指定版本\nnpm i lodash@2.1.1</p>\n</li>\n<li>\n<p>查询安装路径\nnpm root [-g]</p>\n</li>\n<li>\n<p>查看包的信息(直接看官网的)\nnpm view vue\nview aliases:v info show</p>\n</li>\n<li>\n<p>查看安装包\nnpm list [-g] [--depth=\'依赖深度\']\nlist aliases:ls la ll</p>\n</li>\n<li>\n<p>查看可以更新包\nnpm outdated</p>\n</li>\n<li>\n<p>更新\nnpm update [-g] [package]\nupdate aliases: up, upgrade</p>\n</li>\n<li>\n<p>卸载\nnpm uninstall [-g] package</p>\n</li>\n<li>\n<p>npm config ls [-l] [--json] 查看生效的配置</p>\n</li>\n<li>\n<p>npm config get/set/delete 配置 npm config get registry</p>\n</li>\n<li>\n<p>查看依赖包 漏洞\nnpm audit</p>\n</li>\n<li>\n<p>查看为啥安装这个包\nnpm explain vue</p>\n</li>\n</ol>\n<p>更新 npm:\nnpm i npm -g 全局安装 npm 最新版,此时的 npm 将使用全局的 npm 命令\nnpm update -g npm 更新全局安装的 npm</p>\n<h2 id="%E5%8F%91%E5%B8%83" tabindex="-1">发布</h2>\n<p>注册 npm 官网账号\nnpm cli 登录\nnpm login/logout\nnpm whoami\n填写 packjson</p>\n<p>添加 LICENSE http://choosealicense.online/appendix\n添加 README.MD\nnpm publish</p>\n<h1 id="yarn" tabindex="-1">yarn</h1>\n<p>当时的 npm 很垃圾,串行下载啊,非扁平结构,输出繁琐,没有 npx……\n于是 Facebook,chrome 等大公司就制作了 yarn,优化 npm 操作\n现在的 npm 与 yarn 的差别不大</p>\n<h2 id="%E5%91%BD%E4%BB%A4-1" tabindex="-1">命令</h2>\n<p>yarn init --yes/-y</p>\n<p>yarn [global/-g] add package@ package [--dev/-D] [--exact/-E]</p>\n<p>yarn install [--production/--prod] 安装所有</p>\n<p>yarn run script (start,stop,test)可以省略 run\nyarn run package 内置命令 (npx 学的它)</p>\n<p>yarn [global/-g] bin 查看包的命令文件夹\nyarn info package 字段名\nyarn [global/-g] list [--depth]</p>\n<p>yarn outdate</p>\n<p>yarn [global/-g] update</p>\n<p>yarn remove package</p>\n<p>yarn check 查看 package.json 与 yarn.lock 是否匹配\nyarn audit\nyarn why</p>\n<p>yarn create 用于安装脚手架\n过去的做法</p>\n<ol>\n<li>全局安装 yarn add create-react-app -g</li>\n<li>运行脚手架命令 create-react-app my-app\n使用 yarn create\nyarn create react-app my-app</li>\n</ol>\n<h1 id="cnpm-%E6%B2%A1%E6%9C%89%E6%84%8F%E4%B9%89" tabindex="-1">cnpm 没有意义</h1>\n<p>现在可以使用 npm config set registry 修改,</p>\n<h1 id="nvm-node-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%E7%9B%B4%E6%8E%A5-nvm%2C%E5%A4%A7%E6%A6%82%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%87%BA%E6%9D%A5%E5%93%AA%E4%BA%9B%E5%91%BD%E4%BB%A4%2C%E5%B9%B2%E5%95%A5%E7%9A%84" tabindex="-1">nvm node 版本管理工具 安装之后直接 nvm,大概就能看出来哪些命令,干啥的</h1>\n<p>nvm install\nnvm use</p>\n<h1 id="pnpm" tabindex="-1">pnpm</h1>\n<p>简洁的 node_modules 目录\n避免使用间接依赖\n降低磁盘占用<br>\n原理: 直接下载到到当前盘副的根目录,每次安装如果存在会直接建立链接非拷贝(类似快捷方式),也就是说包存在一份\n回到了树形结构</p>\n<p>[扩展] 文件本质是一个指向外部存储的指针\n删除的是指针,所以删除和大小无关。也是为啥数据可以恢复的原因。</p>\n<pre><code>\t 硬链接：unix操作系统中,将一个新指针指向当前位置,相当于引用\n\t         现在windows中也支持硬链接\n\t\t\t mklink /h 链接名称 目标文件(只能是文件不能是文件夹)\n\t\t\t 删除不影响硬链接\n\t 软链接(符号链接): 指向文件夹或文件\n\t         mklin /d 链接名称 目标文件\n\t\t\t 符号链接始终和链接内容关联\n\n\tnode中: node无法区分是不是硬链接\n\t        软链接会找到原始位置执行\n\tpnpm 的结构是\n</code></pre>\n<h3 id="pnpm-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" tabindex="-1">pnpm 目录结构</h3>\n<pre><code class="language-ts">node_modules\n  .pnpm\n\t node_modules  // 所有间接依赖\n     registry      // 所有直接依赖资源  每个依赖都包含着版本\n\t\t  node_modules\n\t\t  自己的源码 硬链接\n\t\t  直接依赖  registry下面依赖的软链接\n\n   librarys //.pnpm 下面 registry 下面直接依赖的软链接\n</code></pre>\n',
      category: { id: 74, name: "NPM" },
    },
  },
} as unknown as Record<any, IResponse<IDetailArticle>>

export const blogComments = {
  2: {
    code: 200,
    data: {
      total: 4,
      rows: [
        { nickname: "mock", id: 1, content: "nodeって侮らないな", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar4.jpg" },
        { nickname: "mock", id: 2, content: "+1", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar8.jpg" },
        { nickname: "mock", id: 3, content: "excellent", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar2.jpg" },
        { nickname: "mock", id: 9, content: "原来这就是Node", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar6.jpg" },
      ],
    },
  },
  3: {
    code: 200,
    data: {
      total: 4,
      rows: [
        { nickname: "mock", id: 4, content: "谢谢博主", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar6.jpg" },
        { nickname: "mock", id: 6, content: "知らなかったjs知識だ", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar4.jpg" },
        { nickname: "mock", id: 7, content: "+1", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar8.jpg" },
        { nickname: "mock", id: 8, content: "excellent", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar2.jpg" },
      ],
    },
  },
  4: {
    code: 200,
    data: {
      total: 4,
      rows: [
        { nickname: "mock", id: 13, content: "谢谢博主", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar6.jpg" },
        { nickname: "mock", id: 14, content: "css3便利ですね", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar4.jpg" },
        { nickname: "mock", id: 15, content: "+1", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar8.jpg" },
        { nickname: "mock", id: 16, content: "usefull", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar2.jpg" },
      ],
    },
  },
  5: {
    code: 200,
    data: {
      total: 4,
      rows: [
        { nickname: "mock", id: 17, content: "谢谢博主", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar6.jpg" },
        { nickname: "mock", id: 18, content: "これがwebpackの原理か", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar4.jpg" },
        { nickname: "mock", id: 19, content: "+1", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar8.jpg" },
        { nickname: "mock", id: 20, content: "usefull", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar2.jpg" },
      ],
    },
  },
  6: {
    code: 200,
    data: {
      total: 4,
      rows: [
        { nickname: "mock", id: 21, content: "谢谢博主", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar6.jpg" },
        { nickname: "mock", id: 22, content: "npm", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar4.jpg" },
        { nickname: "mock", id: 23, content: "+1", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar8.jpg" },
        { nickname: "mock", id: 24, content: "good", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar2.jpg" },
      ],
    },
  },
  1: {
    code: 200,
    data: {
      total: 4,
      rows: [
        { nickname: "mock", id: 5, content: "原来这就是HTTP", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar6.jpg" },
        { nickname: "mock", id: 10, content: "+1", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar8.jpg" },
        { nickname: "mock", id: 11, content: "good", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar2.jpg" },
        { nickname: "mock", id: 12, content: "なるほど", createDate: "2024-09-16", avatar: "https://qiheizhiya.oss-cn-shenzhen.aliyuncs.com/image/avatar4.jpg" },
      ],
    },
  },
} as unknown as Record<any, IResponse<{ total: number; rows: ICommentItem[] }>>
